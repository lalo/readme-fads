<div class="announce instapaper_body md" data-path="README.md" id="readme"><article class="markdown-body entry-content" itemprop="mainContentOfPage"><p><a href="http://travis-ci.org/eligosource/eventsourced"><img src="https://camo.githubusercontent.com/2b7afb24d258d77f8a97240871e1f08dcb77ed17/68747470733a2f2f7365637572652e7472617669732d63692e6f72672f656c69676f736f757263652f6576656e74736f75726365642e706e67" alt="Build Status" data-canonical-src="https://secure.travis-ci.org/eligosource/eventsourced.png" style="max-width:100%;"></a></p>

<h1>
<a name="user-content-eventsourced" class="anchor" href="#eventsourced" aria-hidden="true"><span class="octicon octicon-link"></span></a>Eventsourced</h1>

<table border="0">
<tr>
<td>Scala version: </td>
    <td>2.10.2</td>
  </tr>
<tr>
<td>Akka version: </td>
    <td>2.2.0</td>
  </tr>
</table><ul class="task-list">
<li><a href="https://github.com/eligosource/eventsourced/wiki#releases">Releases</a></li>
<li><a href="https://github.com/eligosource/eventsourced/wiki/Installation">Installation</a></li>
</ul><h2>
<a name="user-content-contents" class="anchor" href="#contents" aria-hidden="true"><span class="octicon octicon-link"></span></a>Contents</h2>

<ul class="task-list">
<li>
<a href="#overview">Overview</a>

<ul class="task-list">
<li>
<a href="#building-blocks">Building blocks</a>

<ul class="task-list">
<li><a href="#processor">Processor</a></li>
<li><a href="#channel">Channel</a></li>
<li><a href="#journal">Journal</a></li>
</ul>
</li>
<li><a href="#application">Application</a></li>
<li><a href="#journals">Journals</a></li>
</ul>
</li>
<li><a href="#terminology">Terminology</a></li>
<li>
<a href="#first-steps">First steps</a>

<ul class="task-list">
<li><a href="#step-1-eventsourcingextension-initialization">Step 1: EventsourcingExtension initialization</a></li>
<li><a href="#step-2-event-sourced-actor-definition">Step 2: Event-sourced actor definition</a></li>
<li><a href="#step-3-event-sourced-actor-creation-and-recovery">Step 3: Event-sourced actor creation and recovery</a></li>
<li><a href="#step-4-event-sourced-actor-usage">Step 4: Event-sourced actor usage</a></li>
<li><a href="#step-5-channel-usage">Step 5: Channel usage</a></li>
</ul>
</li>
<li>
<a href="#stackable-traits">Stackable traits</a>

<ul class="task-list">
<li><a href="#eventsourced-1">Eventsourced</a></li>
<li><a href="#receiver">Receiver</a></li>
<li><a href="#emitter">Emitter</a></li>
<li><a href="#confirm">Confirm</a></li>
<li><a href="#modified-example">Modified example</a></li>
</ul>
</li>
<li><a href="#sender-references">Sender references</a></li>
<li>
<a href="#channels">Channels</a>

<ul class="task-list">
<li><a href="#defaultchannel">DefaultChannel</a></li>
<li><a href="#reliablechannel">ReliableChannel</a></li>
<li><a href="#reliable-request-reply-channel">Reliable request-reply channel</a></li>
<li>
<a href="#usage-hints">Usage hints</a>

<ul class="task-list">
<li><a href="#eventsourced-usage">Eventsourced usage</a></li>
<li><a href="#standalone-usage">Standalone usage</a></li>
<li><a href="#remote-destinations">Remote destinations</a></li>
</ul>
</li>
<li><a href="#channel-alternatives">Channel alternatives</a></li>
</ul>
</li>
<li>
<a href="#recovery">Recovery</a>

<ul class="task-list">
<li>
<a href="#replay-parameters">Replay parameters</a>

<ul class="task-list">
<li><a href="#recovery-without-snapshots">Recovery without snapshots</a></li>
<li><a href="#recovery-with-snapshots">Recovery with snapshots</a></li>
</ul>
</li>
<li><a href="#await-processing">Await processing</a></li>
<li><a href="#non-blocking-recovery">Non-blocking recovery</a></li>
<li><a href="#channel-recovery-and-usage">Channel recovery and usage</a></li>
<li><a href="#state-dependencies">State dependencies</a></li>
</ul>
</li>
<li>
<a href="#snapshots">Snapshots</a>

<ul class="task-list">
<li><a href="#configuration">Configuration</a></li>
</ul>
</li>
<li><a href="#behavior-changes">Behavior changes</a></li>
<li><a href="#event-series">Event series</a></li>
<li><a href="#idempotency">Idempotency</a></li>
<li><a href="#serialization">Serialization</a></li>
<li>
<a href="#further-examples">Further examples</a>

<ul class="task-list">
<li><a href="#order-management">Order management</a></li>
<li><a href="#state-machines">State machines</a></li>
<li><a href="#clustering">Clustering</a></li>
</ul>
</li>
<li>
<a href="#miscellaneous">Miscellaneous</a>

<ul class="task-list">
<li><a href="#multicast-processor">Multicast processor</a></li>
<li><a href="#retroactive-changes">Retroactive changes</a></li>
</ul>
</li>
<li><a href="#appendix-a-legend">Appendix A: Legend</a></li>
<li><a href="#appendix-b-project">Appendix B: Project</a></li>
<li><a href="#appendix-c-articles">Appendix C: Articles</a></li>
<li><a href="#appendix-d-support">Appendix D: Support</a></li>
</ul><h2>
<a name="user-content-overview" class="anchor" href="#overview" aria-hidden="true"><span class="octicon octicon-link"></span></a>Overview</h2>

<p>The Eventsourced library adds scalable actor state persistence and at-least-once message delivery guarantees to <a href="http://akka.io/">Akka</a>. With Eventsourced, stateful actors</p>

<ul class="task-list">
<li>persist received messages by appending them to a log (journal)</li>
<li>project received messages to derive current state</li>
<li>usually hold current state in memory (memory image)</li>
<li>recover current (or past) state by replaying received messages (during normal application start or after crashes)</li>
<li>never persist current state directly (except optional state <a href="#snapshots">snapshots</a> for recovery time optimization)</li>
</ul><p>In other words, Eventsourced implements a write-ahead log (WAL) that is used to keep track of messages an actor receives and to recover its state by replaying logged messages. Appending messages to a log instead of persisting actor state directly allows for actor state persistence at very high transaction rates and supports efficient replication. In contrast to other WAL-based systems, Eventsourced usually keeps the whole message history in the log and makes usage of state snapshots optional.</p>

<p>Logged messages represent intended changes to an actor's state. Logging changes instead of updating current state is one of the core concept of <a href="http://martinfowler.com/eaaDev/EventSourcing.html">event sourcing</a>. Eventsourced can be used to implement event sourcing concepts but it is not limited to that. More details about Eventsourced and its relation to event sourcing can be found at <a href="https://github.com/eligosource/eventsourced/wiki/FAQ#wiki-event-sourcing-comparison"><em>How does Eventsourced persist actor state and how is this related to event sourcing</em></a>.</p>

<p>Eventsourced can also be used to make message exchanges between actors reliable so that they can be resumed after crashes, for example. For that purpose, channels with at-least-once message delivery guarantees are provided. Channels also prevent that output messages, sent by persistent actors, are redundantly delivered during replays which is relevant for message exchanges between these actors and other services.</p>

<h3>
<a name="user-content-building-blocks" class="anchor" href="#building-blocks" aria-hidden="true"><span class="octicon octicon-link"></span></a>Building blocks</h3>

<p>The core building blocks provided by Eventsourced are processors, channels and journals. These are managed by an Akka extension, the <a href="http://eligosource.github.com/eventsourced/api/snapshot/#org.eligosource.eventsourced.core.EventsourcingExtension"><code>EventsourcingExtension</code></a>.</p>

<h4>
<a name="user-content-processor" class="anchor" href="#processor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Processor</h4>

<p>A processor is a stateful actor that logs (persists) messages it receives. A stateful actor is turned into a processor by modifying it with the stackable <a href="http://eligosource.github.com/eventsourced/api/snapshot/#org.eligosource.eventsourced.core.Eventsourced"><code>Eventsourced</code></a> trait during construction. A processor can be used like any other actor.</p>

<p>Messages wrapped inside <a href="http://eligosource.github.com/eventsourced/api/snapshot/#org.eligosource.eventsourced.core.Message"><code>Message</code></a> are logged by a processor, unwrapped messages are not logged. Wrapped messages are often referred to as <em>events</em> in this user guide. Wrapped messages can also be <em>commands</em>, as explained in section <a href="#application">Application</a>.</p>

<p>Logging behavior is implemented by the <code>Eventsourced</code> trait, a processor's <code>receive</code> method doesn't need to care about that. Acknowledging a successful write to a sender can be done by sending a reply. A processor can also hot-swap its behavior by still keeping its logging functionality.</p>

<p>Processors are registered at an <code>EventsourcingExtension</code>. This extension provides methods to recover processor state by replaying logged messages. Processors can be registered and recovered at any time during an application run.</p>

<p>Eventsourced doesn't impose any restrictions how processors maintain state. A processor can use vars, mutable data structures or STM references, for example.</p>

<h4>
<a name="user-content-channel" class="anchor" href="#channel" aria-hidden="true"><span class="octicon octicon-link"></span></a>Channel</h4>

<p><a href="#channels">Channels</a> are used by processors for sending messages to other actors (channel destinations) and receiving replies from them. Channels</p>

<ul class="task-list">
<li>require their destinations to confirm the receipt of messages for providing at-least-once delivery guarantees (explicit ack-retry protocol). Receipt confirmations are written to a log.</li>
<li>prevent redundant delivery of messages to destinations during processor recovery (replay of messages). Replayed messages with matching receipt confirmations are dropped by the corresponding channels.</li>
</ul><p>A channel itself is an actor that decorates a destination with the aforementioned functionality. Processors usually create channels as child actors for decorating destination actor references.</p>

<p>A processor may also sent messages directly to another actor without using a channel. In this case that actor will redundantly receive messages during processor recovery.</p>

<p>Eventsourced provides three different channel types (more are planned).</p>

<ul class="task-list">
<li>Default channel

<ul class="task-list">
<li>Does not store received messages.</li>
<li>Re-delivers uncomfirmed messages only during recovery of the sending processor.</li>
<li>Order of messages as sent by a processor is not preserved in failure cases.</li>
</ul>
</li>
<li>Reliable channel

<ul class="task-list">
<li>Stores received messages.</li>
<li>Re-delivers unconfirmed messages based on a configurable re-delivery policy.</li>
<li>Order of messages as sent by a processor is preserved, even in failure cases.</li>
<li>Often used to deal with unreliable remote destinations.</li>
<li>Can recover from crashes of the JVM it is running in.</li>
</ul>
</li>
<li>Reliable request-reply channel

<ul class="task-list">
<li>Same as reliable channel but additionally guarantees at-least-once delivery of replies.</li>
<li>Order of replies not guaranteed to correspond to the order of sent request messages.</li>
</ul>
</li>
</ul><p>Eventsourced channels are not meant to replace any existing messaging system but can be used, for example, to reliably connect processors to such a system, if needed. More generally, they are useful to integrate processors with other services, as described in <a href="http://krasserm.blogspot.de/2013/01/event-sourcing-and-external-service.html">this article</a>.</p>

<h4>
<a name="user-content-journal" class="anchor" href="#journal" aria-hidden="true"><span class="octicon octicon-link"></span></a>Journal</h4>

<p>A journal is an actor that is used by processors and channels to log messages and receipt confirmations. The quality of service (availability, scalability, ...) provided by a journal depends on the used storage technology. The <a href="#journals">Journals</a> section below gives an overview of existing journal implementations and their development status.</p>

<h3>
<a name="user-content-application" class="anchor" href="#application" aria-hidden="true"><span class="octicon octicon-link"></span></a>Application</h3>

<p>The Eventsourced library doesn't impose any restrictions on the structure and semantics of <a href="http://eligosource.github.com/eventsourced/api/snapshot/#org.eligosource.eventsourced.core.Message"><code>Message</code></a> payloads. Hence, persistent messages can therefore be events as well as commands. Both can be seen as <em>facts</em> about the interaction of an application with its environment. This is demonstrated in the Eventsourced <a href="https://github.com/eligosource/eventsourced-example">reference application</a> which persists events as well as commands. This also simplifies the implementation of long-running, persistent business processes (sometimes referred to as <em>sagas</em>). These are processors that react on events by sending commands to other services which can be other processors or external services, for example.</p>

<p>Eventsourced fits well into applications that implement the <a href="http://martinfowler.com/bliki/CQRS.html">CQRS</a> pattern and follow a <a href="http://domaindrivendesign.org/resources/what_is_ddd">domain-driven design</a> (DDD) (see <a href="https://github.com/eligosource/eventsourced-example">reference application</a>). On the other hand, the library doesn't force applications to do so and allows them to implement event-sourcing (and/or command-sourcing) without CQRS and/or DDD.</p>

<h3>
<a name="user-content-journals" class="anchor" href="#journals" aria-hidden="true"><span class="octicon octicon-link"></span></a>Journals</h3>

<p>For persisting messages, Eventsourced currently provides the following journal implementations:</p>

<table>
<tr>
<th align="left">Journal</th>
    <th align="left">Usage</th>
  </tr>
<tr>
<td>
<a href="http://eligosource.github.com/eventsourced/api/snapshot/#org.eligosource.eventsourced.journal.leveldb.LeveldbJournalProps">LevelDB journal</a>. It can be configured either with a <a href="http://code.google.com/p/leveldb/">native LevelDB</a> (accessed via <a href="https://github.com/fusesource/leveldbjni">leveldbjni</a>) or a <a href="https://github.com/dain/leveldb">LevelDB Java port</a> as storage backend. Running a native LevelDB from sbt requires <a href="https://github.com/eligosource/eventsourced/wiki/Installation#native-leveldb">special settings</a>. All examples in this user guide use the LevelDB Java port.
    </td>
<td>Production</td>
  </tr>
<tr>
<td>
<a href="http://eligosource.github.com/eventsourced/api/snapshot/#org.eligosource.eventsourced.journal.hbase.HBaseJournalProps">HBase journal</a>. An <a href="http://hbase.apache.org/">HBase</a> backed journal supporting high-availability, horizontal read and write scalability, concurrent and non-blocking reads and writes. Details <a href="https://github.com/eligosource/eventsourced/blob/master/es-journal/es-journal-hbase/readme.md#hbase-journal">here</a>.</td>
    <td>Experimental</td>
  </tr>
<tr>
<td>
<a href="http://eligosource.github.com/eventsourced/api/snapshot/#org.eligosource.eventsourced.journal.mongodb.casbah.MongodbCasbahJournalProps">MongoDB Casbah based journal</a>. A <a href="http://www.mongodb.org/">MongoDB</a> backed journal. Details <a href="https://github.com/eligosource/eventsourced/blob/master/es-journal/es-journal-mongodb-casbah/readme.md#mongodb-casbah-journal">here</a>. Thanks to <a href="https://github.com/ddevore">Duncan DeVore</a>.</td>
    <td>Experimental</td>
  </tr>
<tr>
<td>
<a href="http://eligosource.github.com/eventsourced/api/snapshot/#org.eligosource.eventsourced.journal.mongodb.reactive.MongodbReactiveJournalProps">MongoDB Reactive based journal</a>. A <a href="http://www.mongodb.org/">MongoDB</a> backed journal. Details <a href="https://github.com/eligosource/eventsourced/blob/master/es-journal/es-journal-mongodb-reactive/readme.md#mongodb-reactive-journal">here</a>. Thanks to <a href="https://github.com/ddevore">Duncan DeVore</a>.</td>
    <td>Experimental</td>
  </tr>
<tr>
<td>
<a href="http://eligosource.github.com/eventsourced/api/snapshot/#org.eligosource.eventsourced.journal.dynamodb.DynamoDBJournalProps">DynamoDB journal</a>. A <a href="http://aws.amazon.com/en/dynamodb/">DynamoDB </a> backed journal. Details <a href="https://github.com/eligosource/eventsourced/blob/master/es-journal/es-journal-dynamodb/readme.md#dynamodb-journal">here</a>. Thanks to <a href="https://github.com/sclasen">Scott Clasen</a>.</td>
    <td>Experimental</td>
  </tr>
<tr>
<td>
<a href="http://eligosource.github.com/eventsourced/api/snapshot/#org.eligosource.eventsourced.journal.journalio.JournalioJournalProps">Journal.IO journal</a>. <a href="https://github.com/sbtourist/Journal.IO">Journal.IO</a> backed journal for testing purposes. Messages are persisted.</td>
    <td>Testing</td>
  </tr>
<tr>
<td>
<a href="http://eligosource.github.com/eventsourced/api/snapshot/#org.eligosource.eventsourced.journal.inmem.InmemJournalProps">In memory journal</a>. An in-memory journal for testing purposes. Messages are not persisted.</td>
    <td>Testing</td>
  </tr>
</table><h2>
<a name="user-content-terminology" class="anchor" href="#terminology" aria-hidden="true"><span class="octicon octicon-link"></span></a>Terminology</h2>

<p>In the following, the terms <em>persistent actor</em>, <em>event-sourced actor</em>, <em>event-sourced processor</em> and <em>processor</em> are used interchangeably. Furthermore, a <a href="http://eligosource.github.com/eventsourced/api/snapshot/#org.eligosource.eventsourced.core.Message"><code>Message</code></a> is often referred to as <em>event message</em>.</p>

<h2>
<a name="user-content-first-steps" class="anchor" href="#first-steps" aria-hidden="true"><span class="octicon octicon-link"></span></a>First steps</h2>

<p>This section guides through the minimum steps required to create, use and recover an event-sourced actor and demonstrates the usage of channels. Code from this section is contained in <a href="https://github.com/eligosource/eventsourced/blob/master/es-examples/src/main/scala/org/eligosource/eventsourced/guide/FirstSteps.scala">FirstSteps.scala</a> and <a href="https://github.com/eligosource/eventsourced/blob/master/es-examples/src/main/java/org/eligosource/eventsourced/guide/japi/FirstSteps.java">FirstSteps.java</a>. It can be executed from the sbt prompt with</p>

<p><strong>Scala:</strong></p>

<pre><code>&gt; project eventsourced-examples
&gt; run-main org.eligosource.eventsourced.guide.FirstSteps
</code></pre>

<p><strong>Java:</strong></p>

<pre><code>&gt; project eventsourced-examples
&gt; run-main org.eligosource.eventsourced.guide.japi.FirstSteps
</code></pre>

<p>The example in this section and all further examples use a journal that is backed by a <a href="https://github.com/eligosource/eventsourced/wiki/Installation#leveldb-java-port">LevelDB Java port</a>. For running a <a href="https://github.com/eligosource/eventsourced/wiki/Installation#native-leveldb">native LevelDB</a> instance from sbt, <a href="https://github.com/eligosource/eventsourced/wiki/Installation#native-leveldb">additional settings</a> are required. A legend to the figures used in this and other sections is in <a href="#appendix-a-legend">Appendix A</a>.</p>

<h3>
<a name="user-content-step-1-eventsourcingextension-initialization" class="anchor" href="#step-1-eventsourcingextension-initialization" aria-hidden="true"><span class="octicon octicon-link"></span></a>Step 1: <code>EventsourcingExtension</code> initialization</h3>

<p><a href="http://eligosource.github.com/eventsourced/api/snapshot/#org.eligosource.eventsourced.core.EventsourcingExtension"><code>EventsourcingExtension</code></a> is an Akka extension provided by the Eventsourced library. It is used by applications to</p>

<ul class="task-list">
<li>create and register event-sourced actors (called <em>processors</em> or <em>event processors</em>)</li>
<li>create and register channels</li>
<li>recover registered processors and channels from journaled event messages</li>
</ul><p>An <code>EventsourcingExtension</code> is initialized with an <code>ActorSystem</code> and a journal <code>ActorRef</code>.</p>

<p><strong>Scala:</strong></p>

<div class="highlight highlight-scala"><pre><span class="k">import</span> <span class="nn">java.io.File</span>
<span class="k">import</span> <span class="nn">akka.actor._</span>
<span class="k">import</span> <span class="nn">org.eligosource.eventsourced.core._</span>
<span class="k">import</span> <span class="nn">org.eligosource.eventsourced.journal.leveldb._</span>

<span class="k">val</span> <span class="n">system</span><span class="k">:</span> <span class="kt">ActorSystem</span> <span class="o">=</span> <span class="nc">ActorSystem</span><span class="o">(</span><span class="s">"example"</span><span class="o">)</span>
<span class="k">val</span> <span class="n">journal</span><span class="k">:</span> <span class="kt">ActorRef</span> <span class="o">=</span> <span class="nc">LeveldbJournalProps</span><span class="o">(</span><span class="k">new</span> <span class="nc">File</span><span class="o">(</span><span class="s">"target/example-1"</span><span class="o">),</span> <span class="n">native</span> <span class="k">=</span> <span class="kc">false</span><span class="o">).</span><span class="n">createJournal</span>
<span class="k">val</span> <span class="n">extension</span><span class="k">:</span> <span class="kt">EventsourcingExtension</span> <span class="o">=</span> <span class="nc">EventsourcingExtension</span><span class="o">(</span><span class="n">system</span><span class="o">,</span> <span class="n">journal</span><span class="o">)</span>
</pre></div>

<p><strong>Java:</strong></p>

<div class="highlight highlight-java"><pre><span class="kn">import</span> <span class="nn">java.io.File</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">akka.actor.*</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.eligosource.eventsourced.core.*</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.eligosource.eventsourced.journal.leveldb.*</span><span class="o">;</span>

<span class="kd">final</span> <span class="n">ActorSystem</span> <span class="n">system</span> <span class="o">=</span> <span class="n">ActorSystem</span><span class="o">.</span><span class="na">create</span><span class="o">(</span><span class="s">"guide"</span><span class="o">);</span>
<span class="kd">final</span> <span class="n">ActorRef</span> <span class="n">journal</span> <span class="o">=</span> <span class="n">LeveldbJournalProps</span><span class="o">.</span><span class="na">create</span><span class="o">(</span><span class="k">new</span> <span class="nf">File</span><span class="o">(</span><span class="s">"target/guide-1-java"</span><span class="o">)).</span><span class="na">withNative</span><span class="o">(</span><span class="kc">false</span><span class="o">).</span><span class="na">createJournal</span><span class="o">(</span><span class="n">system</span><span class="o">);</span>
<span class="kd">final</span> <span class="n">EventsourcingExtension</span> <span class="n">extension</span> <span class="o">=</span> <span class="n">EventsourcingExtension</span><span class="o">.</span><span class="na">create</span><span class="o">(</span><span class="n">system</span><span class="o">,</span> <span class="n">journal</span><span class="o">);</span>
</pre></div>

<p>This example uses a <a href="http://eligosource.github.com/eventsourced/api/snapshot/#org.eligosource.eventsourced.journal.leveldb.LeveldbJournalProps">LevelDB journal</a> but any other <a href="#journals">journal implementation</a> can be used as well.</p>

<h3>
<a name="user-content-step-2-event-sourced-actor-definition" class="anchor" href="#step-2-event-sourced-actor-definition" aria-hidden="true"><span class="octicon octicon-link"></span></a>Step 2: Event-sourced actor definition</h3>

<p>With the Scala API, event-sourced actors can be defined as 'plain' actors. With the Java API, event-sourced actors need to extend the abstract <a href="http://eligosource.github.com/eventsourced/api/snapshot/#org.eligosource.eventsourced.core.UntypedEventsourcedActor"><code>UntypedEventsourcedActor</code></a> class. For example,</p>

<p><strong>Scala:</strong></p>

<div class="highlight highlight-scala"><pre><span class="k">class</span> <span class="nc">Processor</span> <span class="k">extends</span> <span class="nc">Actor</span> <span class="o">{</span>
  <span class="k">var</span> <span class="n">counter</span> <span class="k">=</span> <span class="mi">0</span>

  <span class="k">def</span> <span class="n">receive</span> <span class="k">=</span> <span class="o">{</span>
    <span class="k">case</span> <span class="n">msg</span><span class="k">:</span> <span class="kt">Message</span> <span class="o">=&gt;</span> <span class="o">{</span>
      <span class="n">counter</span> <span class="k">=</span> <span class="n">counter</span> <span class="o">+</span> <span class="mi">1</span>
      <span class="n">println</span><span class="o">(</span><span class="s">"[processor] event = %s (%d)"</span> <span class="n">format</span> <span class="o">(</span><span class="n">msg</span><span class="o">.</span><span class="n">event</span><span class="o">,</span> <span class="n">counter</span><span class="o">))</span>
    <span class="o">}</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div>

<p><strong>Java:</strong></p>

<div class="highlight highlight-java"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Processor</span> <span class="kd">extends</span> <span class="n">UntypedEventsourcedActor</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">counter</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">id</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="mi">1</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">onReceive</span><span class="o">(</span><span class="n">Object</span> <span class="n">message</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">Exception</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">message</span> <span class="k">instanceof</span> <span class="n">Message</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">Message</span> <span class="n">msg</span> <span class="o">=</span> <span class="o">(</span><span class="n">Message</span><span class="o">)</span><span class="n">message</span><span class="o">;</span>
            <span class="n">counter</span> <span class="o">=</span> <span class="n">counter</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
            <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">String</span><span class="o">.</span><span class="na">format</span><span class="o">(</span><span class="s">"[processor] event = %s (%d)"</span><span class="o">,</span> <span class="n">msg</span><span class="o">.</span><span class="na">event</span><span class="o">(),</span> <span class="n">counter</span><span class="o">));</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></div>

<p>is an actor that counts the number of received event <a href="http://eligosource.github.com/eventsourced/api/snapshot/#org.eligosource.eventsourced.core.Message"><code>Message</code></a>s. In Eventsourced applications, events are always communicated (transported) via event <code>Message</code>s.</p>

<h3>
<a name="user-content-step-3-event-sourced-actor-creation-and-recovery" class="anchor" href="#step-3-event-sourced-actor-creation-and-recovery" aria-hidden="true"><span class="octicon octicon-link"></span></a>Step 3: Event-sourced actor creation and recovery</h3>

<p>To make the Scala <code>Processor</code> an event-sourced actor, it must be modified with the stackable <a href="http://eligosource.github.com/eventsourced/api/snapshot/#org.eligosource.eventsourced.core.Eventsourced"><code>Eventsourced</code></a> trait during instantiation. The Java <code>Processor</code> already extends <a href="http://eligosource.github.com/eventsourced/api/snapshot/#org.eligosource.eventsourced.core.UntypedEventsourcedActor"><code>UntypedEventsourcedActor</code></a> class, so no further modification is needed.</p>

<p><strong>Scala:</strong></p>

<div class="highlight highlight-scala"><pre><span class="c1">// create and register event-sourced processor</span>
<span class="k">val</span> <span class="n">processor</span><span class="k">:</span> <span class="kt">ActorRef</span> <span class="o">=</span> <span class="n">extension</span><span class="o">.</span><span class="n">processorOf</span><span class="o">(</span><span class="nc">Props</span><span class="o">(</span><span class="k">new</span> <span class="nc">Processor</span> <span class="k">with</span> <span class="nc">Eventsourced</span> <span class="o">{</span> <span class="k">val</span> <span class="n">id</span> <span class="k">=</span> <span class="mi">1</span> <span class="o">}</span> <span class="o">))</span>

<span class="c1">// recover registered processors by replaying journaled events</span>
<span class="n">extension</span><span class="o">.</span><span class="n">recover</span><span class="o">()</span>
</pre></div>

<p><strong>Java:</strong></p>

<div class="highlight highlight-java"><pre><span class="c1">// create and register event-sourced processor</span>
<span class="kd">final</span> <span class="n">ActorRef</span> <span class="n">processor</span> <span class="o">=</span> <span class="n">extension</span><span class="o">.</span><span class="na">processorOf</span><span class="o">(</span><span class="n">Props</span><span class="o">.</span><span class="na">create</span><span class="o">(</span><span class="n">Processor</span><span class="o">.</span><span class="na">class</span><span class="o">),</span> <span class="n">system</span><span class="o">);</span>

<span class="c1">// recover registered processors by replaying journaled events</span>
<span class="n">extension</span><span class="o">.</span><span class="na">recover</span><span class="o">();</span>
</pre></div>

<p>An actor that is modified with <code>Eventsourced</code> (or extends <code>UntypedEventsourcedActor</code>) writes event <code>Message</code>s to a journal before its <code>receive</code>  method (or <code>onReceive</code> method, respectively) is called. The <code>processorOf</code> method registers that actor under a unique <code>id</code>. The processor <code>id</code> is defined by implementing the abstract <code>Eventsourced.id</code> member which must be a positive integer and consistently re-used across applications runs. The <code>recover</code> method recovers the state of <code>processor</code> by replaying all event messages that <code>processor</code> received in previous application runs.</p>

<h3>
<a name="user-content-step-4-event-sourced-actor-usage" class="anchor" href="#step-4-event-sourced-actor-usage" aria-hidden="true"><span class="octicon octicon-link"></span></a>Step 4: Event-sourced actor usage</h3>

<p>The event-sourced <code>processor</code> can be used like any other actor. Messages of type <a href="http://eligosource.github.com/eventsourced/api/snapshot/#org.eligosource.eventsourced.core.Message"><code>Message</code></a> are written to the journal, messages of any other type are directly received by <code>processor</code> without being journaled.</p>

<p><a href="https://camo.githubusercontent.com/e73826badd954c8e8fe0eaca5b7b40e54d3a89e5/68747470733a2f2f7261772e6769746875622e636f6d2f656c69676f736f757263652f6576656e74736f75726365642f6d61737465722f646f632f696d616765732f666972737473746570732d312e706e67" target="_blank"><img src="https://camo.githubusercontent.com/e73826badd954c8e8fe0eaca5b7b40e54d3a89e5/68747470733a2f2f7261772e6769746875622e636f6d2f656c69676f736f757263652f6576656e74736f75726365642f6d61737465722f646f632f696d616765732f666972737473746570732d312e706e67" alt="Event-sourced actor" data-canonical-src="https://raw.github.com/eligosource/eventsourced/master/doc/images/firststeps-1.png" style="max-width:100%;"></a></p>

<p><strong>Scala:</strong></p>

<div class="highlight highlight-scala"><pre><span class="c1">// send event message to processor (will be journaled)</span>
<span class="n">processor</span> <span class="o">!</span> <span class="nc">Message</span><span class="o">(</span><span class="s">"foo"</span><span class="o">)</span>
</pre></div>

<p><strong>Java:</strong></p>

<div class="highlight highlight-java"><pre><span class="c1">// send event message to processor (will be journaled)</span>
<span class="n">processor</span><span class="o">.</span><span class="na">tell</span><span class="o">(</span><span class="n">Message</span><span class="o">.</span><span class="na">create</span><span class="o">(</span><span class="s">"foo"</span><span class="o">),</span> <span class="kc">null</span><span class="o">);</span>
</pre></div>

<p>A first application run will create an empty journal. Hence, no event messages will be replayed and the <code>processor</code> writes</p>

<pre><code>[processor] event = foo (1)
</code></pre>

<p>to <code>stdout</code>. When the application is restarted, however, the <code>processor</code>'s state will be recovered by replaying the previously journaled event message. Then, the application sends another event message. You will therefore see</p>

<pre><code>[processor] event = foo (1)
[processor] event = foo (2)
</code></pre>

<p>on <code>stdout</code> where the first <code>println</code> is triggered by a replayed event message.</p>

<h3>
<a name="user-content-step-5-channel-usage" class="anchor" href="#step-5-channel-usage" aria-hidden="true"><span class="octicon octicon-link"></span></a>Step 5: Channel usage</h3>

<p><a href="https://camo.githubusercontent.com/3a9eb2b0778b47b8c37d5307b25ab30a7d7f96cd/68747470733a2f2f7261772e6769746875622e636f6d2f656c69676f736f757263652f6576656e74736f75726365642f6d61737465722f646f632f696d616765732f666972737473746570732d322e706e67" target="_blank"><img src="https://camo.githubusercontent.com/3a9eb2b0778b47b8c37d5307b25ab30a7d7f96cd/68747470733a2f2f7261772e6769746875622e636f6d2f656c69676f736f757263652f6576656e74736f75726365642f6d61737465722f646f632f696d616765732f666972737473746570732d322e706e67" alt="Channel" data-canonical-src="https://raw.github.com/eligosource/eventsourced/master/doc/images/firststeps-2.png" style="max-width:100%;"></a></p>

<p>In this step, the event-sourced <code>processor</code> is extended to send out new event messages to a <code>destination</code>. It creates another event message (by making a copy of the received event message) with an updated <code>event</code> field and sends the updated message to <code>destination</code>.</p>

<p><strong>Scala:</strong></p>

<div class="highlight highlight-scala"><pre><span class="k">class</span> <span class="nc">Processor</span><span class="o">(</span><span class="n">destination</span><span class="k">:</span> <span class="kt">ActorRef</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Actor</span> <span class="o">{</span>
  <span class="k">var</span> <span class="n">counter</span> <span class="k">=</span> <span class="mi">0</span><span class="o">;</span>

  <span class="k">def</span> <span class="n">receive</span> <span class="k">=</span> <span class="o">{</span>
    <span class="k">case</span> <span class="n">msg</span><span class="k">:</span> <span class="kt">Message</span> <span class="o">=&gt;</span> <span class="o">{</span>
      <span class="n">counter</span> <span class="k">=</span> <span class="n">counter</span> <span class="o">+</span> <span class="mi">1</span>
      <span class="c1">// …</span>
      <span class="n">destination</span> <span class="o">!</span> <span class="n">msg</span><span class="o">.</span><span class="n">copy</span><span class="o">(</span><span class="n">event</span> <span class="k">=</span> <span class="s">"processed %d event messages so far"</span> <span class="n">format</span> <span class="n">counter</span><span class="o">)</span>
    <span class="o">}</span>
  <span class="o">}</span>
<span class="o">}</span>

<span class="k">val</span> <span class="n">destination</span><span class="k">:</span> <span class="kt">ActorRef</span> <span class="o">=</span> <span class="n">system</span><span class="o">.</span><span class="n">actorOf</span><span class="o">(</span><span class="nc">Props</span><span class="o">[</span><span class="kt">Destination</span><span class="o">])</span>
<span class="c1">// instantiate processor by passing the destination as constructor argument</span>
<span class="k">val</span> <span class="n">processor</span><span class="k">:</span> <span class="kt">ActorRef</span> <span class="o">=</span> <span class="n">extension</span><span class="o">.</span><span class="n">processorOf</span><span class="o">(</span><span class="nc">Props</span><span class="o">(</span><span class="k">new</span> <span class="nc">Processor</span><span class="o">(</span><span class="n">destination</span><span class="o">)</span> <span class="k">with</span> <span class="nc">Eventsourced</span> <span class="o">{</span> <span class="k">val</span> <span class="n">id</span> <span class="k">=</span> <span class="mi">1</span> <span class="o">}</span> <span class="o">))</span>

<span class="n">extension</span><span class="o">.</span><span class="n">recover</span><span class="o">()</span>
</pre></div>

<p><strong>Java:</strong></p>

<div class="highlight highlight-java"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Processor</span> <span class="kd">extends</span> <span class="n">UntypedEventsourcedActor</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="n">ActorRef</span> <span class="n">destination</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">counter</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">Processor</span><span class="o">(</span><span class="n">ActorRef</span> <span class="n">destination</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">destination</span> <span class="o">=</span> <span class="n">destination</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">id</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="mi">1</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">onReceive</span><span class="o">(</span><span class="n">Object</span> <span class="n">message</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">Exception</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">message</span> <span class="k">instanceof</span> <span class="n">Message</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">Message</span> <span class="n">msg</span> <span class="o">=</span> <span class="o">(</span><span class="n">Message</span><span class="o">)</span><span class="n">message</span><span class="o">;</span>
            <span class="n">counter</span> <span class="o">=</span> <span class="n">counter</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
            <span class="c1">// …</span>
            <span class="n">destination</span><span class="o">.</span><span class="na">tell</span><span class="o">(</span><span class="n">msg</span><span class="o">.</span><span class="na">withEvent</span><span class="o">(</span><span class="n">String</span><span class="o">.</span><span class="na">format</span><span class="o">(</span><span class="s">"processed %d event messages so far"</span><span class="o">,</span> <span class="n">counter</span><span class="o">)),</span> <span class="n">getSelf</span><span class="o">());</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">final</span> <span class="n">ActorRef</span> <span class="n">destination</span> <span class="o">=</span> <span class="n">system</span><span class="o">.</span><span class="na">actorOf</span><span class="o">(</span><span class="n">Props</span><span class="o">.</span><span class="na">create</span><span class="o">(</span><span class="n">Destination</span><span class="o">.</span><span class="na">class</span><span class="o">));</span>
<span class="c1">// instantiate processor by passing the destination as constructor argument</span>
<span class="kd">final</span> <span class="n">ActorRef</span> <span class="n">processor</span> <span class="o">=</span> <span class="n">extension</span><span class="o">.</span><span class="na">processorOf</span><span class="o">(</span><span class="n">Props</span><span class="o">.</span><span class="na">create</span><span class="o">(</span><span class="n">Processor</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="n">destination</span><span class="o">),</span> <span class="n">system</span><span class="o">);</span>

<span class="n">extension</span><span class="o">.</span><span class="na">recover</span><span class="o">();</span>
</pre></div>

<p>Without any further actions, this would also send event messages to <code>destination</code> during recovery (i.e. during replay of event messages). With every application restart, <code>destination</code> would redundantly receive the whole event message history again and again. This is not acceptable in most cases, such as when <code>destination</code> represents an external service, for example.</p>

<p>To prevent redundant message delivery to <code>destination</code> we need something that <em>remembers</em> which messages have already been successfully delivered. This is exactly the use case for <a href="#channels">channels</a>. A channel drops all messages that have already been successfully delivered to a destination. We therefore wrap <code>destination</code> by a channel and let the processor communicate with the destination via that channel. This can be done without changing the code of <code>Processor</code>.</p>

<p><strong>Scala:</strong></p>

<div class="highlight highlight-scala"><pre><span class="k">val</span> <span class="n">destination</span><span class="k">:</span> <span class="kt">ActorRef</span> <span class="o">=</span> <span class="n">system</span><span class="o">.</span><span class="n">actorOf</span><span class="o">(</span><span class="nc">Props</span><span class="o">[</span><span class="kt">Destination</span><span class="o">])</span>
<span class="c1">// wrap destination by channel</span>
<span class="k">val</span> <span class="n">channel</span><span class="k">:</span> <span class="kt">ActorRef</span> <span class="o">=</span> <span class="n">extension</span><span class="o">.</span><span class="n">channelOf</span><span class="o">(</span><span class="nc">DefaultChannelProps</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="n">destination</span><span class="o">))</span>
<span class="c1">// instantiate processor by passing the channel (i.e. wrapped destination) as constructor argument</span>
<span class="k">val</span> <span class="n">processor</span><span class="k">:</span> <span class="kt">ActorRef</span> <span class="o">=</span> <span class="n">extension</span><span class="o">.</span><span class="n">processorOf</span><span class="o">(</span><span class="nc">Props</span><span class="o">(</span><span class="k">new</span> <span class="nc">Processor</span><span class="o">(</span><span class="n">channel</span><span class="o">)</span> <span class="k">with</span> <span class="nc">Eventsourced</span> <span class="o">{</span> <span class="k">val</span> <span class="n">id</span> <span class="k">=</span> <span class="mi">1</span> <span class="o">}</span> <span class="o">))</span>
</pre></div>

<p><strong>Java:</strong></p>

<div class="highlight highlight-java"><pre><span class="kd">final</span> <span class="n">ActorRef</span> <span class="n">destination</span> <span class="o">=</span> <span class="n">system</span><span class="o">.</span><span class="na">actorOf</span><span class="o">(</span><span class="n">Props</span><span class="o">.</span><span class="na">create</span><span class="o">(</span><span class="n">Destination</span><span class="o">.</span><span class="na">class</span><span class="o">));</span>
<span class="c1">// wrap destination by channel</span>
<span class="kd">final</span> <span class="n">ActorRef</span> <span class="n">channel</span> <span class="o">=</span> <span class="n">extension</span><span class="o">.</span><span class="na">channelOf</span><span class="o">(</span><span class="n">DefaultChannelProps</span><span class="o">.</span><span class="na">create</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="n">destination</span><span class="o">),</span> <span class="n">system</span><span class="o">);</span>
<span class="c1">// instantiate processor by passing the channel (i.e. wrapped destination) as constructor argument</span>
<span class="kd">final</span> <span class="n">ActorRef</span> <span class="n">processor</span> <span class="o">=</span> <span class="n">extension</span><span class="o">.</span><span class="na">processorOf</span><span class="o">(</span><span class="n">Props</span><span class="o">.</span><span class="na">create</span><span class="o">(</span><span class="n">Processor</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="n">channel</span><span class="o">),</span> <span class="n">system</span><span class="o">);</span>
</pre></div>

<p>A channel must have a unique id (<code>1</code> in our example), a positive integer that must be consistently defined across application runs. Here, we create a <a href="#defaultchannel">default channel</a> that is configured with a <a href="http://eligosource.github.com/eventsourced/api/snapshot/#org.eligosource.eventsourced.core.DefaultChannelProps"><code>DefaultChannelProps</code></a> configuration object. If applications need reliable event message delivery to destinations, they should use a <a href="#reliablechannel">reliable channel</a> that is configured with a <a href="http://eligosource.github.com/eventsourced/api/snapshot/#org.eligosource.eventsourced.core.ReliableChannelProps"><code>ReliableChannelProps</code></a> configuration object.</p>

<p>Assuming the following definition of a <code>Destination</code> actor</p>

<p><strong>Scala:</strong></p>

<div class="highlight highlight-scala"><pre><span class="k">class</span> <span class="nc">Destination</span> <span class="k">extends</span> <span class="nc">Actor</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">receive</span> <span class="k">=</span> <span class="o">{</span>
    <span class="k">case</span> <span class="n">msg</span><span class="k">:</span> <span class="kt">Message</span> <span class="o">=&gt;</span> <span class="o">{</span>
      <span class="n">println</span><span class="o">(</span><span class="s">"[destination] event = '%s'"</span> <span class="n">format</span> <span class="n">msg</span><span class="o">.</span><span class="n">event</span><span class="o">)</span>
      <span class="c1">// confirm receipt of event message from channel</span>
      <span class="n">msg</span><span class="o">.</span><span class="n">confirm</span><span class="o">()</span>
    <span class="o">}</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div>

<p><strong>Java:</strong></p>

<div class="highlight highlight-java"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Destination</span> <span class="kd">extends</span> <span class="n">UntypedActor</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">onReceive</span><span class="o">(</span><span class="n">Object</span> <span class="n">message</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">Exception</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">message</span> <span class="k">instanceof</span> <span class="n">Message</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">Message</span> <span class="n">msg</span> <span class="o">=</span> <span class="o">(</span><span class="n">Message</span><span class="o">)</span><span class="n">message</span><span class="o">;</span>
            <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">String</span><span class="o">.</span><span class="na">format</span><span class="o">(</span><span class="s">"[destination] event = %s"</span><span class="o">,</span> <span class="n">msg</span><span class="o">.</span><span class="na">event</span><span class="o">()));</span>
            <span class="n">msg</span><span class="o">.</span><span class="na">confirm</span><span class="o">(</span><span class="kc">true</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></div>

<p>and that we're starting again from an empty journal, you should see</p>

<pre><code>[processor] event = foo (1)
[destination] event = 'processed 1 event messages so far'
</code></pre>

<p>on <code>stdout</code> during a first application run. When running the application again, you'll see that the event-sourced <code>processor</code> receives the complete event message history but the <code>destination</code> only receives the last event message produced by <code>processor</code> (which corresponds the the single event message sent to <code>processor</code> during the current application run):</p>

<pre><code>[processor] event = foo (1)
[processor] event = foo (2)
[destination] event = 'processed 2 event messages so far'
</code></pre>

<p>When receiving event messages from a channel, destinations must confirm the receipt of that message by calling <code>Message.confirm()</code> which asynchronously writes a confirmation (an <em>acknowledgement</em>) to the journal that the message has been successfully delivered. Later, you'll also see how confirmation functionality can be added to destinations with the stackable <a href="http://eligosource.github.com/eventsourced/api/snapshot/#org.eligosource.eventsourced.core.Confirm"><code>Confirm</code></a> trait.</p>

<p>This <a href="#first-steps">First steps</a> guide is a rather low-level introduction to the Eventsourced library. More advanced library features are covered in the following sections.</p>

<h2>
<a name="user-content-stackable-traits" class="anchor" href="#stackable-traits" aria-hidden="true"><span class="octicon octicon-link"></span></a>Stackable traits</h2>

<h3>
<a name="user-content-eventsourced-1" class="anchor" href="#eventsourced-1" aria-hidden="true"><span class="octicon octicon-link"></span></a><code>Eventsourced</code>
</h3>

<p><a href="https://camo.githubusercontent.com/63834a4a08107a3e513e9f30ea9d8c4e33e66d99/68747470733a2f2f7261772e6769746875622e636f6d2f656c69676f736f757263652f6576656e74736f75726365642f6d61737465722f646f632f696d616765732f737461636b61626c657472616974732d312e706e67" target="_blank"><img src="https://camo.githubusercontent.com/63834a4a08107a3e513e9f30ea9d8c4e33e66d99/68747470733a2f2f7261772e6769746875622e636f6d2f656c69676f736f757263652f6576656e74736f75726365642f6d61737465722f646f632f696d616765732f737461636b61626c657472616974732d312e706e67" alt="Eventsourced" data-canonical-src="https://raw.github.com/eligosource/eventsourced/master/doc/images/stackabletraits-1.png" style="max-width:100%;"></a></p>

<p>The <a href="http://eligosource.github.com/eventsourced/api/snapshot/#org.eligosource.eventsourced.core.Eventsourced"><code>Eventsourced</code></a> trait has already been discussed in section <a href="#first-steps">First steps</a>. It can be combined with the stackable <code>Receiver</code>, <code>Emitter</code> and/or <code>Confirm</code> traits where the <code>Eventsourced</code> trait must always be the last modification i.e.</p>

<p><strong>Scala:</strong></p>

<div class="highlight highlight-scala"><pre><span class="k">new</span> <span class="nc">MyActor</span> <span class="k">with</span> <span class="nc">Receiver</span> <span class="k">with</span> <span class="nc">Confirm</span> <span class="k">with</span> <span class="nc">Eventsourced</span>
</pre></div>

<p><strong>Java:</strong></p>

<div class="highlight highlight-java"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">MyActor</span> <span class="kd">extends</span> <span class="n">UntypedEventsourcedConfirmingReceiver</span>
</pre></div>

<p>The Eventsourced Java API provides some predefined combinations of stackable traits as abstract base classes. For example, <a href="http://eligosource.github.com/eventsourced/api/snapshot/#org.eligosource.eventsourced.core.UntypedEventsourcedConfirmingReceiver"><code>UntypedEventsourcedConfirmingReceiver</code></a> is defined as</p>

<div class="highlight highlight-scala"><pre><span class="k">abstract</span> <span class="k">class</span> <span class="nc">UntypedEventsourcedReceiver</span> <span class="k">extends</span> <span class="nc">UntypedActor</span> <span class="k">with</span> <span class="nc">Receiver</span> <span class="k">with</span> <span class="nc">Confirm</span> <span class="k">with</span> <span class="nc">Eventsourced</span>
</pre></div>

<p>Other predefined combinations of stackable traits in the Java API are described in the following subsections. Refer to the <code>Untyped*</code> abstract classes in the <a href="http://eligosource.github.io/eventsourced/api/snapshot/#org.eligosource.eventsourced.core.package">API docs</a> for all predefined combinations.</p>

<h3>
<a name="user-content-receiver" class="anchor" href="#receiver" aria-hidden="true"><span class="octicon octicon-link"></span></a><code>Receiver</code>
</h3>

<p><a href="https://camo.githubusercontent.com/0fc3deae03b60fd11fbb4d47b768886cabae65aa/68747470733a2f2f7261772e6769746875622e636f6d2f656c69676f736f757263652f6576656e74736f75726365642f6d61737465722f646f632f696d616765732f737461636b61626c657472616974732d322e706e67" target="_blank"><img src="https://camo.githubusercontent.com/0fc3deae03b60fd11fbb4d47b768886cabae65aa/68747470733a2f2f7261772e6769746875622e636f6d2f656c69676f736f757263652f6576656e74736f75726365642f6d61737465722f646f632f696d616765732f737461636b61626c657472616974732d322e706e67" alt="Receiver" data-canonical-src="https://raw.github.com/eligosource/eventsourced/master/doc/images/stackabletraits-2.png" style="max-width:100%;"></a></p>

<p>An actor that receives event <a href="http://eligosource.github.com/eventsourced/api/snapshot/#org.eligosource.eventsourced.core.Message"><code>Message</code></a>s often wants to pattern-match against the contained <code>event</code> directly instead of the whole event message. This can be achieved by modifying it with the <a href="http://eligosource.github.com/eventsourced/api/snapshot/#org.eligosource.eventsourced.core.Receiver"><code>Receiver</code></a> trait during instantiation (Scala API) or extending the abstract <a href="http://eligosource.github.com/eventsourced/api/snapshot/#org.eligosource.eventsourced.core.UntypedReceiver"><code>UntypedReceiver</code></a> class (Java API).</p>

<p><strong>Scala:</strong></p>

<div class="highlight highlight-scala"><pre><span class="k">class</span> <span class="nc">MyActor</span> <span class="k">extends</span> <span class="nc">Actor</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">receive</span> <span class="k">=</span> <span class="o">{</span>
    <span class="k">case</span> <span class="n">event</span> <span class="k">=&gt;</span> <span class="n">println</span><span class="o">(</span><span class="s">"received event %s"</span> <span class="n">format</span> <span class="n">event</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span>

<span class="k">val</span> <span class="n">myActor</span> <span class="k">=</span> <span class="n">system</span><span class="o">.</span><span class="n">actorOf</span><span class="o">(</span><span class="nc">Props</span><span class="o">(</span><span class="k">new</span> <span class="nc">MyActor</span> <span class="k">with</span> <span class="nc">Receiver</span><span class="o">))</span>

<span class="n">myActor</span> <span class="o">!</span> <span class="nc">Message</span><span class="o">(</span><span class="s">"foo"</span><span class="o">)</span>
</pre></div>

<p><strong>Java:</strong></p>

<div class="highlight highlight-java"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">MyActor</span> <span class="kd">extends</span> <span class="n">UntypedReceiver</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">onReceive</span><span class="o">(</span><span class="n">Object</span> <span class="n">event</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">Exception</span> <span class="o">{</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">String</span><span class="o">.</span><span class="na">format</span><span class="o">(</span><span class="s">"received event = %s"</span><span class="o">,</span> <span class="n">event</span><span class="o">));</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">final</span> <span class="n">ActorRef</span> <span class="n">myActor</span> <span class="o">=</span> <span class="n">system</span><span class="o">.</span><span class="na">actorOf</span><span class="o">(</span><span class="n">Props</span><span class="o">.</span><span class="na">create</span><span class="o">(</span><span class="n">MyActor</span><span class="o">.</span><span class="na">class</span><span class="o">));</span>

<span class="n">myActor</span><span class="o">.</span><span class="na">tell</span><span class="o">(</span><span class="n">Message</span><span class="o">.</span><span class="na">create</span><span class="o">(</span><span class="s">"foo"</span><span class="o">),</span> <span class="kc">null</span><span class="o">);</span>
</pre></div>

<p>In the above example, sending <code>Message("foo")</code> to <code>myActor</code> will write <code>received event foo</code> to <code>stdout</code>. The <code>Receiver</code> trait stores the received event message as <em>current</em> event message in a field, extracts the contained <code>event</code> from that message and calls the <code>receive</code> (or <code>onReceive</code>) method of <code>MyActor</code> with <code>event</code> as argument. If <code>MyActor</code> wants to have access to the current event message it must be defined with a <code>Receiver</code> self-type and call the <code>message</code> method (Scala API) or just call the <code>message()</code> method (Java API).</p>

<p><strong>Scala:</strong></p>

<div class="highlight highlight-scala"><pre><span class="k">class</span> <span class="nc">MyActor</span> <span class="k">extends</span> <span class="nc">Actor</span> <span class="o">{</span> <span class="k">this:</span> <span class="kt">Receiver</span> <span class="o">=&gt;</span>
  <span class="k">def</span> <span class="n">receive</span> <span class="k">=</span> <span class="o">{</span>
    <span class="k">case</span> <span class="n">event</span> <span class="k">=&gt;</span> <span class="o">{</span>
      <span class="c1">// obtain current event message</span>
      <span class="k">val</span> <span class="n">currentMessage</span> <span class="k">=</span> <span class="n">message</span>
      <span class="c1">// …</span>
      <span class="n">println</span><span class="o">(</span><span class="s">"received event %s"</span> <span class="n">format</span> <span class="n">event</span><span class="o">)</span>
    <span class="o">}</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div>

<p><strong>Java:</strong></p>

<div class="highlight highlight-java"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">MyActor</span> <span class="kd">extends</span> <span class="n">UntypedReceiver</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">onReceive</span><span class="o">(</span><span class="n">Object</span> <span class="n">event</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">Exception</span> <span class="o">{</span>
        <span class="c1">// obtain current event message</span>
        <span class="n">Message</span> <span class="n">currentMessage</span> <span class="o">=</span> <span class="n">message</span><span class="o">();</span>
        <span class="c1">// …</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">String</span><span class="o">.</span><span class="na">format</span><span class="o">(</span><span class="s">"received event = %s"</span><span class="o">,</span> <span class="n">event</span><span class="o">));</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></div>

<p>The <code>Receiver</code> trait can also be combined with the stackable <code>Eventsourced</code> and/or <code>Confirm</code> traits where <code>Receiver</code> must always be the first modification. For example:</p>

<p><strong>Scala:</strong></p>

<div class="highlight highlight-scala"><pre><span class="k">new</span> <span class="nc">MyActor</span> <span class="k">with</span> <span class="nc">Receiver</span> <span class="k">with</span> <span class="nc">Eventsourced</span>
</pre></div>

<p><strong>Java:</strong></p>

<div class="highlight highlight-java"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">MyActor</span> <span class="kd">extends</span> <span class="n">UntypedEventsourcedReceiver</span>
</pre></div>

<p>Refer to the <a href="http://eligosource.github.com/eventsourced/api/snapshot/#org.eligosource.eventsourced.core.Receiver">API docs</a> for further details.</p>

<h3>
<a name="user-content-emitter" class="anchor" href="#emitter" aria-hidden="true"><span class="octicon octicon-link"></span></a><code>Emitter</code>
</h3>

<p><a href="https://camo.githubusercontent.com/3bd2f64cf42d4e6a71bb71aa5b36866b59e70465/68747470733a2f2f7261772e6769746875622e636f6d2f656c69676f736f757263652f6576656e74736f75726365642f6d61737465722f646f632f696d616765732f737461636b61626c657472616974732d332e706e67" target="_blank"><img src="https://camo.githubusercontent.com/3bd2f64cf42d4e6a71bb71aa5b36866b59e70465/68747470733a2f2f7261772e6769746875622e636f6d2f656c69676f736f757263652f6576656e74736f75726365642f6d61737465722f646f632f696d616765732f737461636b61626c657472616974732d332e706e67" alt="Emitter" data-canonical-src="https://raw.github.com/eligosource/eventsourced/master/doc/images/stackabletraits-3.png" style="max-width:100%;"></a></p>

<p>Where a <code>Receiver</code> modification allows actors to pattern-match against incoming events directly instead of whole event <code>Message</code>s, an <a href="http://eligosource.github.com/eventsourced/api/snapshot/#org.eligosource.eventsourced.core.Emitter"><code>Emitter</code></a> introduces a corresponding simplification on the sending (outgoing) side. It allows actors to send (emit) events to channels without having to deal with whole event <code>Message</code>s. An emitter can also lookup channels by name (or id, see below).</p>

<p><strong>Scala:</strong></p>

<div class="highlight highlight-scala"><pre><span class="k">class</span> <span class="nc">MyActor</span> <span class="k">extends</span> <span class="nc">Actor</span> <span class="o">{</span> <span class="k">this:</span> <span class="kt">Emitter</span> <span class="o">=&gt;</span>
    <span class="k">def</span> <span class="n">receive</span> <span class="k">=</span> <span class="o">{</span>
      <span class="k">case</span> <span class="n">event</span> <span class="k">=&gt;</span> <span class="o">{</span>
        <span class="c1">// emit event to channel "myChannel"</span>
        <span class="n">emitter</span><span class="o">(</span><span class="s">"myChannel"</span><span class="o">)</span> <span class="n">sendEvent</span> <span class="o">(</span><span class="s">"received: %s"</span> <span class="n">format</span> <span class="n">event</span><span class="o">)</span>
      <span class="o">}</span>
    <span class="o">}</span>
  <span class="o">}</span>

<span class="c1">// create register channel under name "myChannel"</span>
<span class="n">extension</span><span class="o">.</span><span class="n">channelOf</span><span class="o">(</span><span class="nc">DefaultChannelProps</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="n">destination</span><span class="o">).</span><span class="n">withName</span><span class="o">(</span><span class="s">"myChannel"</span><span class="o">))</span>

<span class="k">val</span> <span class="n">myActor</span> <span class="k">=</span> <span class="n">system</span><span class="o">.</span><span class="n">actorOf</span><span class="o">(</span><span class="nc">Props</span><span class="o">(</span><span class="k">new</span> <span class="nc">MyActor</span> <span class="k">with</span> <span class="nc">Emitter</span><span class="o">))</span>
</pre></div>

<p><strong>Java:</strong></p>

<div class="highlight highlight-java"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">MyActor</span> <span class="kd">extends</span> <span class="n">UntypedEmitter</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">onReceive</span><span class="o">(</span><span class="n">Object</span> <span class="n">event</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">Exception</span> <span class="o">{</span>
        <span class="c1">// emit event to channel "myChannel"</span>
        <span class="n">emitter</span><span class="o">(</span><span class="s">"myChannel"</span><span class="o">).</span><span class="na">sendEvent</span><span class="o">(</span><span class="n">String</span><span class="o">.</span><span class="na">format</span><span class="o">(</span><span class="s">"received: %s"</span><span class="o">,</span> <span class="n">event</span><span class="o">),</span> <span class="n">getSelf</span><span class="o">());</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="c1">// create register channel under name "myChannel"</span>
<span class="n">extension</span><span class="o">.</span><span class="na">channelOf</span><span class="o">(</span><span class="n">DefaultChannelProps</span><span class="o">.</span><span class="na">create</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="n">destination</span><span class="o">).</span><span class="na">withName</span><span class="o">(</span><span class="s">"myChannel"</span><span class="o">),</span> <span class="n">system</span><span class="o">);</span>

<span class="kd">final</span> <span class="n">ActorRef</span> <span class="n">myActor</span> <span class="o">=</span> <span class="n">extension</span><span class="o">.</span><span class="na">processorOf</span><span class="o">(</span><span class="n">Props</span><span class="o">.</span><span class="na">create</span><span class="o">(</span><span class="n">MyActor</span><span class="o">.</span><span class="na">class</span><span class="o">),</span> <span class="n">system</span><span class="o">);</span>
</pre></div>

<p>Event messages sent by an emitter to a channel are always derived from (i.e. are a copy of) the current event message (an <code>Emitter</code> is also <code>Receiver</code> and maintains a <em>current</em> event message, see also section <a href="#receiver">Receiver</a>). A call to the <code>emitter</code> method with a channel name as argument creates a <a href="http://eligosource.github.com/eventsourced/api/snapshot/#org.eligosource.eventsourced.core.MessageEmitter"><code>MessageEmitter</code></a> object that captures the named channel and the current event message. Calling <code>sendEvent</code> on that object modifies the captured event message with the specified event argument and sends the updated event message to the channel (see also channel <a href="#usage-hints">usage hints</a>). A <code>MessageEmitter</code> object can also be sent to other actors (or threads) and be used there i.e. a <code>MessageEmitter</code> object is thread-safe. Channels can also be referred to by id when creating a <code>MessageEmitter</code> i.e. there's no need to define a custom channel name:</p>

<p><strong>Scala:</strong></p>

<div class="highlight highlight-scala"><pre><span class="k">class</span> <span class="nc">MyActor</span> <span class="k">extends</span> <span class="nc">Actor</span> <span class="o">{</span> <span class="k">this:</span> <span class="kt">Emitter</span> <span class="o">=&gt;</span>
  <span class="k">def</span> <span class="n">receive</span> <span class="k">=</span> <span class="o">{</span>
    <span class="k">case</span> <span class="n">event</span> <span class="k">=&gt;</span> <span class="o">{</span>
      <span class="c1">// emit event to channel with id 1</span>
      <span class="n">emitter</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span> <span class="n">sendEvent</span> <span class="o">(</span><span class="s">"received: %s"</span> <span class="n">format</span> <span class="n">event</span><span class="o">)</span>
    <span class="o">}</span>
  <span class="o">}</span>
<span class="o">}</span>

<span class="c1">// create register channel</span>
<span class="n">extension</span><span class="o">.</span><span class="n">channelOf</span><span class="o">(</span><span class="nc">DefaultChannelProps</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="n">destination</span><span class="o">))</span>
</pre></div>

<p><strong>Java:</strong></p>

<div class="highlight highlight-java"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">MyActor</span> <span class="kd">extends</span> <span class="n">UntypedEmitter</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">onReceive</span><span class="o">(</span><span class="n">Object</span> <span class="n">event</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">Exception</span> <span class="o">{</span>
        <span class="c1">// emit event to channel with id 1</span>
        <span class="n">emitter</span><span class="o">(</span><span class="mi">1</span><span class="o">).</span><span class="na">sendEvent</span><span class="o">(</span><span class="n">String</span><span class="o">.</span><span class="na">format</span><span class="o">(</span><span class="s">"received: %s"</span><span class="o">,</span> <span class="n">event</span><span class="o">),</span> <span class="n">getSelf</span><span class="o">());</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="c1">// create register channel</span>
<span class="n">extension</span><span class="o">.</span><span class="na">channelOf</span><span class="o">(</span><span class="n">DefaultChannelProps</span><span class="o">.</span><span class="na">create</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="n">destination</span><span class="o">),</span> <span class="n">system</span><span class="o">);</span>
</pre></div>

<p>The <code>Emitter</code> trait can also be combined with the stackable <code>Eventsourced</code> and/or <code>Confirm</code> traits where <code>Emitter</code> must always be the first modification. For example:</p>

<p><strong>Scala:</strong></p>

<div class="highlight highlight-scala"><pre><span class="k">new</span> <span class="nc">MyActor</span> <span class="k">with</span> <span class="nc">Emitter</span> <span class="k">with</span> <span class="nc">Eventsourced</span>
</pre></div>

<p><strong>Java:</strong></p>

<div class="highlight highlight-java"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">MyActor</span> <span class="kd">extends</span> <span class="n">UntypedEventsourcedEmitter</span>
</pre></div>

<p>Refer to the <a href="http://eligosource.github.com/eventsourced/api/snapshot/#org.eligosource.eventsourced.core.Emitter">API docs</a> for further details.</p>

<h3>
<a name="user-content-confirm" class="anchor" href="#confirm" aria-hidden="true"><span class="octicon octicon-link"></span></a><code>Confirm</code>
</h3>

<p><a href="https://camo.githubusercontent.com/5912958c17ad1d4a847ac89e2ac130fcfe8e6960/68747470733a2f2f7261772e6769746875622e636f6d2f656c69676f736f757263652f6576656e74736f75726365642f6d61737465722f646f632f696d616765732f737461636b61626c657472616974732d342e706e67" target="_blank"><img src="https://camo.githubusercontent.com/5912958c17ad1d4a847ac89e2ac130fcfe8e6960/68747470733a2f2f7261772e6769746875622e636f6d2f656c69676f736f757263652f6576656e74736f75726365642f6d61737465722f646f632f696d616765732f737461636b61626c657472616974732d342e706e67" alt="Confirm" data-canonical-src="https://raw.github.com/eligosource/eventsourced/master/doc/images/stackabletraits-4.png" style="max-width:100%;"></a></p>

<p>The receipt of event messages from channels must be confirmed by calling <code>confirm()</code> or <code>confirm(true)</code> on the received event <code>Message</code>. Applications can also <em>negatively</em> confirm an event message receipt by calling <code>confirm(false)</code>. This, for example, causes a reliable channel to redeliver the event message.</p>

<p>Instead of calling <code>confirm(true)</code> or <code>confirm(false)</code> explicitly, actors can also be modified with the stackable <a href="http://eligosource.github.com/eventsourced/api/snapshot/#org.eligosource.eventsourced.core.Confirm"><code>Confirm</code></a> trait. This trait calls <code>confirm(true)</code> on the received event message when the modified actor's <code>receive</code> (or <code>onReceive</code>) method returns normally and <code>confirm(false)</code> when it throws an exception.</p>

<p>This trait can either be used standalone</p>

<p><strong>Scala:</strong></p>

<div class="highlight highlight-scala"><pre><span class="k">new</span> <span class="nc">MyActor</span> <span class="k">with</span> <span class="nc">Confirm</span>
</pre></div>

<p><strong>Java:</strong></p>

<div class="highlight highlight-java"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">MyActor</span> <span class="kd">extends</span> <span class="n">UntypedConfirmingActor</span>
</pre></div>

<p>or in combination with the stackable <code>Receiver</code>, <code>Emitter</code> and/or <code>Eventsourced</code> traits where the <code>Confirm</code> modification must be made after a <code>Receiver</code> or <code>Emitter</code> modification but before an <code>Eventsourced</code> modification. For example:</p>

<p><strong>Scala:</strong></p>

<div class="highlight highlight-scala"><pre><span class="k">new</span> <span class="nc">MyActor</span> <span class="k">with</span> <span class="nc">Receiver</span> <span class="k">with</span> <span class="nc">Confirm</span> <span class="k">with</span> <span class="nc">Eventsourced</span>
</pre></div>

<p><strong>Java:</strong></p>

<div class="highlight highlight-java"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">MyActor</span> <span class="kd">extends</span> <span class="n">UntypedEventsourcedConfirmingReceiver</span>
</pre></div>

<p>Refer to the <a href="http://eligosource.github.com/eventsourced/api/snapshot/#org.eligosource.eventsourced.core.Confirm">API docs</a> for further details.</p>

<h3>
<a name="user-content-modified-example" class="anchor" href="#modified-example" aria-hidden="true"><span class="octicon octicon-link"></span></a>Modified example</h3>

<p><a href="https://camo.githubusercontent.com/1b18933a025ad0c6f624471725cebcb8a8f034bb/68747470733a2f2f7261772e6769746875622e636f6d2f656c69676f736f757263652f6576656e74736f75726365642f6d61737465722f646f632f696d616765732f737461636b61626c657472616974732d352e706e67" target="_blank"><img src="https://camo.githubusercontent.com/1b18933a025ad0c6f624471725cebcb8a8f034bb/68747470733a2f2f7261772e6769746875622e636f6d2f656c69676f736f757263652f6576656e74736f75726365642f6d61737465722f646f632f696d616765732f737461636b61626c657472616974732d352e706e67" alt="Example" data-canonical-src="https://raw.github.com/eligosource/eventsourced/master/doc/images/stackabletraits-5.png" style="max-width:100%;"></a></p>

<p>This section modifies (and simplifies) the example from section <a href="#first-steps">First steps</a> by making use of the stackable <code>Receiver</code>, <code>Emitter</code> and <code>Confirm</code> traits. In particular, for the Scala API</p>

<ul class="task-list">
<li>
<code>Processor</code> will be modified with <code>Emitter</code> (in addition to <code>Eventsourced</code>)</li>
<li>
<code>Destination</code> will be modified with <code>Receiver</code> and <code>Confirm</code>
</li>
</ul><p>For the Java API</p>

<ul class="task-list">
<li>
<code>Processor</code> will extend <code>UntypedEventsourcedEmitter</code>
</li>
<li>
<code>Destination</code> will extend <code>UntypedConfirmingReceiver</code>
</li>
</ul><p>Code from this section is contained in <a href="https://github.com/eligosource/eventsourced/blob/master/es-examples/src/main/scala/org/eligosource/eventsourced/guide/StackableTraits.scala">StackableTraits.scala</a> and
<a href="https://github.com/eligosource/eventsourced/blob/master/es-examples/src/main/java/org/eligosource/eventsourced/guide/japi/StackableTraits.java">StackableTraits.java</a>. It can be executed from the sbt prompt with</p>

<p><strong>Scala:</strong></p>

<pre><code>&gt; project eventsourced-examples
&gt; run-main org.eligosource.eventsourced.guide.StackableTraits
</code></pre>

<p><strong>Java:</strong></p>

<pre><code>&gt; project eventsourced-examples
&gt; run-main org.eligosource.eventsourced.guide.japi.StackableTraits
</code></pre>

<p>The new Scala definition of <code>Processor</code> now has a self-type <code>Emitter</code> and pattern-matches against events directly. The Java definition of <code>Processor</code> extends <code>UntypedEventsourcedEmitter</code> and also receives events directly (instead of <code>Message</code>s).</p>

<p><strong>Scala:</strong></p>

<div class="highlight highlight-scala"><pre><span class="k">class</span> <span class="nc">Processor</span> <span class="k">extends</span> <span class="nc">Actor</span> <span class="o">{</span> <span class="k">this:</span> <span class="kt">Emitter</span> <span class="o">=&gt;</span>
  <span class="k">var</span> <span class="n">counter</span> <span class="k">=</span> <span class="mi">0</span>

  <span class="k">def</span> <span class="n">receive</span> <span class="k">=</span> <span class="o">{</span>
    <span class="k">case</span> <span class="n">event</span> <span class="k">=&gt;</span> <span class="o">{</span>
      <span class="n">counter</span> <span class="k">=</span> <span class="n">counter</span> <span class="o">+</span> <span class="mi">1</span>
      <span class="n">println</span><span class="o">(</span><span class="s">"[processor] event = %s (%d)"</span> <span class="n">format</span> <span class="o">(</span><span class="n">event</span><span class="o">,</span> <span class="n">counter</span><span class="o">))</span>
      <span class="n">emitter</span><span class="o">(</span><span class="s">"destination"</span><span class="o">)</span> <span class="n">sendEvent</span> <span class="o">(</span><span class="s">"processed %d events so far"</span> <span class="n">format</span> <span class="n">counter</span><span class="o">)</span>
    <span class="o">}</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div>

<p><strong>Java:</strong></p>

<div class="highlight highlight-java"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Processor</span> <span class="kd">extends</span> <span class="n">UntypedEventsourcedEmitter</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">counter</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">id</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="mi">1</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">onReceive</span><span class="o">(</span><span class="n">Object</span> <span class="n">event</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">Exception</span> <span class="o">{</span>
        <span class="n">counter</span> <span class="o">=</span> <span class="n">counter</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">String</span><span class="o">.</span><span class="na">format</span><span class="o">(</span><span class="s">"[processor] event = %s (%d)"</span><span class="o">,</span> <span class="n">event</span><span class="o">,</span> <span class="n">counter</span><span class="o">));</span>
        <span class="n">emitter</span><span class="o">(</span><span class="s">"destination"</span><span class="o">).</span><span class="na">sendEvent</span><span class="o">(</span><span class="n">String</span><span class="o">.</span><span class="na">format</span><span class="o">(</span><span class="s">"processed %d event messages so far"</span><span class="o">,</span> <span class="n">counter</span><span class="o">),</span> <span class="n">getSelf</span><span class="o">());</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></div>

<p>Instead of passing the channel via the constructor it is now looked-up by name (<code>"destination"</code>). The channel name is specified during channel creation.</p>

<p><strong>Scala:</strong></p>

<div class="highlight highlight-scala"><pre><span class="n">extension</span><span class="o">.</span><span class="n">channelOf</span><span class="o">(</span><span class="nc">DefaultChannelProps</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="n">destination</span><span class="o">).</span><span class="n">withName</span><span class="o">(</span><span class="s">"destination"</span><span class="o">))</span>
</pre></div>

<p><strong>Java:</strong></p>

<div class="highlight highlight-java"><pre><span class="n">extension</span><span class="o">.</span><span class="na">channelOf</span><span class="o">(</span><span class="n">DefaultChannelProps</span><span class="o">.</span><span class="na">create</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="n">destination</span><span class="o">).</span><span class="na">withName</span><span class="o">(</span><span class="s">"destination"</span><span class="o">),</span> <span class="n">system</span><span class="o">);</span>
</pre></div>

<p>The Scala <code>Processor</code> must be instantiated with an additional <code>Emitter</code> modification to conform to the <code>Processor</code> self-type. No further modification is needed for the Java <code>Processor</code>.</p>

<p><strong>Scala:</strong></p>

<div class="highlight highlight-scala"><pre><span class="k">val</span> <span class="n">processor</span><span class="k">:</span> <span class="kt">ActorRef</span> <span class="o">=</span> <span class="n">extension</span><span class="o">.</span><span class="n">processorOf</span><span class="o">(</span><span class="nc">Props</span><span class="o">(</span><span class="k">new</span> <span class="nc">Processor</span> <span class="k">with</span> <span class="nc">Emitter</span> <span class="k">with</span> <span class="nc">Eventsourced</span> <span class="o">{</span> <span class="k">val</span> <span class="n">id</span> <span class="k">=</span> <span class="mi">1</span> <span class="o">}</span> <span class="o">))</span>
</pre></div>

<p><strong>Java:</strong></p>

<div class="highlight highlight-java"><pre><span class="kd">final</span> <span class="n">ActorRef</span> <span class="n">processor</span> <span class="o">=</span> <span class="n">extension</span><span class="o">.</span><span class="na">processorOf</span><span class="o">(</span><span class="n">Props</span><span class="o">.</span><span class="na">create</span><span class="o">(</span><span class="n">Processor</span><span class="o">.</span><span class="na">class</span><span class="o">),</span> <span class="n">system</span><span class="o">);</span>
</pre></div>

<p>The new definition of <code>Destination</code></p>

<p><strong>Scala:</strong></p>

<div class="highlight highlight-scala"><pre><span class="k">class</span> <span class="nc">Destination</span> <span class="k">extends</span> <span class="nc">Actor</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">receive</span> <span class="k">=</span> <span class="o">{</span>
    <span class="k">case</span> <span class="n">event</span> <span class="k">=&gt;</span> <span class="o">{</span>
      <span class="n">println</span><span class="o">(</span><span class="s">"[destination] event = '%s'"</span> <span class="n">format</span> <span class="n">event</span><span class="o">)</span>
    <span class="o">}</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div>

<p><strong>Java:</strong></p>

<div class="highlight highlight-java"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Destination</span> <span class="kd">extends</span> <span class="n">UntypedConfirmingReceiver</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">onReceive</span><span class="o">(</span><span class="n">Object</span> <span class="n">event</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">Exception</span> <span class="o">{</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">String</span><span class="o">.</span><span class="na">format</span><span class="o">(</span><span class="s">"[destination] event = %s"</span><span class="o">,</span> <span class="n">event</span><span class="o">));</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></div>

<p>pattern-matches against events directly and leaves event message receipt confirmation to the <code>Confirm</code> trait. The Scala <code>Destination</code> must be instantiated with a <code>Receiver</code> and a <code>Confirm</code> modification and again, no further modification is needed for the Java <code>Destination</code>.</p>

<p><strong>Scala:</strong></p>

<div class="highlight highlight-scala"><pre><span class="k">val</span> <span class="n">destination</span><span class="k">:</span> <span class="kt">ActorRef</span> <span class="o">=</span> <span class="n">system</span><span class="o">.</span><span class="n">actorOf</span><span class="o">(</span><span class="nc">Props</span><span class="o">(</span><span class="k">new</span> <span class="nc">Destination</span> <span class="k">with</span> <span class="nc">Receiver</span> <span class="k">with</span> <span class="nc">Confirm</span><span class="o">))</span>
</pre></div>

<p><strong>Java:</strong></p>

<div class="highlight highlight-java"><pre><span class="kd">final</span> <span class="n">ActorRef</span> <span class="n">destination</span> <span class="o">=</span> <span class="n">system</span><span class="o">.</span><span class="na">actorOf</span><span class="o">(</span><span class="n">Props</span><span class="o">.</span><span class="na">create</span><span class="o">(</span><span class="n">Destination</span><span class="o">.</span><span class="na">class</span><span class="o">));</span>
</pre></div>

<h2>
<a name="user-content-sender-references" class="anchor" href="#sender-references" aria-hidden="true"><span class="octicon octicon-link"></span></a>Sender references</h2>

<p>The Eventsourced library preserves sender references for all</p>

<ul class="task-list">
<li>message exchanges with actors that are modified with <code>Eventsourced</code>, <code>Receiver</code>, <code>Emitter</code> and/or <code>Confirm</code> (or extend any of the abstract <code>Untyped*</code> base classes from the Java API) and</li>
<li>message exchanges with destination actors via <a href="#channels">channels</a>
</li>
</ul><p>i.e. event-sourced actor applications can make use of sender references in the same way as plain actor applications. If you know how sender references work with Akka <a href="http://doc.akka.io/docs/akka/2.1.0/scala/actors.html">actors</a>, the following will sound familiar to you.</p>

<p><a href="https://camo.githubusercontent.com/bc1e72e4a9067ad43d27d005224b9ceb2522e268/68747470733a2f2f7261772e6769746875622e636f6d2f656c69676f736f757263652f6576656e74736f75726365642f6d61737465722f646f632f696d616765732f73656e646572726566732d312e706e67" target="_blank"><img src="https://camo.githubusercontent.com/bc1e72e4a9067ad43d27d005224b9ceb2522e268/68747470733a2f2f7261772e6769746875622e636f6d2f656c69676f736f757263652f6576656e74736f75726365642f6d61737465722f646f632f696d616765732f73656e646572726566732d312e706e67" alt="Processor reply" data-canonical-src="https://raw.github.com/eligosource/eventsourced/master/doc/images/senderrefs-1.png" style="max-width:100%;"></a></p>

<p>For example, taking the code from section <a href="#first-steps">First steps</a> as a starting point, <code>Processor</code> can be extended to reply to message senders as follows.</p>

<p><strong>Scala:</strong></p>

<div class="highlight highlight-scala"><pre><span class="k">class</span> <span class="nc">Processor</span><span class="o">(</span><span class="n">destination</span><span class="k">:</span> <span class="kt">ActorRef</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Actor</span> <span class="o">{</span>
  <span class="c1">// …</span>

  <span class="k">def</span> <span class="n">receive</span> <span class="k">=</span> <span class="o">{</span>
    <span class="k">case</span> <span class="n">msg</span><span class="k">:</span> <span class="kt">Message</span> <span class="o">=&gt;</span> <span class="o">{</span>
      <span class="c1">// …</span>
      <span class="c1">// reply to sender</span>
      <span class="n">sender</span> <span class="o">!</span> <span class="o">(</span><span class="s">"done processing event = %s"</span> <span class="n">format</span> <span class="n">msg</span><span class="o">.</span><span class="n">event</span><span class="o">)</span>
    <span class="o">}</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div>

<p><strong>Java:</strong></p>

<div class="highlight highlight-java"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Processor</span> <span class="kd">extends</span> <span class="n">UntypedEventsourcedActor</span> <span class="o">{</span>
    <span class="c1">// …</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">onReceive</span><span class="o">(</span><span class="n">Object</span> <span class="n">message</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">Exception</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">message</span> <span class="k">instanceof</span> <span class="n">Message</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// …</span>
            <span class="n">getSender</span><span class="o">().</span><span class="na">tell</span><span class="o">(</span><span class="n">String</span><span class="o">.</span><span class="na">format</span><span class="o">(</span><span class="s">"done processing event = %s"</span><span class="o">,</span> <span class="n">msg</span><span class="o">.</span><span class="na">event</span><span class="o">()),</span> <span class="n">getSelf</span><span class="o">());</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></div>

<p>Applications can now <em>ask</em> the <code>processor</code> and will get a response asynchronously.</p>

<p><strong>Scala:</strong></p>

<div class="highlight highlight-scala"><pre><span class="n">processor</span> <span class="o">?</span> <span class="nc">Message</span><span class="o">(</span><span class="s">"foo"</span><span class="o">)</span> <span class="n">onSuccess</span> <span class="o">{</span>
  <span class="k">case</span> <span class="n">response</span> <span class="k">=&gt;</span> <span class="n">println</span><span class="o">(</span><span class="n">response</span><span class="o">)</span>
<span class="o">}</span>
</pre></div>

<p><strong>Java:</strong></p>

<div class="highlight highlight-java"><pre><span class="n">ask</span><span class="o">(</span><span class="n">processor</span><span class="o">,</span> <span class="n">Message</span><span class="o">.</span><span class="na">create</span><span class="o">(</span><span class="s">"foo"</span><span class="o">),</span> <span class="mi">5000L</span><span class="o">).</span><span class="na">onSuccess</span><span class="o">(</span><span class="k">new</span> <span class="n">OnSuccess</span><span class="o">&lt;</span><span class="n">Object</span><span class="o">&gt;()</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">onSuccess</span><span class="o">(</span><span class="n">Object</span> <span class="n">response</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">Throwable</span> <span class="o">{</span>
        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">response</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">},</span> <span class="n">system</span><span class="o">.</span><span class="na">dispatcher</span><span class="o">());</span>
</pre></div>

<p>No surprise here. The sender reference in this example represents the future that is returned from the <code>?</code> or <code>ask</code> method call. But what happens during a replay? During a replay, the sender reference will be <code>deadLetters</code> because <code>Eventsourced</code> processors don't store sender references in the journal. The main reason for this is that applications usually do not want to redundantly reply to senders during replays.</p>

<p><a href="https://camo.githubusercontent.com/a1bdea554599f1dc1dafd270bbc1bfdcd6ee05dc/68747470733a2f2f7261772e6769746875622e636f6d2f656c69676f736f757263652f6576656e74736f75726365642f6d61737465722f646f632f696d616765732f73656e646572726566732d322e706e67" target="_blank"><img src="https://camo.githubusercontent.com/a1bdea554599f1dc1dafd270bbc1bfdcd6ee05dc/68747470733a2f2f7261772e6769746875622e636f6d2f656c69676f736f757263652f6576656e74736f75726365642f6d61737465722f646f632f696d616765732f73656e646572726566732d322e706e67" alt="Destination reply" data-canonical-src="https://raw.github.com/eligosource/eventsourced/master/doc/images/senderrefs-2.png" style="max-width:100%;"></a></p>

<p>Instead of replying to the sender, the processor can also forward the sender reference to a destination and let the destination reply to the sender. This even works if the destination is wrapped by a channel because a channel simply forwards sender references when delivering event messages to destinations. For that reason, a <a href="http://eligosource.github.com/eventsourced/api/snapshot/#org.eligosource.eventsourced.core.ReliableChannel"><code>ReliableChannel</code></a> needs to store sender references (in contrast to processors), so that sender references are even available after a reliable channel has been restarted. If a stored sender reference is a remote reference, it remains valid even after recovery from a JVM crash (i.e. a crash of the JVM the reliable channel is running in) provided the remote sender is still available.</p>

<p><strong>Scala:</strong></p>

<div class="highlight highlight-scala"><pre><span class="k">class</span> <span class="nc">Processor</span><span class="o">(</span><span class="n">destination</span><span class="k">:</span> <span class="kt">ActorRef</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Actor</span> <span class="o">{</span>
  <span class="k">var</span> <span class="n">counter</span> <span class="k">=</span> <span class="mi">0</span>

  <span class="k">def</span> <span class="n">receive</span> <span class="k">=</span> <span class="o">{</span>
    <span class="k">case</span> <span class="n">msg</span><span class="k">:</span> <span class="kt">Message</span> <span class="o">=&gt;</span> <span class="o">{</span>
      <span class="c1">// …</span>
      <span class="c1">// forward modified event message to destination (together with sender reference)</span>
      <span class="n">destination</span> <span class="n">forward</span> <span class="n">msg</span><span class="o">.</span><span class="n">copy</span><span class="o">(</span><span class="n">event</span> <span class="k">=</span> <span class="s">"processed %d event messages so far"</span> <span class="n">format</span> <span class="n">counter</span><span class="o">)</span>
    <span class="o">}</span>
  <span class="o">}</span>
<span class="o">}</span>

<span class="k">class</span> <span class="nc">Destination</span> <span class="k">extends</span> <span class="nc">Actor</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">receive</span> <span class="k">=</span> <span class="o">{</span>
    <span class="k">case</span> <span class="n">msg</span><span class="k">:</span> <span class="kt">Message</span> <span class="o">=&gt;</span> <span class="o">{</span>
      <span class="c1">// …</span>
      <span class="c1">// reply to sender</span>
      <span class="n">sender</span> <span class="o">!</span> <span class="o">(</span><span class="s">"done processing event = %s (%d)"</span> <span class="n">format</span> <span class="n">msg</span><span class="o">.</span><span class="n">event</span><span class="o">)</span>
    <span class="o">}</span>
  <span class="o">}</span>
<span class="o">}</span>

<span class="k">val</span> <span class="n">destination</span><span class="k">:</span> <span class="kt">ActorRef</span> <span class="o">=</span> <span class="n">system</span><span class="o">.</span><span class="n">actorOf</span><span class="o">(</span><span class="nc">Props</span><span class="o">[</span><span class="kt">Destination</span><span class="o">])</span>
<span class="k">val</span> <span class="n">channel</span><span class="k">:</span> <span class="kt">ActorRef</span> <span class="o">=</span> <span class="n">extension</span><span class="o">.</span><span class="n">channelOf</span><span class="o">(</span><span class="nc">DefaultChannelProps</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="n">destination</span><span class="o">))</span>
<span class="k">val</span> <span class="n">processor</span><span class="k">:</span> <span class="kt">ActorRef</span> <span class="o">=</span> <span class="n">extension</span><span class="o">.</span><span class="n">processorOf</span><span class="o">(</span><span class="nc">Props</span><span class="o">(</span><span class="k">new</span> <span class="nc">Processor</span><span class="o">(</span><span class="n">channel</span><span class="o">)</span> <span class="k">with</span> <span class="nc">Eventsourced</span> <span class="o">{</span> <span class="k">val</span> <span class="n">id</span> <span class="k">=</span> <span class="mi">1</span> <span class="o">}</span> <span class="o">))</span>
</pre></div>

<p><strong>Java:</strong></p>

<div class="highlight highlight-java"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Processor</span> <span class="kd">extends</span> <span class="n">UntypedEventsourcedActor</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="n">ActorRef</span> <span class="n">destination</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">counter</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">Processor</span><span class="o">(</span><span class="n">ActorRef</span> <span class="n">destination</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">destination</span> <span class="o">=</span> <span class="n">destination</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">id</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="mi">1</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">onReceive</span><span class="o">(</span><span class="n">Object</span> <span class="n">message</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">Exception</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">message</span> <span class="k">instanceof</span> <span class="n">Message</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">Message</span> <span class="n">msg</span> <span class="o">=</span> <span class="o">(</span><span class="n">Message</span><span class="o">)</span><span class="n">message</span><span class="o">;</span>
            <span class="c1">// forward modified event message to destination (together with sender reference)</span>
            <span class="n">destination</span><span class="o">.</span><span class="na">forward</span><span class="o">(</span><span class="n">msg</span><span class="o">.</span><span class="na">withEvent</span><span class="o">(</span><span class="n">String</span><span class="o">.</span><span class="na">format</span><span class="o">(</span><span class="s">"processed %d event messages so far"</span><span class="o">,</span> <span class="n">counter</span><span class="o">)),</span> <span class="n">getContext</span><span class="o">());</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Destination</span> <span class="kd">extends</span> <span class="n">UntypedActor</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">onReceive</span><span class="o">(</span><span class="n">Object</span> <span class="n">message</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">Exception</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">message</span> <span class="k">instanceof</span> <span class="n">Message</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">Message</span> <span class="n">msg</span> <span class="o">=</span> <span class="o">(</span><span class="n">Message</span><span class="o">)</span><span class="n">message</span><span class="o">;</span>
            <span class="c1">// …</span>
            <span class="c1">// reply to sender</span>
            <span class="n">getSender</span><span class="o">().</span><span class="na">tell</span><span class="o">(</span><span class="n">String</span><span class="o">.</span><span class="na">format</span><span class="o">(</span><span class="s">"done processing event = %s"</span><span class="o">,</span> <span class="n">msg</span><span class="o">.</span><span class="na">event</span><span class="o">()),</span> <span class="n">getSelf</span><span class="o">());</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">final</span> <span class="n">ActorRef</span> <span class="n">destination</span> <span class="o">=</span> <span class="n">system</span><span class="o">.</span><span class="na">actorOf</span><span class="o">(</span><span class="n">Props</span><span class="o">.</span><span class="na">create</span><span class="o">(</span><span class="n">Destination</span><span class="o">.</span><span class="na">class</span><span class="o">));</span>
<span class="kd">final</span> <span class="n">ActorRef</span> <span class="n">channel</span> <span class="o">=</span> <span class="n">extension</span><span class="o">.</span><span class="na">channelOf</span><span class="o">(</span><span class="n">DefaultChannelProps</span><span class="o">.</span><span class="na">create</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="n">destination</span><span class="o">),</span> <span class="n">system</span><span class="o">);</span>
<span class="kd">final</span> <span class="n">ActorRef</span> <span class="n">processor</span> <span class="o">=</span> <span class="n">extension</span><span class="o">.</span><span class="na">processorOf</span><span class="o">(</span><span class="n">Props</span><span class="o">.</span><span class="na">create</span><span class="o">(</span><span class="n">Processor</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="n">channel</span><span class="o">),</span> <span class="n">system</span><span class="o">);</span>
</pre></div>

<p>When using a <a href="http://eligosource.github.com/eventsourced/api/snapshot/#org.eligosource.eventsourced.core.MessageEmitter"><code>MessageEmitter</code></a> (see also section <a href="#emitter">Emitter</a>) applications can choose between methods <code>sendEvent</code> and <code>forwardEvent</code> where <code>sendEvent</code> takes an (implicit) sender reference as parameter and <code>forwardEvent</code> forwards the current sender reference. They work in the same way as the <code>tell</code> (<code>!</code>) and <code>forward</code> methods on <code>ActorRef</code>, respectively.</p>

<p>Code from this section is contained in <a href="https://github.com/eligosource/eventsourced/blob/master/es-examples/src/main/scala/org/eligosource/eventsourced/guide/SenderReferences.scala">SenderReferences.scala</a> and <a href="https://github.com/eligosource/eventsourced/blob/master/es-examples/src/main/java/org/eligosource/eventsourced/guide/japi/SenderReferences.java">SenderReferences.java</a>. It can be executed from the sbt prompt with</p>

<p><strong>Scala:</strong></p>

<pre><code>&gt; project eventsourced-examples
&gt; run-main org.eligosource.eventsourced.guide.SenderReferences
</code></pre>

<p><strong>Java:</strong></p>

<pre><code>&gt; project eventsourced-examples
&gt; run-main org.eligosource.eventsourced.guide.japi.SenderReferences
</code></pre>

<h2>
<a name="user-content-channels" class="anchor" href="#channels" aria-hidden="true"><span class="octicon octicon-link"></span></a>Channels</h2>

<p>A <a href="#channel">channel</a> is an actor that keeps track of successfully delivered event messages. Channels are used by event-sourced actors (processors) to prevent redundant message delivery to destinations during event message replay. Some channels can also be used <a href="#standalone-usage">standalone</a> i.e. independent of event-sourced actors.</p>

<p>A use case for channels is described in section <a href="http://martinfowler.com/eaaDev/EventSourcing.html#ExternalUpdates">External Updates</a> of Martin Fowler's <a href="http://martinfowler.com/eaaDev/EventSourcing.html">Event Sourcing</a> article. A getting-started example is given in section <a href="#step-5-channel-usage">Channel usage</a> of the <a href="#first-steps">First steps</a> guide</p>

<p>Currently, the library provides two different channel implementations, <a href="http://eligosource.github.com/eventsourced/api/snapshot/#org.eligosource.eventsourced.core.DefaultChannel"><code>DefaultChannel</code></a> and <a href="http://eligosource.github.com/eventsourced/api/snapshot/#org.eligosource.eventsourced.core.ReliableChannel"><code>ReliableChannel</code></a>, and a pattern on top of <code>ReliableChannel</code>, a <a href="#reliable-request-reply-channel">reliable request-reply channel</a>. These are explained in the following subsections.</p>

<h3>
<a name="user-content-defaultchannel" class="anchor" href="#defaultchannel" aria-hidden="true"><span class="octicon octicon-link"></span></a><code>DefaultChannel</code>
</h3>

<p><a href="https://camo.githubusercontent.com/b7e696e51affe40a0350317414099b13beb04e29/68747470733a2f2f7261772e6769746875622e636f6d2f656c69676f736f757263652f6576656e74736f75726365642f6d61737465722f646f632f696d616765732f6368616e6e656c732d312e706e67" target="_blank"><img src="https://camo.githubusercontent.com/b7e696e51affe40a0350317414099b13beb04e29/68747470733a2f2f7261772e6769746875622e636f6d2f656c69676f736f757263652f6576656e74736f75726365642f6d61737465722f646f632f696d616765732f6368616e6e656c732d312e706e67" alt="Default channel" data-canonical-src="https://raw.github.com/eligosource/eventsourced/master/doc/images/channels-1.png" style="max-width:100%;"></a></p>

<p>A default channel is a transient channel that delivers event messages to a destination actor. When the destination confirms the delivery of an event message by calling either <code>confirm()</code> or <code>confirm(true)</code> on the received <code>Message</code> object, a confirmation (an <em>acknowledgement</em>) is asynchronously written to the journal. During a replay, event messages for which a confirmation exists won't be delivered again to the destination.</p>

<p>Event messages that are negatively confirmed by the destination (via a call to <code>confirm(false)</code> on the received event message) will be re-delivered during the next event message replay. This is also the case for event messages for which no confirmation has been made. Therefore, in cases of negative or missing confirmations, the order of event messages received by a destination from a default channel may differ from the order of event messages produced by an event-sourced processor.</p>

<p>A <code>DefaultChannel</code> is created and registered at an <code>EventsourcingExtension</code> as follows.</p>

<div class="highlight highlight-scala"><pre><span class="k">val</span> <span class="n">extension</span><span class="k">:</span> <span class="kt">EventsourcingExtension</span> <span class="o">=</span> <span class="err">…</span>
<span class="k">val</span> <span class="n">destination</span><span class="k">:</span> <span class="kt">ActorRef</span> <span class="o">=</span> <span class="err">…</span>
<span class="k">val</span> <span class="n">channelId</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="err">…</span>

<span class="k">val</span> <span class="n">channel</span><span class="k">:</span> <span class="kt">ActorRef</span> <span class="o">=</span> <span class="n">extension</span><span class="o">.</span><span class="n">channelOf</span><span class="o">(</span><span class="nc">DefaultChannelProps</span><span class="o">(</span><span class="n">channelId</span><span class="o">,</span> <span class="n">destination</span><span class="o">))</span>
</pre></div>

<p>The <code>channelId</code> must be a positive integer and consistently defined across application runs. The map of registered channels can be obtained via the <code>channels</code> method of <code>EventsourcingExtension</code> which returns a map of type <code>Map[Int, ActorRef]</code> where the mapping key is the channel id. Channels can optionally be registered under a custom name (see also section <a href="#emitter">Emitter</a>).</p>

<div class="highlight highlight-scala"><pre><span class="c1">// …</span>
<span class="k">val</span> <span class="n">channelId</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="err">…</span>
<span class="k">val</span> <span class="n">channelName</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="err">…</span>

<span class="k">val</span> <span class="n">channel</span><span class="k">:</span> <span class="kt">ActorRef</span> <span class="o">=</span> <span class="n">extension</span><span class="o">.</span><span class="n">channelOf</span><span class="o">(</span><span class="nc">DefaultChannelProps</span><span class="o">(</span><span class="n">channelId</span><span class="o">,</span> <span class="n">destination</span><span class="o">).</span><span class="n">withName</span><span class="o">(</span><span class="n">channelName</span><span class="o">))</span>
</pre></div>

<p>The map of registered named channels can be obtained via the <code>namedChannels</code> method which returns a map of type <code>Map[String, ActorRef]</code> where the mapping key is the channel name.</p>

<p>A default channel preserves <a href="#sender-references">sender references</a>. Applications can therefore use <code>?</code> and <code>forward</code> as well to communicate with channel destinations via channel actor refs. However, special care must be taken when using <code>?</code>: replayed messages that have already been confirmed by a channel destination will be ignored by the corresponding channel and the destination cannot reply. Hence, the sender will see a reply timeout. This can be avoided by finding out in advance if the channel will ignore a message or not. Applications do that by investigating the <code>Message.acks</code> list. If the channel's id is contained in that list, the message will be ignored and should not be used for asking.</p>

<div class="highlight highlight-scala"><pre><span class="k">val</span> <span class="n">channelId</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="err">…</span>
<span class="k">val</span> <span class="n">channel</span><span class="k">:</span> <span class="kt">ActorRef</span> <span class="o">=</span> <span class="err">…</span>

<span class="k">if</span> <span class="o">(!</span><span class="n">message</span><span class="o">.</span><span class="n">acks</span><span class="o">.</span><span class="n">contains</span><span class="o">(</span><span class="n">channelId</span><span class="o">))</span> <span class="n">channel</span> <span class="o">?</span> <span class="n">message</span><span class="o">.</span><span class="n">copy</span><span class="o">(</span><span class="err">…</span><span class="o">)</span> <span class="n">onComplete</span> <span class="o">{</span>
  <span class="k">case</span> <span class="n">result</span> <span class="k">=&gt;</span> <span class="err">…</span>
<span class="o">}</span>
</pre></div>

<p>See also <a href="#usage-hints">usage-hints</a> regarding <code>message.copy(…)</code>.</p>

<h3>
<a name="user-content-reliablechannel" class="anchor" href="#reliablechannel" aria-hidden="true"><span class="octicon octicon-link"></span></a><code>ReliableChannel</code>
</h3>

<p><a href="https://camo.githubusercontent.com/be8ca5b15f27b4c8bf9408f27fd7c4b5d628cbf1/68747470733a2f2f7261772e6769746875622e636f6d2f656c69676f736f757263652f6576656e74736f75726365642f6d61737465722f646f632f696d616765732f6368616e6e656c732d322e706e67" target="_blank"><img src="https://camo.githubusercontent.com/be8ca5b15f27b4c8bf9408f27fd7c4b5d628cbf1/68747470733a2f2f7261772e6769746875622e636f6d2f656c69676f736f757263652f6576656e74736f75726365642f6d61737465722f646f632f696d616765732f6368616e6e656c732d322e706e67" alt="Reliable channel" data-canonical-src="https://raw.github.com/eligosource/eventsourced/master/doc/images/channels-2.png" style="max-width:100%;"></a></p>

<p>A reliable channel is a persistent channel that writes event messages to a journal before delivering them to a destination actor. In contrast to a default channel, a reliable channel preserves the order of messages as produced by an event-sourced processor and attempts to re-deliver event messages on destination failures. Therefore, a reliable channel enables applications to recover from temporary destination failures without having to run an event message replay. Furthermore, a reliable channel can also recover from crashes of the JVM it is running in. This allows applications to guarantee at-least-once message delivery in case of both, destination failures and sender failures.</p>

<p>If a destination positively confirms the receipt of an event message, the stored message is removed from the channel and the next one is delivered. If a destination negatively confirms the receipt of an event message or if no confirmation is made (i.e. a timeout occurs), a re-delivery attempt is made after a certain <em>redelivery delay</em>. If the maximum number of re-delivery attempts have been made, the channel restarts itself after a certain <em>restart delay</em> and starts again with re-deliveries. If the maximum number of restarts has been reached, the channel stops message delivery and publishes a <a href="http://eligosource.github.com/eventsourced/api/snapshot/#org.eligosource.eventsourced.core.Channel%24%24DeliveryStopped"><code>DeliveryStopped</code></a> event to the event stream of the actor system this channel belongs to. Applications can then re-activate the channel by calling the <code>deliver(Int)</code> method of <code>EventsourcingExtension</code> with the channel id as argument. Refer to the <a href="http://eligosource.github.com/eventsourced/api/snapshot/#org.eligosource.eventsourced.core.ReliableChannel"><code>ReliableChannel</code></a> API docs for details.</p>

<p>A <code>ReliableChannel</code> is created and registered in the same way as a default channel except that a <a href="http://eligosource.github.com/eventsourced/api/snapshot/#org.eligosource.eventsourced.core.ReliableChannelProps"><code>ReliableChannelProps</code></a> configuration object is used.</p>

<div class="highlight highlight-scala"><pre><span class="c1">// …</span>
<span class="k">val</span> <span class="n">channel</span><span class="k">:</span> <span class="kt">ActorRef</span> <span class="o">=</span> <span class="n">extension</span><span class="o">.</span><span class="n">channelOf</span><span class="o">(</span><span class="nc">ReliableChannelProps</span><span class="o">(</span><span class="n">channelId</span><span class="o">,</span> <span class="n">destination</span><span class="o">))</span>
</pre></div>

<p>This configuration object additionally allows applications to configure a <a href="http://eligosource.github.com/eventsourced/api/snapshot/#org.eligosource.eventsourced.core.RedeliveryPolicy"><code>RedeliveryPolicy</code></a> for the channel.</p>

<p>A reliable channel preserves <a href="#sender-references">sender references</a>. Applications can therefore use <code>?</code> and <code>forward</code> as well to communicate with channel destinations via channel actor refs. Details have already been described in the <a href="#defaultchannel">default channel</a> section. A reliable channel also stores sender references along with event messages so that they can be forwarded to destinations even after the channel has been restarted. If a stored sender reference is a remote reference, it remains valid even after recovery from a JVM crash (i.e. a crash of the JVM the reliable channel is running in) provided the remote sender is still available.</p>

<p>For those familiar with Akka, a reliable channel is similar to an <a href="http://doc.akka.io/docs/akka/snapshot/contrib/reliable-proxy.html">Akka reliable proxy</a> except that it additionally can recover from sender JVM crashes (see also section <a href="#remote-destinations">Remote destinations</a>).</p>

<h3>
<a name="user-content-reliable-request-reply-channel" class="anchor" href="#reliable-request-reply-channel" aria-hidden="true"><span class="octicon octicon-link"></span></a>Reliable request-reply channel</h3>

<p><a href="https://camo.githubusercontent.com/7201de62c0d745f6a541e434d2cb77ffd0a07cbf/68747470733a2f2f7261772e6769746875622e636f6d2f656c69676f736f757263652f6576656e74736f75726365642f6d61737465722f646f632f696d616765732f6368616e6e656c732d332e706e67" target="_blank"><img src="https://camo.githubusercontent.com/7201de62c0d745f6a541e434d2cb77ffd0a07cbf/68747470733a2f2f7261772e6769746875622e636f6d2f656c69676f736f757263652f6576656e74736f75726365642f6d61737465722f646f632f696d616765732f6368616e6e656c732d332e706e67" alt="Reliable request-reply channel" data-canonical-src="https://raw.github.com/eligosource/eventsourced/master/doc/images/channels-3.png" style="max-width:100%;"></a></p>

<p>A reliable request-reply channel is a pattern implemented on top of a <a href="#reliablechannel">reliable channel</a>. It mediates reliable request-reply interactions between a request sender (usually an <code>Eventsourced</code> processor) and a destination. This channel has the following properties in addition to a plain reliable channel. It</p>

<ul class="task-list">
<li>extracts requests from received <a href="http://eligosource.github.com/eventsourced/api/snapshot/#org.eligosource.eventsourced.core.Message"><code>Message</code></a>s before sending them to the destination.</li>
<li>wraps replies from the destination into a <code>Message</code> before sending them back to the request sender.</li>
<li>sends a special <a href="http://eligosource.github.com/eventsourced/api/snapshot/#org.eligosource.eventsourced.patterns.reliable.requestreply.DestinationNotResponding"><code>DestinationNotResponding</code></a> reply to the request sender if the destination doesn't reply within a configurable reply timeout.</li>
<li>sends a special <a href="http://eligosource.github.com/eventsourced/api/snapshot/#org.eligosource.eventsourced.patterns.reliable.requestreply.DestinationFailure"><code>DestinationFailure</code></a> reply to the request sender if destination responds with <code>Status.Failure</code>.</li>
<li>guarantees at-least-once delivery of replies to the request sender (in addition to at-least-once delivery of requests to the destination).</li>
<li>requires a positive receipt confirmation for a reply to mark a request-reply interaction as successfully completed.</li>
<li>redelivers requests, and subsequently replies, on missing or negative receipt confirmations.</li>
</ul><p>A reliable request-reply channel is created and registered in the same way as a reliable channel except that a <a href="http://eligosource.github.com/eventsourced/api/snapshot/#org.eligosource.eventsourced.patterns.reliable.requestreply.ReliableRequestReply%24ReliableRequestReplyChannelProps"><code>ReliableRequestReplyChannelProps</code></a> configuration object is used.</p>

<div class="highlight highlight-scala"><pre><span class="c1">// …</span>
<span class="k">import</span> <span class="nn">org.eligosource.eventsourced.patterns.reliable.requestreply._</span>

<span class="k">val</span> <span class="n">channel</span><span class="k">:</span> <span class="kt">ActorRef</span> <span class="o">=</span> <span class="n">extension</span><span class="o">.</span><span class="n">channelOf</span><span class="o">(</span><span class="nc">ReliableRequestReplyChannelProps</span><span class="o">(</span><span class="n">channelId</span><span class="o">,</span> <span class="n">destination</span><span class="o">))</span>
</pre></div>

<p>This configuration object additionally allows applications to configure a <code>replyTimeout</code> for replies from the destination. A detailed usage example of a reliable request-reply channel is given in <a href="http://krasserm.blogspot.com/2013/01/event-sourcing-and-external-service.html">this article</a>.</p>

<h3>
<a name="user-content-usage-hints" class="anchor" href="#usage-hints" aria-hidden="true"><span class="octicon octicon-link"></span></a>Usage hints</h3>

<h4>
<a name="user-content-general" class="anchor" href="#general" aria-hidden="true"><span class="octicon octicon-link"></span></a>General</h4>

<p>Channels must be activated before usage, see extension.deliver().</p>

<h4>
<a name="user-content-eventsourced-usage" class="anchor" href="#eventsourced-usage" aria-hidden="true"><span class="octicon octicon-link"></span></a>Eventsourced usage</h4>

<p>For channels to work properly, event-sourced processors must copy the <code>processorId</code> and <code>sequenceNr</code> values from a received (and journaled) input event message to output event messages. This is usually done by calling <code>copy()</code> on the received input event message and updating only those fields that are relevant for the application such as <code>event</code> or <code>ack</code>, for example:</p>

<div class="highlight highlight-scala"><pre><span class="k">class</span> <span class="nc">Processor</span><span class="o">(</span><span class="n">channel</span><span class="k">:</span> <span class="kt">ActorRef</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Actor</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">receive</span> <span class="k">=</span> <span class="o">{</span>
    <span class="k">case</span> <span class="n">msg</span><span class="k">:</span> <span class="kt">Message</span> <span class="o">=&gt;</span> <span class="o">{</span>
      <span class="c1">// …</span>
      <span class="n">channel</span> <span class="o">!</span> <span class="n">msg</span><span class="o">.</span><span class="n">copy</span><span class="o">(</span><span class="n">event</span> <span class="k">=</span> <span class="err">…</span><span class="o">,</span> <span class="n">ack</span> <span class="k">=</span> <span class="err">…</span><span class="o">)</span>
    <span class="o">}</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div>

<p>When using a <a href="#emitter">message emitter</a>, this is done automatically.</p>

<h4>
<a name="user-content-standalone-usage" class="anchor" href="#standalone-usage" aria-hidden="true"><span class="octicon octicon-link"></span></a>Standalone usage</h4>

<p><a href="#reliablechannel">Reliable channels</a> and <a href="#reliable-request-reply-channel">reliable request-reply channels</a> can also be used independently of <code>Eventsourced</code> processors (i.e. standalone). For standalone channel usage, senders must set the <code>Message.processorId</code> of the sent <code>Message</code> to <code>0</code> (which is the default value):</p>

<div class="highlight highlight-scala"><pre><span class="k">val</span> <span class="n">channel</span> <span class="k">=</span> <span class="n">extension</span><span class="o">.</span><span class="n">channelOf</span><span class="o">(</span><span class="nc">ReliableChannelProps</span><span class="o">(</span><span class="err">…</span><span class="o">))</span>

<span class="n">channel</span> <span class="o">!</span> <span class="nc">Message</span><span class="o">(</span><span class="s">"my event"</span><span class="o">)</span> <span class="c1">// processorId == 0</span>
</pre></div>

<p>This is equivalent to directly sending the <code>Message.event</code>:</p>

<div class="highlight highlight-scala"><pre><span class="n">channel</span> <span class="o">!</span> <span class="s">"my event"</span>
</pre></div>

<p>A reliable channel internally wraps a received event into a <code>Message</code> with <code>processorId</code> set to <code>0</code>. Setting the <code>processorId</code> to <code>0</code> causes a reliable channel to skip writing an acknowledgement. An acknowledgement always refers to an event message received by an <code>Eventsourced</code> processor, so there's no need to write one in this case. Another (unrelated) use case for turning off writing acknowledgements is the emission of <a href="#event-series">event message series</a> in context of <a href="#eventsourced-usage">event-sourced channel usage</a>.</p>

<h4>
<a name="user-content-remote-destinations" class="anchor" href="#remote-destinations" aria-hidden="true"><span class="octicon octicon-link"></span></a>Remote destinations</h4>

<p>Applications should consider using reliable channels whenever a sender processor should deliver messages to a <strong>remote</strong> destination at-least-once and in sending order, even in cases of</p>

<ol class="task-list">
<li>network errors between sender and destination (remote actor ref remains valid but remote actor is temporarily unavailable)</li>
<li>destination JVM crashes (remote actor ref becomes invalid) and</li>
<li>sender JVM crashes (messages already received by a sender processor but not yet delivered to the remote destination must be automatically delivered when the sender <a href="#recovery">recovers</a> from a crash)</li>
</ol><p>Using a remote actor ref as channel destination would work in case 1 but not in case 2. One possible way to deal with case 2, is to use a local actor (a destination proxy) that communicates with the remote destination via an <code>ActorSelection</code>. An <code>ActorSelection</code> can be created from an actor path and is not bound to the remote destination's life-cycle.</p>

<div class="highlight highlight-scala"><pre><span class="k">class</span> <span class="nc">DestinationProxy</span><span class="o">(</span><span class="n">destinationPath</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Actor</span> <span class="o">{</span>
  <span class="k">val</span> <span class="n">destinationSelection</span><span class="k">:</span> <span class="kt">ActorSelection</span> <span class="o">=</span> <span class="n">context</span><span class="o">.</span><span class="n">actorSelection</span><span class="o">(</span><span class="n">destinationPath</span><span class="o">)</span>

  <span class="k">def</span> <span class="n">receive</span> <span class="k">=</span> <span class="o">{</span>
    <span class="k">case</span> <span class="n">msg</span> <span class="k">=&gt;</span> <span class="n">destinationSelection</span> <span class="n">tell</span> <span class="o">(</span><span class="n">msg</span><span class="o">,</span> <span class="n">sender</span><span class="o">)</span> <span class="c1">// forward</span>
  <span class="o">}</span>
<span class="o">}</span>

<span class="k">val</span> <span class="n">destinationPath</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="err">…</span>
<span class="k">val</span> <span class="n">proxy</span> <span class="k">=</span> <span class="n">system</span><span class="o">.</span><span class="n">actorOf</span><span class="o">(</span><span class="nc">Props</span><span class="o">(</span><span class="k">new</span> <span class="nc">DestinationProxy</span><span class="o">(</span><span class="n">destinationPath</span><span class="o">)))</span>
<span class="k">val</span> <span class="n">channel</span> <span class="k">=</span> <span class="n">extension</span><span class="o">.</span><span class="n">channelOf</span><span class="o">(</span><span class="nc">ReliableChannelProps</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="n">proxy</span><span class="o">))</span>
</pre></div>

<p>Using an <code>ActorSelection</code> also covers case 1, of course. Case 3 is automatically covered by the fact that a sender processor uses a reliable channel for sending messages to a destination. Here's an example:</p>

<div class="highlight highlight-scala"><pre><span class="k">class</span> <span class="nc">Sender</span> <span class="k">extends</span> <span class="nc">Actor</span> <span class="o">{</span>
  <span class="k">val</span> <span class="n">id</span> <span class="k">=</span> <span class="mi">1</span>
  <span class="k">val</span> <span class="n">ext</span> <span class="k">=</span> <span class="nc">EventsourcingExtension</span><span class="o">(</span><span class="n">context</span><span class="o">.</span><span class="n">system</span><span class="o">)</span>
  <span class="k">val</span> <span class="n">proxy</span> <span class="k">=</span> <span class="n">context</span><span class="o">.</span><span class="n">actorOf</span><span class="o">(</span><span class="nc">Props</span><span class="o">(</span><span class="k">new</span> <span class="nc">DestinationProxy</span><span class="o">(</span><span class="s">"akka.tcp://example@127.0.0.1:2852/user/destination"</span><span class="o">)))</span>
  <span class="k">val</span> <span class="n">channel</span> <span class="k">=</span> <span class="n">ext</span><span class="o">.</span><span class="n">channelOf</span><span class="o">(</span><span class="nc">ReliableChannelProps</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="n">proxy</span><span class="o">))</span>

  <span class="k">def</span> <span class="n">receive</span> <span class="k">=</span> <span class="o">{</span>
    <span class="k">case</span> <span class="n">msg</span><span class="k">:</span> <span class="kt">Message</span> <span class="o">=&gt;</span> <span class="n">channel</span> <span class="n">forward</span> <span class="n">msg</span>
  <span class="o">}</span>
<span class="o">}</span>

<span class="c1">// create and recover sender and its channel</span>
<span class="k">val</span> <span class="n">sender</span> <span class="k">=</span> <span class="n">extension</span><span class="o">.</span><span class="n">processorOf</span><span class="o">(</span><span class="nc">Props</span><span class="o">(</span><span class="k">new</span> <span class="nc">Sender</span> <span class="k">with</span> <span class="nc">Eventsourced</span><span class="o">))</span>

<span class="n">sender</span> <span class="o">!</span> <span class="nc">Message</span><span class="o">(</span><span class="s">"hello"</span><span class="o">)</span>
</pre></div>

<p>Special care must be taken if the remote destination actor is an <code>Eventsourced</code> actor. In this case, the application must ensure that the destination actor can only be accessed remotely <strong>after</strong> it has been successfully recovered. This can be achieved, for example, by using an additional <em>endpoint</em> actor that simply forwards to the destination actor. The endpoint actor is registered under the destination path after the destination actor has been successfully recovered.</p>

<div class="highlight highlight-scala"><pre><span class="k">class</span> <span class="nc">DestinationEndpoint</span><span class="o">(</span><span class="n">destination</span><span class="k">:</span> <span class="kt">ActorRef</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Actor</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">receive</span> <span class="k">=</span> <span class="o">{</span>
    <span class="k">case</span> <span class="n">msg</span> <span class="k">=&gt;</span> <span class="n">destination</span> <span class="n">forward</span> <span class="n">msg</span>
  <span class="o">}</span>
<span class="o">}</span>

<span class="k">class</span> <span class="nc">Destination</span> <span class="k">extends</span> <span class="nc">Actor</span> <span class="o">{</span>
  <span class="k">val</span> <span class="n">id</span> <span class="k">=</span> <span class="mi">2</span>

  <span class="k">def</span> <span class="n">receive</span> <span class="k">=</span> <span class="o">{</span>
    <span class="k">case</span> <span class="n">msg</span><span class="k">:</span> <span class="kt">Message</span> <span class="o">=&gt;</span> <span class="o">{</span>
      <span class="n">println</span><span class="o">(</span><span class="n">s</span><span class="s">"received ${msg.event}"</span><span class="o">)</span>
      <span class="n">msg</span><span class="o">.</span><span class="n">confirm</span><span class="o">()</span>
    <span class="o">}</span>
  <span class="o">}</span>
<span class="o">}</span>

<span class="k">val</span> <span class="n">destination</span> <span class="k">=</span> <span class="n">extension</span><span class="o">.</span><span class="n">processorOf</span><span class="o">(</span><span class="nc">Props</span><span class="o">(</span><span class="k">new</span> <span class="nc">Destination</span> <span class="k">with</span> <span class="nc">Eventsourced</span><span class="o">))</span>

<span class="c1">// wait for destination recovery to complete</span>
<span class="n">extension</span><span class="o">.</span><span class="n">recover</span><span class="o">()</span>

<span class="c1">// make destination remotely accessible after recovery</span>
<span class="n">system</span><span class="o">.</span><span class="n">actorOf</span><span class="o">(</span><span class="nc">Props</span><span class="o">(</span><span class="k">new</span> <span class="nc">DestinationEndpoint</span><span class="o">(</span><span class="n">destination</span><span class="o">)),</span> <span class="s">"destination"</span><span class="o">)</span>
</pre></div>

<p>This ensures that new remote messages never interleave with messages that are replayed to the destination actor during recovery.</p>

<p>Code from this section is contained in <a href="https://github.com/eligosource/eventsourced/blob/master/es-examples/src/main/scala/org/eligosource/eventsourced/example/ReliableChannelExample.scala">ReliableChannelExample.scala</a>. The sender application can be started from sbt with</p>

<pre><code>&gt; project eventsourced-examples
&gt; run-main org.eligosource.eventsourced.example.Sender
</code></pre>

<p>The (remote) destination can be started with</p>

<pre><code>&gt; project eventsourced-examples
&gt; run-main org.eligosource.eventsourced.example.Destination
</code></pre>

<p>The sender application prompts the user to enter messages on <code>stdin</code> which are then reliably sent to the remote destination.</p>

<h3>
<a name="user-content-channel-alternatives" class="anchor" href="#channel-alternatives" aria-hidden="true"><span class="octicon octicon-link"></span></a>Channel alternatives</h3>

<p>A less reliable alternative to channels is communication via sender references. This means producing event messages to destinations that have been passed to a processor via sender references (along with an input event message). These sender references will be <code>deadLetters</code> during a replay which also prevents redundant delivery. The main difference, however, is that the delivery guarantee changes from <em>at-least-once</em> to <em>at-most-once</em>.</p>

<h2>
<a name="user-content-recovery" class="anchor" href="#recovery" aria-hidden="true"><span class="octicon octicon-link"></span></a>Recovery</h2>

<p>Recovery is a procedure that re-creates the state of event-sourced applications consisting of <a href="http://eligosource.github.com/eventsourced/api/snapshot/#org.eligosource.eventsourced.core.Eventsourced"><code>Eventsourced</code></a> actors (processors) and <a href="#channels">channels</a>. Recovery is usually done at application start, either after normal termination or after a crash (but can also be done any time later, even for individual processors and channels).</p>

<div class="highlight highlight-scala"><pre><span class="k">val</span> <span class="n">system</span><span class="k">:</span> <span class="kt">ActorSystem</span> <span class="o">=</span> <span class="err">…</span>
<span class="k">val</span> <span class="n">journal</span><span class="k">:</span> <span class="kt">ActorRef</span> <span class="o">=</span> <span class="err">…</span>

<span class="k">val</span> <span class="n">extension</span> <span class="k">=</span> <span class="nc">EventsourcingExtension</span><span class="o">(</span><span class="n">system</span><span class="o">,</span> <span class="n">journal</span><span class="o">)</span>

<span class="c1">// create and register event-sourced processors</span>
<span class="n">extension</span><span class="o">.</span><span class="n">processorOf</span><span class="o">(</span><span class="err">…</span><span class="o">)</span>
<span class="c1">// …</span>

<span class="c1">// create and register channels</span>
<span class="n">extension</span><span class="o">.</span><span class="n">channelOf</span><span class="o">(</span><span class="err">…</span><span class="o">)</span>
<span class="c1">// …</span>

<span class="c1">// recover state of registered processors and activate channels</span>
<span class="n">extension</span><span class="o">.</span><span class="n">recover</span><span class="o">()</span>

<span class="c1">// processors and channels are now ready to use</span>
<span class="c1">// …</span>
</pre></div>

<p>The <code>recover()</code> method first replays journaled event messages to all registered processors. By replaying the event message history, processors can recover state. Processors that emit event messages to one or more channels will also do so during replay. These channels will either ignore (discard) event messages that have already been successfully delivered (i.e. <em>acknowledged</em>) in previous application runs or buffer them for later delivery. After replay, the <code>recover()</code> method triggers the delivery of buffered messages by activating channels.</p>

<p>If channels delivered event messages immediately instead of buffering them, delivered event messages could wrongly interleave with replayed event messages. This could lead to inconsistencies in event message ordering across application runs and therefore to inconsistencies in application state. Therefore, recovery must ensure that buffered event messages are only delivered after all replayed event messages have been added to their corresponding processors' mailboxes. This is especially important for the recovery of processors and channels that are connected to cyclic, directed graphs.</p>

<h3>
<a name="user-content-replay-parameters" class="anchor" href="#replay-parameters" aria-hidden="true"><span class="octicon octicon-link"></span></a>Replay parameters</h3>

<p>Recovery can be parameterized with <a href="http://eligosource.github.com/eventsourced/api/snapshot/#org.eligosource.eventsourced.core.ReplayParams">replay parameters</a> using the <code>EventsourcingExtension.recover(Seq[ReplayParams])</code> method (or one of its overloaded definitions). <code>ReplayParams</code> allow fine-grained control over state recovery of individual processors. For each processor to be recovered, an application must create a <code>ReplayParams</code> instance. <code>ReplayParams</code> specify</p>

<ul class="task-list">
<li>whether replay should start from scratch, from a <a href="#snapshots">snapshot</a> or from a given sequence number (lower sequence number bound).</li>
<li>whether replay should end at current state or any state in the past (using an upper sequence number bound)</li>
</ul><p>The following two subsections demonstrate some <code>ReplayParams</code> usage examples. For more details, refer to the API docs of <a href="http://eligosource.github.com/eventsourced/api/snapshot/#org.eligosource.eventsourced.core.ReplayParams"><code>ReplayParams</code></a> and its <a href="http://eligosource.github.com/eventsourced/api/snapshot/#org.eligosource.eventsourced.core.ReplayParams%24">companion object</a>. For details about snapshot creation refer to the <a href="#snapshots">Snapshots</a> section.</p>

<h4>
<a name="user-content-recovery-without-snapshots" class="anchor" href="#recovery-without-snapshots" aria-hidden="true"><span class="octicon octicon-link"></span></a>Recovery without snapshots</h4>

<p>As already explained above</p>

<div class="highlight highlight-scala"><pre><span class="k">val</span> <span class="n">extension</span><span class="k">:</span> <span class="kt">EventsourcingExtension</span> <span class="o">=</span> <span class="err">…</span>

<span class="k">import</span> <span class="nn">extension._</span>

<span class="n">recover</span><span class="o">()</span>
</pre></div>

<p>recovers all processors with no lower and upper sequence number bound i.e. all event messages are replayed. This is equivalent to</p>

<div class="highlight highlight-scala"><pre><span class="n">recover</span><span class="o">(</span><span class="n">replayParams</span><span class="o">.</span><span class="n">allFromScratch</span><span class="o">)</span>
</pre></div>

<p>or</p>

<div class="highlight highlight-scala"><pre><span class="n">recover</span><span class="o">(</span><span class="n">processors</span><span class="o">.</span><span class="n">keys</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="n">pid</span> <span class="k">=&gt;</span> <span class="nc">ReplayParams</span><span class="o">(</span><span class="n">pid</span><span class="o">)).</span><span class="n">toSeq</span><span class="o">)</span>
</pre></div>

<p>If an application only wants to recover specific processors it should create <code>ReplayParams</code> only for these processors. For example</p>

<div class="highlight highlight-scala"><pre><span class="n">recover</span><span class="o">(</span><span class="nc">Seq</span><span class="o">(</span><span class="nc">ReplayParams</span><span class="o">(</span><span class="mi">1</span><span class="o">),</span> <span class="nc">ReplayParams</span><span class="o">(</span><span class="mi">2</span><span class="o">)))</span>
</pre></div>

<p>only recovers processors with ids <code>1</code> and <code>2</code>. Upper and lower sequence number bounds can be specified as well.</p>

<div class="highlight highlight-scala"><pre><span class="n">recover</span><span class="o">(</span><span class="nc">Seq</span><span class="o">(</span><span class="nc">ReplayParams</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="n">toSequenceNr</span> <span class="k">=</span> <span class="mi">12651L</span><span class="o">),</span> <span class="nc">ReplayParams</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="n">fromSequenceNr</span> <span class="k">=</span> <span class="mi">10L</span><span class="o">)))</span>
</pre></div>

<p>Here processor <code>1</code> will receive replayed event messages with sequence numbers within range <code>0</code> and <code>12651</code> (inclusive), processor <code>2</code> with receive event messages with sequence numbers starting from <code>10</code> with no upper sequence number bound.</p>

<h4>
<a name="user-content-recovery-with-snapshots" class="anchor" href="#recovery-with-snapshots" aria-hidden="true"><span class="octicon octicon-link"></span></a>Recovery with snapshots</h4>

<p>During snapshot based recovery, a processor receives a <a href="http://eligosource.github.com/eventsourced/api/snapshot/#org.eligosource.eventsourced.core.SnapshotOffer"><code>SnapshotOffer</code></a> message before receiving the remaining event messages (if there are any). A processor uses a <code>SnapshotOffer</code> message to restore its state.</p>

<p><strong>Scala:</strong></p>

<div class="highlight highlight-scala"><pre><span class="k">class</span> <span class="nc">Processor</span> <span class="k">extends</span> <span class="nc">Actor</span> <span class="o">{</span>
  <span class="k">var</span> <span class="n">state</span> <span class="k">=</span> <span class="c1">// …</span>

  <span class="k">def</span> <span class="n">receive</span> <span class="k">=</span> <span class="o">{</span>
    <span class="k">case</span> <span class="n">so</span><span class="k">:</span> <span class="kt">SnapshotOffer</span> <span class="o">=&gt;</span> <span class="n">state</span> <span class="k">=</span> <span class="n">so</span><span class="o">.</span><span class="n">snapshot</span><span class="o">.</span><span class="n">state</span>
    <span class="c1">// …</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div>

<p><strong>Java:</strong></p>

<div class="highlight highlight-java"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Processor</span> <span class="kd">extends</span> <span class="n">UntypedEventsourcedActor</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="n">Object</span> <span class="n">state</span> <span class="o">=</span> <span class="c1">// …</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">onReceive</span><span class="o">(</span><span class="n">Object</span> <span class="n">message</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">Exception</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">message</span> <span class="k">instanceof</span> <span class="n">SnapshotOffer</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">SnapshotOffer</span> <span class="n">so</span> <span class="o">=</span> <span class="o">(</span><span class="n">SnapshotOffer</span><span class="o">)</span><span class="n">message</span><span class="o">;</span>
            <span class="n">state</span> <span class="o">=</span> <span class="n">so</span><span class="o">.</span><span class="na">snapshot</span><span class="o">().</span><span class="na">state</span><span class="o">();</span>
        <span class="o">}</span>
        <span class="c1">// …</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></div>

<p>Snapshot based recovery will only send a <code>SnapshotOffer</code> message to a processor if one or more snapshots have been created for that processor before and these snapshots match the criteria in the corresponding <code>ReplayParams</code>. Relevant criteria are <code>toSequenceNr</code> and <code>snapshotFilter</code>. If there are no snapshots for a processor or existing snapshots do not match <code>ReplayParams</code> criteria, event messages will be replayed from scratch i.e. from sequence number <code>0</code>.</p>

<p>To recover all processors from their latest snapshot</p>

<div class="highlight highlight-scala"><pre><span class="n">recover</span><span class="o">(</span><span class="n">replayParams</span><span class="o">.</span><span class="n">allWithSnapshot</span><span class="o">)</span>
</pre></div>

<p>can be used. This is equivalent to</p>

<div class="highlight highlight-scala"><pre><span class="n">recover</span><span class="o">(</span><span class="n">processors</span><span class="o">.</span><span class="n">keys</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="n">pid</span> <span class="k">=&gt;</span> <span class="nc">ReplayParams</span><span class="o">(</span><span class="n">pid</span><span class="o">,</span> <span class="n">snapshot</span> <span class="k">=</span> <span class="kc">true</span><span class="o">)).</span><span class="n">toSeq</span><span class="o">)</span>
</pre></div>

<p>Snapshot based recovery can also be made with upper sequence number bound.</p>

<div class="highlight highlight-scala"><pre><span class="n">recover</span><span class="o">(</span><span class="nc">Seq</span><span class="o">(</span><span class="nc">ReplayParams</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="n">snapshot</span> <span class="k">=</span> <span class="kc">true</span><span class="o">,</span> <span class="n">toSequenceNr</span> <span class="k">=</span> <span class="mi">12651L</span><span class="o">)))</span>
</pre></div>

<p>This recovers processor <code>1</code> with the latest snapshot that has a sequence number <code>&lt;= 12651</code>. Remaining event messages (if there are any) are replayed up to sequence number <code>12651</code> (inclusive). Applications may also define further constraints on snapshots. For example</p>

<div class="highlight highlight-scala"><pre><span class="k">import</span> <span class="nn">scala.concurrent.duration._</span>

<span class="k">val</span> <span class="n">limit</span> <span class="k">=</span> <span class="nc">System</span><span class="o">.</span><span class="n">currentTimeMillis</span> <span class="o">-</span> <span class="mf">24.</span><span class="n">hours</span><span class="o">.</span><span class="n">toMillis</span>

<span class="n">recover</span><span class="o">(</span><span class="nc">Seq</span><span class="o">(</span><span class="nc">ReplayParams</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="n">snapshotFilter</span> <span class="k">=</span> <span class="n">snapshotMetadata</span> <span class="k">=&gt;</span> <span class="n">snapshotMetadata</span><span class="o">.</span><span class="n">timestamp</span> <span class="o">&lt;</span> <span class="n">limit</span><span class="o">)))</span>
</pre></div>

<p>uses the latest snapshot of processor <code>1</code> that is older than 24 hours. This is done with a <code>snapshotFilter</code> that filters snapshots based on their timestamp. Snapshot filters operate on <a href="http://eligosource.github.com/eventsourced/api/snapshot/#org.eligosource.eventsourced.core.SnapshotMetadata"><code>SnapshotMetadata</code></a>.</p>

<h3>
<a name="user-content-await-processing" class="anchor" href="#await-processing" aria-hidden="true"><span class="octicon octicon-link"></span></a>Await processing</h3>

<p>The <code>recover</code> method waits for replayed messages being sent to all processors (via <code>!</code>) but does not wait for replayed event messages being processed by these processors. However, any new message sent to any registered processor, after <code>recover</code> successfully returned, will be processed after the replayed event messages. Applications that want to wait for processors to complete processing of replayed event messages, should use the <code>awaitProcessing()</code> method of <a href="http://eligosource.github.com/eventsourced/api/snapshot/#org.eligosource.eventsourced.core.EventsourcingExtension"><code>EventsourcingExtension</code></a>.</p>

<div class="highlight highlight-scala"><pre><span class="k">val</span> <span class="n">extension</span><span class="k">:</span> <span class="kt">EventsourcingExtension</span> <span class="o">=</span> <span class="err">…</span>

<span class="n">extension</span><span class="o">.</span><span class="n">recover</span><span class="o">()</span>
<span class="n">extension</span><span class="o">.</span><span class="n">awaitProcessing</span><span class="o">()</span>
</pre></div>

<p>This can be useful in situations where event-sourced processors maintain state via STM references and the application wants to ensure that the (externally visible) state is fully recovered before accepting new read requests from client applications. By default, the <code>awaitProcessing()</code> method waits for all registered processors to complete processing but applications can also specify a subset of registered processors.</p>

<h3>
<a name="user-content-non-blocking-recovery" class="anchor" href="#non-blocking-recovery" aria-hidden="true"><span class="octicon octicon-link"></span></a>Non-blocking recovery</h3>

<p>The <code>recover</code> and <code>awaitProcessing</code> methods block the calling thread. This may be convenient in scenarios where a main thread wants to recover the state of an event-sourced application before taking any further actions. In other scenarios, for example, where recovery is done for individual child processors (and channels) inside an actor (see <a href="https://github.com/eligosource/eventsourced/blob/master/es-examples/src/main/scala/org/eligosource/eventsourced/example/OrderExampleReliable.scala">OrderExampleReliable.scala</a>), the non-blocking recovery API should be used:</p>

<div class="highlight highlight-scala"><pre><span class="k">val</span> <span class="n">extension</span><span class="k">:</span> <span class="kt">EventsourcingExtension</span> <span class="o">=</span> <span class="err">…</span>

<span class="k">val</span> <span class="n">future</span> <span class="k">=</span> <span class="k">for</span> <span class="o">{</span>
  <span class="k">_</span> <span class="k">&lt;-</span> <span class="n">extension</span><span class="o">.</span><span class="n">replay</span><span class="o">(</span><span class="err">…</span><span class="o">)</span>
  <span class="k">_</span> <span class="k">&lt;-</span> <span class="n">extension</span><span class="o">.</span><span class="n">deliver</span><span class="o">(</span><span class="err">…</span><span class="o">)</span>            <span class="c1">// optional</span>
  <span class="k">_</span> <span class="k">&lt;-</span> <span class="n">extension</span><span class="o">.</span><span class="n">completeProcessing</span><span class="o">(</span><span class="err">…</span><span class="o">)</span> <span class="c1">// optional</span>
<span class="o">}</span> <span class="k">yield</span> <span class="o">()</span>

<span class="n">future</span> <span class="n">onSuccess</span> <span class="o">{</span>
  <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="c1">// event-sourced processors now ready to use …</span>
<span class="o">}</span>
</pre></div>

<p>Here, the futures returned by <code>replay</code>, <code>deliver</code> and <code>completeProcessing</code> are monadically composed with a for-comprehension which ensures a sequential execution of the corresponding asynchronous operations. When the composite <code>future</code> completes, the recovered processors and channels are ready to use. More details in the <a href="http://eligosource.github.com/eventsourced/api/snapshot/#org.eligosource.eventsourced.core.EventsourcingExtension">API docs</a>. The <code>replay</code> method can also be parameterized with a <code>ReplayParams</code> sequence (see section <a href="#replay-parameters">Replay parameters</a>).</p>

<h3>
<a name="user-content-channel-recovery-and-usage" class="anchor" href="#channel-recovery-and-usage" aria-hidden="true"><span class="octicon octicon-link"></span></a>Channel recovery and usage</h3>

<p>Channels can even be used by applications immediately after creation i.e. before activating them. This is especially important when event-sourced (parent) processors create new event-sourced child processors during handling of an event:</p>

<div class="highlight highlight-scala"><pre><span class="k">class</span> <span class="nc">Parent</span> <span class="k">extends</span> <span class="nc">Actor</span> <span class="o">{</span> <span class="k">this:</span> <span class="kt">Receiver</span> <span class="kt">with</span> <span class="kt">Eventsourced</span> <span class="o">=&gt;</span>
  <span class="k">import</span> <span class="nn">context.dispatcher</span>

  <span class="k">var</span> <span class="n">child</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">ActorRef</span><span class="o">]</span> <span class="k">=</span> <span class="nc">None</span>

  <span class="k">def</span> <span class="n">receive</span> <span class="k">=</span> <span class="o">{</span>
    <span class="k">case</span> <span class="n">event</span> <span class="k">=&gt;</span> <span class="o">{</span>
        <span class="c1">// create child processor wrapped by channel</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">child</span><span class="o">.</span><span class="n">isEmpty</span><span class="o">)</span> <span class="o">{</span> <span class="n">child</span> <span class="k">=</span> <span class="nc">Some</span><span class="o">(</span><span class="n">createChildProcessor</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="mi">2</span><span class="o">))</span> <span class="o">}</span>
        <span class="c1">// channel can be used immediately</span>
        <span class="n">child</span><span class="o">.</span><span class="n">foreach</span><span class="o">(</span><span class="k">_</span> <span class="o">!</span> <span class="n">message</span><span class="o">.</span><span class="n">copy</span><span class="o">(</span><span class="err">…</span><span class="o">))</span>
    <span class="o">}</span>
  <span class="o">}</span>

  <span class="k">def</span> <span class="n">createChildProcessor</span><span class="o">(</span><span class="n">pid</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">cid</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">ActorRef</span> <span class="o">=</span> <span class="o">{</span>
    <span class="k">implicit</span> <span class="k">val</span> <span class="n">recoveryTimeout</span> <span class="k">=</span> <span class="nc">Timeout</span><span class="o">(</span><span class="mi">10</span> <span class="n">seconds</span><span class="o">)</span>

    <span class="k">val</span> <span class="n">childProcessor</span> <span class="k">=</span> <span class="n">extension</span><span class="o">.</span><span class="n">processorOf</span><span class="o">(</span><span class="nc">Props</span><span class="o">(</span><span class="k">new</span> <span class="nc">Child</span> <span class="k">with</span> <span class="nc">Receiver</span> <span class="k">with</span> <span class="nc">Eventsourced</span> <span class="o">{</span> <span class="k">val</span> <span class="n">id</span> <span class="k">=</span> <span class="n">pid</span> <span class="o">}</span> <span class="o">))</span>
    <span class="k">val</span> <span class="n">childChannel</span> <span class="k">=</span> <span class="n">extension</span><span class="o">.</span><span class="n">channelOf</span><span class="o">(</span><span class="nc">DefaultChannelProps</span><span class="o">(</span><span class="n">cid</span><span class="o">,</span> <span class="n">childProcessor</span><span class="o">))</span>

    <span class="k">for</span> <span class="o">{</span> <span class="c1">// asynchronous, non-blocking recovery</span>
      <span class="k">_</span> <span class="k">&lt;-</span> <span class="n">extension</span><span class="o">.</span><span class="n">replay</span><span class="o">(</span><span class="nc">Seq</span><span class="o">(</span><span class="nc">ReplayParams</span><span class="o">(</span><span class="n">pid</span><span class="o">)))</span>
      <span class="k">_</span> <span class="k">&lt;-</span> <span class="n">extension</span><span class="o">.</span><span class="n">deliver</span><span class="o">(</span><span class="n">cid</span><span class="o">)</span>
    <span class="o">}</span> <span class="k">yield</span> <span class="o">()</span>

    <span class="n">childChannel</span>
  <span class="o">}</span>
<span class="o">}</span>

<span class="k">class</span> <span class="nc">Child</span> <span class="k">extends</span> <span class="nc">Actor</span> <span class="o">{</span> <span class="k">this:</span> <span class="kt">Receiver</span> <span class="o">=&gt;</span>
  <span class="k">def</span> <span class="n">receive</span> <span class="k">=</span> <span class="o">{</span>
    <span class="k">case</span> <span class="n">event</span> <span class="k">=&gt;</span> <span class="o">{</span>
      <span class="err">…</span>
      <span class="n">confirm</span><span class="o">()</span>
    <span class="o">}</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div>

<p>Here, <code>Parent</code> lazily creates a new <code>childProcessor</code> (wrapped by a default channel) on receiving an <code>event</code>. The <code>childChannel</code> is used by <code>Parent</code> immediately after creation i.e. concurrently to <code>childProcessor</code> message replay and <code>childChannel</code> activation. This is possible because a channel internally buffers new messages before its activation and delivers them to its destination after activation. This ensures that new messages will only be delivered to <code>childProcessor</code> after <code>childChannel</code> has been activated. During <code>Parent</code> recovery, <code>childChannel</code> will ignore messages that have already been successfully delivered to <code>childActor</code> (i.e. confirmed by <code>childActor</code>).</p>

<h3>
<a name="user-content-state-dependencies" class="anchor" href="#state-dependencies" aria-hidden="true"><span class="octicon octicon-link"></span></a>State dependencies</h3>

<p>The behavior of <a href="http://eligosource.github.com/eventsourced/api/snapshot/#org.eligosource.eventsourced.core.Eventsourced"><code>Eventsourced</code></a> processors may depend on the state of other <code>Eventsourced</code> processors. For example, processor A sends a message to processor B and processor B replies with a message that includes (part of) processor B's state. Depending on the state value included in the reply, processor A may take different actions. To ensure a proper recovery of such a setup, any state-conveying or state-dependent messages exchanged between processors A and B must be of type <a href="http://eligosource.github.com/eventsourced/api/snapshot/#org.eligosource.eventsourced.core.Message"><code>Message</code></a> (see also <a href="https://github.com/eligosource/eventsourced/blob/master/es-core/src/test/scala/org/eligosource/eventsourced/core/DependentStateRecoverySpec.scala">DependentStateRecoverySpec.scala</a>). Exchanging state via non-journaled messages (i.e. messages of type other than <code>Message</code>) can break consistent recovery. This is also the case if an <code>Eventsourced</code> processor maintains state via an externally visible STM reference and another <code>Eventsourced</code> processor directly reads from that reference. Communication between <code>Eventsourced</code> processors is closely related to <a href="http://martinfowler.com/eaaDev/EventSourcing.html#ExternalQueries">external queries</a> and <a href="http://martinfowler.com/eaaDev/EventSourcing.html#ExternalUpdates">external updates</a>.</p>

<h2>
<a name="user-content-snapshots" class="anchor" href="#snapshots" aria-hidden="true"><span class="octicon octicon-link"></span></a>Snapshots</h2>

<p>Snapshots represent processor state at a certain point in time and can dramatically reduce <a href="#recovery">recovery</a> times. Snapshot capturing and saving is triggered by applications and does not delete entries from the event message history unless explicitly requested by an application.</p>

<p>Applications can create snapshots by sending an <code>Eventsourced</code> processor a <a href="http://eligosource.github.com/eventsourced/api/snapshot/#org.eligosource.eventsourced.core.SnapshotRequest%24"><code>SnapshotRequest</code></a> message (Scala API) or <code>SnapshotRequest.get()</code> message (Java API).</p>

<p><strong>Scala:</strong></p>

<div class="highlight highlight-scala"><pre><span class="k">import</span> <span class="nn">org.eligosource.eventsourced.core._</span>
<span class="c1">// …</span>

<span class="k">val</span> <span class="n">processor</span><span class="k">:</span> <span class="kt">ActorRef</span> <span class="o">=</span> <span class="err">…</span>

<span class="n">processor</span> <span class="o">!</span> <span class="nc">SnapshotRequest</span>
</pre></div>

<p><strong>Java:</strong></p>

<div class="highlight highlight-java"><pre><span class="kn">import</span> <span class="nn">org.eligosource.eventsourced.core.*</span><span class="o">;</span>
<span class="c1">// …</span>

<span class="kd">final</span> <span class="n">ActorRef</span> <span class="n">processor</span> <span class="o">=</span> <span class="err">…</span>

<span class="n">processor</span><span class="o">.</span><span class="na">tell</span><span class="o">(</span><span class="n">SnapshotRequest</span><span class="o">.</span><span class="na">get</span><span class="o">(),</span> <span class="err">…</span><span class="o">)</span>
</pre></div>

<p>This will asynchronously capture and save a snapshot of <code>processor</code>'s state. The sender will be notified when the snapshot has been successfully saved.</p>

<p><strong>Scala:</strong></p>

<div class="highlight highlight-scala"><pre><span class="o">(</span><span class="n">processor</span> <span class="o">?</span> <span class="nc">SnapshotRequest</span><span class="o">).</span><span class="n">mapTo</span><span class="o">[</span><span class="kt">SnapshotSaved</span><span class="o">].</span><span class="n">onComplete</span> <span class="o">{</span>
  <span class="k">case</span> <span class="nc">Success</span><span class="o">(</span><span class="nc">SnapshotSaved</span><span class="o">(</span><span class="n">processorId</span><span class="o">,</span> <span class="n">sequenceNr</span><span class="o">,</span> <span class="n">timestamp</span><span class="o">))</span> <span class="k">=&gt;</span> <span class="err">…</span>
  <span class="k">case</span> <span class="nc">Failure</span><span class="o">(</span><span class="n">e</span><span class="o">)</span>                                                 <span class="k">=&gt;</span> <span class="err">…</span>
<span class="o">}</span>
</pre></div>

<p><strong>Java:</strong></p>

<div class="highlight highlight-java"><pre><span class="n">ask</span><span class="o">(</span><span class="n">processor</span><span class="o">,</span> <span class="n">SnapshotRequest</span><span class="o">.</span><span class="na">get</span><span class="o">(),</span> <span class="mi">5000L</span><span class="o">).</span><span class="na">mapTo</span><span class="o">(</span><span class="n">Util</span><span class="o">.</span><span class="na">classTag</span><span class="o">(</span><span class="n">SnapshotSaved</span><span class="o">.</span><span class="na">class</span><span class="o">)).</span><span class="na">onComplete</span><span class="o">(</span><span class="k">new</span> <span class="n">OnComplete</span><span class="o">&lt;</span><span class="n">SnapshotSaved</span><span class="o">&gt;()</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">onComplete</span><span class="o">(</span><span class="n">Throwable</span> <span class="n">failure</span><span class="o">,</span> <span class="n">SnapshotSaved</span> <span class="n">result</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">failure</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span> <span class="err">…</span> <span class="o">}</span> <span class="k">else</span> <span class="o">{</span> <span class="err">…</span> <span class="o">}</span>
    <span class="o">}</span>
<span class="o">},</span> <span class="n">system</span><span class="o">.</span><span class="na">dispatcher</span><span class="o">());</span>
</pre></div>

<p>Alternatively, applications may also use the <code>EventsourcingExtension.snapshot</code> method to trigger snapshot creation. For example,</p>

<p><strong>Scala:</strong></p>

<div class="highlight highlight-scala"><pre><span class="k">val</span> <span class="n">extension</span><span class="k">:</span> <span class="kt">EventsourcingExtension</span> <span class="o">=</span> <span class="err">…</span>

<span class="n">extension</span><span class="o">.</span><span class="n">snapshot</span><span class="o">(</span><span class="nc">Set</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">))</span> <span class="n">onComplete</span> <span class="o">{</span>
  <span class="k">case</span> <span class="nc">Success</span><span class="o">(</span><span class="n">snapshotSavedSet</span><span class="k">:</span> <span class="kt">Set</span><span class="o">[</span><span class="kt">SnapshotSaved</span><span class="o">])</span> <span class="k">=&gt;</span> <span class="err">…</span>
  <span class="k">case</span> <span class="nc">Failure</span><span class="o">(</span><span class="k">_</span><span class="o">)</span>                                    <span class="k">=&gt;</span> <span class="err">…</span>
<span class="o">}</span>
</pre></div>

<p><strong>Java:</strong></p>

<div class="highlight highlight-java"><pre><span class="n">Set</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">processorIds</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HashSet</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;();</span>

<span class="n">processorIds</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span>
<span class="n">processorIds</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="mi">2</span><span class="o">);</span>

<span class="n">extension</span><span class="o">.</span><span class="na">snapshot</span><span class="o">(</span><span class="n">processorIds</span><span class="o">,</span> <span class="k">new</span> <span class="nf">Timeout</span><span class="o">(</span><span class="mi">5000L</span><span class="o">)).</span><span class="na">onComplete</span><span class="o">(</span><span class="k">new</span> <span class="n">OnComplete</span><span class="o">&lt;</span><span class="n">Set</span><span class="o">&lt;</span><span class="n">SnapshotSaved</span><span class="o">&gt;&gt;()</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">onComplete</span><span class="o">(</span><span class="n">Throwable</span> <span class="n">failure</span><span class="o">,</span> <span class="n">Set</span><span class="o">&lt;</span><span class="n">SnapshotSaved</span><span class="o">&gt;</span> <span class="n">snapshotSavedSet</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">failure</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span> <span class="err">…</span> <span class="o">}</span> <span class="k">else</span> <span class="o">{</span> <span class="err">…</span> <span class="o">}</span>
    <span class="o">}</span>
<span class="o">},</span> <span class="n">system</span><span class="o">.</span><span class="na">dispatcher</span><span class="o">());</span>
</pre></div>

<p>creates snapshots of processors with ids <code>1</code> and <code>2</code>. The returned future (of type <code>Future[scala.immutable.Set[SnapshotSaved]]</code> (Scala API) or <code>Future&lt;java.util.Set&lt;SnapshotSaved&gt;&gt;</code> (Java API)) successfully completes when the snapshots of both processors have been successfully saved.</p>

<p>To participate in snapshot capturing, a processor must process <a href="http://eligosource.github.com/eventsourced/api/snapshot/#org.eligosource.eventsourced.core.SnapshotRequest"><code>SnapshotRequest</code></a> messages by calling their <code>process</code> method with its current <code>state</code> as argument:</p>

<p><strong>Scala:</strong></p>

<div class="highlight highlight-scala"><pre><span class="k">class</span> <span class="nc">Processor</span> <span class="k">extends</span> <span class="nc">Actor</span> <span class="o">{</span>
  <span class="k">var</span> <span class="n">state</span> <span class="k">=</span> <span class="err">…</span>

  <span class="k">def</span> <span class="n">receive</span> <span class="k">=</span> <span class="o">{</span>
    <span class="k">case</span> <span class="n">sr</span><span class="k">:</span> <span class="kt">SnapshotRequest</span> <span class="o">=&gt;</span> <span class="n">sr</span><span class="o">.</span><span class="n">process</span><span class="o">(</span><span class="n">state</span><span class="o">)</span>
    <span class="c1">// …</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div>

<p><strong>Java:</strong></p>

<div class="highlight highlight-java"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Processor</span> <span class="kd">extends</span> <span class="n">UntypedEventsourcedActor</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="n">Object</span> <span class="n">state</span> <span class="o">=</span> <span class="err">…</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">onReceive</span><span class="o">(</span><span class="n">Object</span> <span class="n">message</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">Exception</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">message</span> <span class="k">instanceof</span> <span class="n">SnapshotRequest</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">SnapshotRequest</span> <span class="n">sr</span> <span class="o">=</span> <span class="o">(</span><span class="n">SnapshotRequest</span><span class="o">)</span><span class="n">message</span><span class="o">;</span>
            <span class="n">sr</span><span class="o">.</span><span class="na">process</span><span class="o">(</span><span class="n">state</span><span class="o">,</span> <span class="n">getContext</span><span class="o">());</span>
        <span class="o">}</span>
        <span class="c1">// …</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></div>

<p>Calling <code>process</code> will asynchronously save the <code>state</code> argument together with (generated) snapshot metadata. Creating a new snapshot does not delete older snapshots unless explicitly requested by an application. Hence, there can be n snapshots per processor.</p>

<p>An example that demonstrates snapshot creation and <a href="#recovery-with-snapshots">snapshot based recovery</a> is contained in <a href="https://github.com/eligosource/eventsourced/blob/master/es-examples/src/main/scala/org/eligosource/eventsourced/example/SnapshotExample.scala">SnapshotExample.scala</a> and <a href="https://github.com/eligosource/eventsourced/blob/master/es-examples/src/main/java/org/eligosource/eventsourced/example/japi/SnapshotExample.java">SnapshotExample.java</a>. It can be executed from the sbt prompt with</p>

<p><strong>Scala:</strong></p>

<pre><code>&gt; project eventsourced-examples
&gt; run-main org.eligosource.eventsourced.example.SnapshotExample
</code></pre>

<p><strong>Java:</strong></p>

<pre><code>&gt; project eventsourced-examples
&gt; run-main org.eligosource.eventsourced.example.japi.SnapshotExample
</code></pre>

<h3>
<a name="user-content-configuration" class="anchor" href="#configuration" aria-hidden="true"><span class="octicon octicon-link"></span></a>Configuration</h3>

<p>Snapshotting is supported by all journals via the Hadoop <a href="http://hadoop.apache.org/docs/r1.1.2/api/org/apache/hadoop/fs/FileSystem.html"><code>FileSystem</code></a> abstraction. The default <code>FileSystem</code> instance is the local filesystem i.e. snapshots are by default written locally unless configured otherwise by the application. Please refer to the Hadoop documentation how to create <code>FileSystem</code> instances for HDFS, FTP, S3 etc. Application-defined <code>FileSystem</code> instances can be configured in the following way:</p>

<p><strong>Scala:</strong></p>

<div class="highlight highlight-scala"><pre><span class="c1">// …</span>
<span class="k">import</span> <span class="nn">org.apache.hadoop.fs.FileSystem</span>

<span class="c1">// …</span>
<span class="k">val</span> <span class="n">hdfs</span><span class="k">:</span> <span class="kt">FileSystem</span> <span class="o">=</span> <span class="nc">FileSystem</span><span class="o">.</span><span class="n">get</span><span class="o">(...)</span>
<span class="k">val</span> <span class="n">journal</span><span class="k">:</span> <span class="kt">ActorRef</span> <span class="o">=</span> <span class="nc">LeveldbJournalProps</span><span class="o">(...,</span> <span class="n">snapshotFilesystem</span> <span class="k">=</span> <span class="n">hdfs</span><span class="o">).</span><span class="n">createJournal</span>
</pre></div>

<p><strong>Java:</strong></p>

<div class="highlight highlight-java"><pre><span class="c1">// …</span>
<span class="kn">import</span> <span class="nn">org.apache.hadoop.fs.FileSystem</span><span class="o">;</span>

<span class="c1">// …</span>
<span class="kd">final</span> <span class="n">FileSystem</span> <span class="n">hdfs</span> <span class="o">=</span> <span class="n">FileSystem</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="err">…</span><span class="o">);</span>
<span class="kd">final</span> <span class="n">ActorRef</span> <span class="n">journal</span> <span class="o">=</span> <span class="n">LeveldbJournalProps</span><span class="o">.</span><span class="na">create</span><span class="o">(...).</span><span class="na">withSnapshotFilesystem</span><span class="o">(</span><span class="n">hdfs</span><span class="o">).</span><span class="na">createJournal</span><span class="o">(</span><span class="n">system</span><span class="o">);</span>
</pre></div>

<p>Find out more in the <a href="http://eligosource.github.com/eventsourced/api/snapshot/#org.eligosource.eventsourced.journal.common.snapshot.HadoopFilesystemSnapshottingProps">HadoopFilesystemSnapshottingProps</a> API docs.</p>

<h2>
<a name="user-content-behavior-changes" class="anchor" href="#behavior-changes" aria-hidden="true"><span class="octicon octicon-link"></span></a>Behavior changes</h2>

<p>Actors that are modified with a stackable <code>Receiver</code>, <code>Emitter</code> and/or <code>Eventsourced</code> trait (Scala API) or extend any of the abstract <code>Untyped*</code> base classes (Java API) can change their behavior with the methods <code>become()</code> and <code>unbecome()</code>. These are defined on the <a href="http://eligosource.github.com/eventsourced/api/snapshot/#org.eligosource.eventsourced.core.Behavior"><code>Behavior</code></a> trait from which <code>Receiver</code>, <code>Emitter</code> and <code>Eventsourced</code> inherit.</p>

<p>Actors that change their behavior with <code>become()</code> and <code>unbecome()</code> will keep the functionality introduced by a stackable <code>Receiver</code>, <code>Emitter</code> and/or <code>Eventsourced</code> trait. For example, an actor that is modified with the <code>Eventsourced</code> trait (Scala API) or extends <code>UntypedEventsourcedActor</code> (Java API) will continue to journal event messages after having changed its behavior with <code>become()</code>.</p>

<p>On the other hand, actors that change their behavior with <code>context.become()</code> (Scala API) or <code>getContext().become()</code> (Java API) will loose the functionality introduced by the stackable <code>Receiver</code>, <code>Emitter</code> and/or <code>Eventsourced</code> traits (although the lost behavior can be recovered with <code>context.unbecome()</code> or <code>getContext().unbecome()</code>).</p>

<h2>
<a name="user-content-event-series" class="anchor" href="#event-series" aria-hidden="true"><span class="octicon octicon-link"></span></a>Event series</h2>

<p>When a processor derives more than one output event message from a single input event message and emits those output messages to a single channel, it generates a series of event messages. For an event message series, the event processor should set the <code>ack</code> field for all but the last emitted message to <code>false</code>.</p>

<div class="highlight highlight-scala"><pre><span class="k">class</span> <span class="nc">Processor</span><span class="o">(</span><span class="n">channel</span><span class="k">:</span> <span class="kt">ActorRef</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Actor</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">receive</span> <span class="k">=</span> <span class="o">{</span>
    <span class="k">case</span> <span class="n">msg</span><span class="k">:</span> <span class="kt">Message</span> <span class="o">=&gt;</span> <span class="o">{</span>
      <span class="c1">// …</span>
      <span class="n">channel</span> <span class="o">!</span> <span class="n">msg</span><span class="o">.</span><span class="n">copy</span><span class="o">(</span><span class="n">event</span> <span class="k">=</span> <span class="s">"event 1"</span><span class="o">,</span> <span class="n">ack</span> <span class="k">=</span> <span class="kc">false</span><span class="o">)</span> <span class="c1">// 1st message of series</span>
      <span class="n">channel</span> <span class="o">!</span> <span class="n">msg</span><span class="o">.</span><span class="n">copy</span><span class="o">(</span><span class="n">event</span> <span class="k">=</span> <span class="s">"event 2"</span><span class="o">,</span> <span class="n">ack</span> <span class="k">=</span> <span class="kc">false</span><span class="o">)</span> <span class="c1">// 2nd message of series</span>
      <span class="c1">// …</span>
      <span class="n">channel</span> <span class="o">!</span> <span class="n">msg</span><span class="o">.</span><span class="n">copy</span><span class="o">(</span><span class="n">event</span> <span class="k">=</span> <span class="s">"event n"</span><span class="o">)</span> <span class="c1">// last message of series</span>
    <span class="o">}</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div>

<p>Processors that use an emitter do that in the following way.</p>

<div class="highlight highlight-scala"><pre><span class="k">class</span> <span class="nc">Processor</span> <span class="k">extends</span> <span class="nc">Actor</span> <span class="o">{</span> <span class="k">this:</span> <span class="kt">Emitter</span> <span class="o">=&gt;</span>
  <span class="k">def</span> <span class="n">receive</span> <span class="k">=</span> <span class="o">{</span>
    <span class="k">case</span> <span class="n">event</span> <span class="k">=&gt;</span> <span class="o">{</span>
      <span class="c1">// …</span>
      <span class="n">emitter</span><span class="o">(</span><span class="s">"channelName"</span><span class="o">)</span> <span class="n">send</span> <span class="o">(</span><span class="n">msg</span> <span class="k">=&gt;</span> <span class="n">msg</span><span class="o">.</span><span class="n">copy</span><span class="o">(</span><span class="n">event</span> <span class="k">=</span> <span class="s">"event 1"</span><span class="o">,</span> <span class="n">ack</span> <span class="k">=</span> <span class="kc">false</span><span class="o">))</span> <span class="c1">// 1st message of series</span>
      <span class="n">emitter</span><span class="o">(</span><span class="s">"channelName"</span><span class="o">)</span> <span class="n">send</span> <span class="o">(</span><span class="n">msg</span> <span class="k">=&gt;</span> <span class="n">msg</span><span class="o">.</span><span class="n">copy</span><span class="o">(</span><span class="n">event</span> <span class="k">=</span> <span class="s">"event 2"</span><span class="o">,</span> <span class="n">ack</span> <span class="k">=</span> <span class="kc">false</span><span class="o">))</span> <span class="c1">// 2nd message of series</span>
      <span class="c1">// …</span>
      <span class="n">emitter</span><span class="o">(</span><span class="s">"channelName"</span><span class="o">)</span> <span class="n">sendEvent</span> <span class="s">"event n"</span>
    <span class="o">}</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div>

<p>This ensures that an acknowledgement is only written to the journal after the last message of a series has been successfully</p>

<ul class="task-list">
<li>delivered by a <a href="#defaultchannel">default channel</a> or</li>
<li>stored by a <a href="#reliablechannel">reliable channel</a>
</li>
</ul><p>Destinations, however, should confirm the receipt of every event message, regardless whether it belongs to a series or not.</p>

<h2>
<a name="user-content-idempotency" class="anchor" href="#idempotency" aria-hidden="true"><span class="octicon octicon-link"></span></a>Idempotency</h2>

<p>Under certain failure conditions, <a href="#channels">channels</a> may deliver event messages to destinations more than once. A typical example is that a destination positively confirms a message receipt but the application crashes shortly before that confirmation can be written to the journal. In this case, the destination will receive the event message again during recovery.</p>

<p>For these (but also other) reasons, channel destinations must be idempotent event message consumers which is an application-level concern. For example, an event message consumer that stores received purchase orders in a map (where the map key is the order id) is likely to be an idempotent consumer because receiving a purchase order only once or several times will lead to the same result: the purchase order is contained in the map only once. An event message consumer that counts the number of received purchase orders is not an idempotent consumer: a re-delivery will lead to a wrong counter value from a business logic perspective. In this case the event message consumer must implement some extra means to detect event message <em>duplicates</em>.</p>

<p>For detecting duplicates, applications should use identifiers with their events. Identifier values should be set by an event-sourced processor before an event is emitted via a channel. Channel destinations (or other downstream consumers) should keep track of identifiers of successfully processed events and compare them to identifiers of newly received events. A newly received event with an already known identifier can be considered as a duplicate (assuming that the emitting processor generates unique identifiers). For generating unique identifiers, processors can use the sequence number of received event messages:</p>

<div class="highlight highlight-scala"><pre><span class="k">case</span> <span class="k">class</span> <span class="nc">MyEvent</span><span class="o">(</span><span class="n">details</span><span class="k">:</span> <span class="kt">Any</span><span class="o">,</span> <span class="n">eventId</span><span class="k">:</span> <span class="kt">Long</span><span class="o">)</span>

<span class="k">class</span> <span class="nc">Processor</span> <span class="k">extends</span> <span class="nc">Actor</span> <span class="o">{</span> <span class="k">this:</span> <span class="kt">Emitter</span> <span class="kt">with</span> <span class="kt">Eventsourced</span> <span class="o">=&gt;</span>
  <span class="k">def</span> <span class="n">receive</span> <span class="k">=</span> <span class="o">{</span>
    <span class="k">case</span> <span class="n">event</span> <span class="k">=&gt;</span> <span class="o">{</span>
      <span class="c1">// get sequence number of current event message</span>
      <span class="k">val</span> <span class="n">snr</span><span class="k">:</span> <span class="kt">Long</span> <span class="o">=</span> <span class="n">sequenceNr</span>
      <span class="k">val</span> <span class="n">details</span><span class="k">:</span> <span class="kt">Any</span> <span class="o">=</span> <span class="err">…</span>
      <span class="c1">// …</span>
      <span class="n">emitter</span><span class="o">(</span><span class="s">"channelName"</span><span class="o">)</span> <span class="n">sendEvent</span> <span class="nc">MyEvent</span><span class="o">(</span><span class="n">details</span><span class="o">,</span> <span class="n">snr</span><span class="o">)</span>
    <span class="o">}</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div>

<p>Using the sequence number has the advantage that consumers of emitted events only need to remember the identifier of the last successfully consumed event. If the identifier of a newly received event is less than or equal to that of the last consumed event then it is a duplicate and can therefore be ignored.</p>

<div class="highlight highlight-scala"><pre><span class="k">class</span> <span class="nc">Consumer</span> <span class="k">extends</span> <span class="nc">Actor</span> <span class="o">{</span>
  <span class="k">var</span> <span class="n">lastEventId</span> <span class="k">=</span> <span class="mi">0L</span>

  <span class="k">def</span> <span class="n">receive</span> <span class="k">=</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">MyEvent</span><span class="o">(</span><span class="n">details</span><span class="o">,</span> <span class="n">eventId</span><span class="o">)</span> <span class="k">=&gt;</span>
      <span class="k">if</span> <span class="o">(</span><span class="n">eventId</span> <span class="o">&lt;=</span> <span class="n">lastEventId</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// duplicate</span>
      <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
        <span class="c1">// …</span>
        <span class="n">lastEventId</span> <span class="k">=</span> <span class="n">eventId</span>
      <span class="o">}</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div>

<p>Consumers that are event-sourced processors can store the event identifier as part of their state which will be recovered during an event message replay. Other consumers must store the identifier somewhere else.</p>

<p>Processors that emit <a href="#event-series">event message series</a> should use an event message index in addition to the sequence number to uniquely identify an emitted event:</p>

<div class="highlight highlight-scala"><pre><span class="k">case</span> <span class="k">class</span> <span class="nc">MyEvent</span><span class="o">(</span><span class="n">details</span><span class="k">:</span> <span class="kt">Any</span><span class="o">,</span> <span class="n">eventId</span><span class="k">:</span> <span class="o">(</span><span class="kt">Long</span><span class="o">,</span> <span class="kt">Int</span><span class="o">))</span>

<span class="k">class</span> <span class="nc">Processor</span> <span class="k">extends</span> <span class="nc">Actor</span> <span class="o">{</span> <span class="k">this:</span> <span class="kt">Emitter</span> <span class="kt">with</span> <span class="kt">Eventsourced</span> <span class="o">=&gt;</span>
  <span class="k">def</span> <span class="n">receive</span> <span class="k">=</span> <span class="o">{</span>
    <span class="k">case</span> <span class="n">event</span> <span class="k">=&gt;</span> <span class="o">{</span>
      <span class="c1">// get sequence number of current event message</span>
      <span class="k">val</span> <span class="n">snr</span><span class="k">:</span> <span class="kt">Long</span> <span class="o">=</span> <span class="n">sequenceNr</span>
      <span class="k">val</span> <span class="n">details</span><span class="k">:</span> <span class="kt">Seq</span><span class="o">[</span><span class="kt">Any</span><span class="o">]</span> <span class="k">=</span> <span class="err">…</span>
      <span class="c1">// …</span>
      <span class="n">emitter</span><span class="o">(</span><span class="s">"channelName"</span><span class="o">)</span> <span class="n">send</span> <span class="o">(</span><span class="n">msg</span> <span class="k">=&gt;</span> <span class="n">msg</span><span class="o">.</span><span class="n">copy</span><span class="o">(</span><span class="n">event</span> <span class="k">=</span> <span class="nc">MyEvent</span><span class="o">(</span><span class="n">details</span><span class="o">(</span><span class="mi">0</span><span class="o">),</span> <span class="o">(</span><span class="n">snr</span><span class="o">,</span> <span class="mi">0</span><span class="o">)),</span> <span class="n">ack</span> <span class="k">=</span> <span class="kc">false</span><span class="o">))</span>
      <span class="n">emitter</span><span class="o">(</span><span class="s">"channelName"</span><span class="o">)</span> <span class="n">send</span> <span class="o">(</span><span class="n">msg</span> <span class="k">=&gt;</span> <span class="n">msg</span><span class="o">.</span><span class="n">copy</span><span class="o">(</span><span class="n">event</span> <span class="k">=</span> <span class="nc">MyEvent</span><span class="o">(</span><span class="n">details</span><span class="o">(</span><span class="mi">1</span><span class="o">),</span> <span class="o">(</span><span class="n">snr</span><span class="o">,</span> <span class="mi">1</span><span class="o">)),</span> <span class="n">ack</span> <span class="k">=</span> <span class="kc">false</span><span class="o">))</span>
      <span class="c1">// …</span>
    <span class="o">}</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div>

<p>Consumers should then compare the sequence number - index pairs for detecting duplicates.</p>

<h2>
<a name="user-content-serialization" class="anchor" href="#serialization" aria-hidden="true"><span class="octicon octicon-link"></span></a>Serialization</h2>

<p>Applications can configure custom serializers for events of event <code>Message</code>s. Custom serializers are used for both, writing the event to a journal and for remote communication. They can be configured like any other <a href="http://doc.akka.io/docs/akka/2.1.0/scala/serialization.html">Akka serializer</a>. For example:</p>

<pre><code>akka {
  actor {
    serializers {
      custom = "example.MyEventSerializer"
    }
    serialization-bindings {
      "example.MyEvent" = custom
    }
  }
}
</code></pre>

<p>Here, <code>example.MyEvent</code> is an application-specific event type and <code>example.MyEventSerializer</code> is an application-specific serializer that extends <code>akka.serialization.Serializer</code></p>

<div class="highlight highlight-scala"><pre><span class="k">import</span> <span class="nn">akka.serialization.Serializer</span>

<span class="k">class</span> <span class="nc">CustomEventSerializer</span> <span class="k">extends</span> <span class="nc">Serializer</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">identifier</span> <span class="k">=</span> <span class="err">…</span>
  <span class="k">def</span> <span class="n">includeManifest</span> <span class="k">=</span> <span class="kc">true</span>

  <span class="k">def</span> <span class="n">toBinary</span><span class="o">(</span><span class="n">o</span><span class="k">:</span> <span class="kt">AnyRef</span><span class="o">)</span> <span class="k">=</span> <span class="err">…</span>
  <span class="k">def</span> <span class="n">fromBinary</span><span class="o">(</span><span class="n">bytes</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">Byte</span><span class="o">],</span> <span class="n">manifest</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">Class</span><span class="o">[</span><span class="k">_</span><span class="o">]])</span> <span class="k">=</span> <span class="err">…</span>
<span class="o">}</span>
</pre></div>

<p>Event <a href="http://eligosource.github.com/eventsourced/api/snapshot/#org.eligosource.eventsourced.core.Message">Message</a>s themselves are serialized with a <a href="https://github.com/eligosource/eventsourced/blob/master/es-journal/es-journal-common/src/main/resources/reference.conf#L4">pre-configured</a>, library-specific serializer. This serializer is automatically used for event <code>Message</code>s when the <code>eventsourced-journal-common-*.jar</code> is on the classpath of an Akka application.</p>

<h2>
<a name="user-content-further-examples" class="anchor" href="#further-examples" aria-hidden="true"><span class="octicon octicon-link"></span></a>Further examples</h2>

<h3>
<a name="user-content-order-management" class="anchor" href="#order-management" aria-hidden="true"><span class="octicon octicon-link"></span></a>Order management</h3>

<p>The order management example in this section is taken from <a href="http://www.martinfowler.com/">Martin Fowler</a>'s great <a href="http://martinfowler.com/articles/lmax.html">LMAX article</a>:</p>

<blockquote>
<p>Imagine you are making an order for jelly beans by credit card. A simple retailing system would take your order information, use a credit card validation service to check your credit card number, and then confirm your order - all within a single operation. The thread processing your order would block while waiting for the credit card to be checked, but that block wouldn't be very long for the user, and the server can always run another thread on the processor while it's waiting.</p>

<p>In the LMAX architecture, you would split this operation into two. The first operation would capture the order information and finish by outputting an event (credit card validation requested) to the credit card company. The Business Logic Processor would then carry on processing events for other customers until it received a credit-card-validated event in its input event stream. On processing that event it would carry out the confirmation tasks for that order.</p>
</blockquote>

<p>This can be implemented with the Eventsourced library as shown in the following diagram (legend is in <a href="#appendix-a-legend">Appendix A</a>).</p>

<p><a href="https://camo.githubusercontent.com/cfebf4d807fad657a1d87fcc59a95d552af05dcb/68747470733a2f2f7261772e6769746875622e636f6d2f656c69676f736f757263652f6576656e74736f75726365642f6d61737465722f646f632f696d616765732f6f726465726d676e742d312e706e67" target="_blank"><img src="https://camo.githubusercontent.com/cfebf4d807fad657a1d87fcc59a95d552af05dcb/68747470733a2f2f7261772e6769746875622e636f6d2f656c69676f736f757263652f6576656e74736f75726365642f6d61737465722f646f632f696d616765732f6f726465726d676e742d312e706e67" alt="Order management" data-canonical-src="https://raw.github.com/eligosource/eventsourced/master/doc/images/ordermgnt-1.png" style="max-width:100%;"></a></p>

<ul class="task-list">
<li>We implement the mentioned <em>Business Logic Processor</em> processor as event-sourced actor (<code>OrderProcessor</code>). It processes <code>OrderSubmitted</code> events by assigning submitted orders an id and storing them in a map (= state of <code>OrderProcessor</code>). For every submitted order it emits a <code>CreditCardValidationRequested</code> event.</li>
<li>
<code>CreditCardValidationRequested</code> events are processed by a <code>CreditCardValidator</code> actor. It contacts an external credit card validation service and sends <code>CreditCardValidated</code> events back to the <code>OrderProcessor</code> for every order with a valid credit card number. In the example implementation below, we won't actually use an external service to keep the implementation simple, but for real-world implementations, <a href="http://doc.akka.io/docs/akka/2.1.0/scala/camel.html">akka-camel</a> would be a perfect fit here.</li>
<li>On receiving a <code>CreditCardValidated</code> event, the event-sourced <code>OrderProcessor</code> updates the status of corresponding order to <code>validated = true</code> and sends an <code>OrderAccepted</code> event, containing the updated order, to <code>Destination</code>. It also replies the updated order to the initial sender.</li>
</ul><p>The <code>Order</code> domain object, the domain events and the <code>OrderProcessor</code> are defined as follows:</p>

<div class="highlight highlight-scala"><pre><span class="c1">// domain object</span>
<span class="k">case</span> <span class="k">class</span> <span class="nc">Order</span><span class="o">(</span><span class="n">id</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="n">details</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">validated</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">false</span><span class="o">,</span> <span class="n">creditCardNumber</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span>

<span class="c1">// domain events</span>
<span class="k">case</span> <span class="k">class</span> <span class="nc">OrderSubmitted</span><span class="o">(</span><span class="n">order</span><span class="k">:</span> <span class="kt">Order</span><span class="o">)</span>
<span class="k">case</span> <span class="k">class</span> <span class="nc">OrderAccepted</span><span class="o">(</span><span class="n">order</span><span class="k">:</span> <span class="kt">Order</span><span class="o">)</span>
<span class="k">case</span> <span class="k">class</span> <span class="nc">CreditCardValidationRequested</span><span class="o">(</span><span class="n">order</span><span class="k">:</span> <span class="kt">Order</span><span class="o">)</span>
<span class="k">case</span> <span class="k">class</span> <span class="nc">CreditCardValidated</span><span class="o">(</span><span class="n">orderId</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span>

<span class="c1">// event-sourced order processor</span>
<span class="k">class</span> <span class="nc">OrderProcessor</span> <span class="k">extends</span> <span class="nc">Actor</span> <span class="o">{</span> <span class="k">this:</span> <span class="kt">Emitter</span> <span class="o">=&gt;</span>
  <span class="k">var</span> <span class="n">orders</span> <span class="k">=</span> <span class="nc">Map</span><span class="o">.</span><span class="n">empty</span><span class="o">[</span><span class="kt">Int</span>, <span class="kt">Order</span><span class="o">]</span> <span class="c1">// processor state</span>

  <span class="k">def</span> <span class="n">receive</span> <span class="k">=</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">OrderSubmitted</span><span class="o">(</span><span class="n">order</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="o">{</span>
      <span class="k">val</span> <span class="n">id</span> <span class="k">=</span> <span class="n">orders</span><span class="o">.</span><span class="n">size</span>
      <span class="k">val</span> <span class="n">upd</span> <span class="k">=</span> <span class="n">order</span><span class="o">.</span><span class="n">copy</span><span class="o">(</span><span class="n">id</span> <span class="k">=</span> <span class="n">id</span><span class="o">)</span>
      <span class="n">orders</span> <span class="k">=</span> <span class="n">orders</span> <span class="o">+</span> <span class="o">(</span><span class="n">id</span> <span class="o">-&gt;</span> <span class="n">upd</span><span class="o">)</span>
      <span class="n">emitter</span><span class="o">(</span><span class="s">"validation_requests"</span><span class="o">)</span> <span class="n">forwardEvent</span> <span class="nc">CreditCardValidationRequested</span><span class="o">(</span><span class="n">upd</span><span class="o">)</span>
    <span class="o">}</span>
    <span class="k">case</span> <span class="nc">CreditCardValidated</span><span class="o">(</span><span class="n">orderId</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="o">{</span>
      <span class="n">orders</span><span class="o">.</span><span class="n">get</span><span class="o">(</span><span class="n">orderId</span><span class="o">).</span><span class="n">foreach</span> <span class="o">{</span> <span class="n">order</span> <span class="k">=&gt;</span>
        <span class="k">val</span> <span class="n">upd</span> <span class="k">=</span> <span class="n">order</span><span class="o">.</span><span class="n">copy</span><span class="o">(</span><span class="n">validated</span> <span class="k">=</span> <span class="kc">true</span><span class="o">)</span>
        <span class="n">orders</span> <span class="k">=</span> <span class="n">orders</span> <span class="o">+</span> <span class="o">(</span><span class="n">orderId</span> <span class="o">-&gt;</span> <span class="n">upd</span><span class="o">)</span>
        <span class="n">sender</span> <span class="o">!</span> <span class="n">upd</span>
        <span class="n">emitter</span><span class="o">(</span><span class="s">"accepted_orders"</span><span class="o">)</span> <span class="n">sendEvent</span> <span class="nc">OrderAccepted</span><span class="o">(</span><span class="n">upd</span><span class="o">)</span>
      <span class="o">}</span>
    <span class="o">}</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div>

<p>The <code>OrderProcessor</code> uses a message <code>emitter</code> to send <code>CreditCardValidationRequested</code> events to <code>CreditCardValidator</code> via the named <code>"validation_requests"</code> channel. The <code>forwardEvent</code> method not only sends the event but also forwards the initial <a href="#sender-references">sender reference</a>. Upon receiving a <code>CreditCardValidationRequested</code> event, the <code>CreditCardValidator</code> runs a credit card validation in the background and sends a <code>CreditCardValidated</code> event back to the <code>OrderProcessor</code></p>

<div class="highlight highlight-scala"><pre><span class="k">class</span> <span class="nc">CreditCardValidator</span><span class="o">(</span><span class="n">orderProcessor</span><span class="k">:</span> <span class="kt">ActorRef</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Actor</span> <span class="o">{</span> <span class="k">this:</span> <span class="kt">Receiver</span> <span class="o">=&gt;</span>
  <span class="k">def</span> <span class="n">receive</span> <span class="k">=</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">CreditCardValidationRequested</span><span class="o">(</span><span class="n">order</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="o">{</span>
      <span class="k">val</span> <span class="n">sdr</span> <span class="k">=</span> <span class="n">sender</span>  <span class="c1">// initial sender</span>
      <span class="k">val</span> <span class="n">msg</span> <span class="k">=</span> <span class="n">message</span> <span class="c1">// current event message</span>
      <span class="nc">Future</span> <span class="o">{</span>
        <span class="c1">// do some credit card validation</span>
        <span class="c1">// …</span>

        <span class="c1">// and send back a successful validation result (preserving the initial sender)</span>
        <span class="n">orderProcessor</span> <span class="n">tell</span> <span class="o">(</span><span class="n">msg</span><span class="o">.</span><span class="n">copy</span><span class="o">(</span><span class="n">event</span> <span class="k">=</span> <span class="nc">CreditCardValidated</span><span class="o">(</span><span class="n">order</span><span class="o">.</span><span class="n">id</span><span class="o">)),</span> <span class="n">sdr</span><span class="o">)</span>
      <span class="o">}</span>
    <span class="o">}</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div>

<p>The <code>CreditCardValidator</code> again forwards the initial sender reference which finally enables the <code>OrderProcessor</code> to reply to the initial sender when it receives the <code>CreditCardValidated</code> event. The <code>OrderProcessor</code> also sends an <code>OrderAccepted</code> event to <code>Destination</code> via the named <code>"accepted_orders"</code> channel.</p>

<div class="highlight highlight-scala"><pre><span class="k">class</span> <span class="nc">Destination</span> <span class="k">extends</span> <span class="nc">Actor</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">receive</span> <span class="k">=</span> <span class="o">{</span>
    <span class="k">case</span> <span class="n">event</span> <span class="k">=&gt;</span> <span class="n">println</span><span class="o">(</span><span class="s">"received event %s"</span> <span class="n">format</span> <span class="n">event</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div>

<p>Next step is to wire the collaborators and to recover them:</p>

<div class="highlight highlight-scala"><pre><span class="k">val</span> <span class="n">extension</span><span class="k">:</span> <span class="kt">EventsourcingExtension</span> <span class="o">=</span> <span class="err">…</span>

<span class="k">val</span> <span class="n">processor</span> <span class="k">=</span> <span class="n">extension</span><span class="o">.</span><span class="n">processorOf</span><span class="o">(</span><span class="nc">Props</span><span class="o">(</span><span class="k">new</span> <span class="nc">OrderProcessor</span> <span class="k">with</span> <span class="nc">Emitter</span> <span class="k">with</span> <span class="nc">Confirm</span> <span class="k">with</span> <span class="nc">Eventsourced</span> <span class="o">{</span> <span class="k">val</span> <span class="n">id</span> <span class="k">=</span> <span class="mi">1</span> <span class="o">}))</span>
<span class="k">val</span> <span class="n">validator</span> <span class="k">=</span> <span class="n">system</span><span class="o">.</span><span class="n">actorOf</span><span class="o">(</span><span class="nc">Props</span><span class="o">(</span><span class="k">new</span> <span class="nc">CreditCardValidator</span><span class="o">(</span><span class="n">processor</span><span class="o">)</span> <span class="k">with</span> <span class="nc">Receiver</span><span class="o">))</span>
<span class="k">val</span> <span class="n">destination</span> <span class="k">=</span> <span class="n">system</span><span class="o">.</span><span class="n">actorOf</span><span class="o">(</span><span class="nc">Props</span><span class="o">(</span><span class="k">new</span> <span class="nc">Destination</span> <span class="k">with</span> <span class="nc">Receiver</span> <span class="k">with</span> <span class="nc">Confirm</span><span class="o">))</span>

<span class="n">extension</span><span class="o">.</span><span class="n">channelOf</span><span class="o">(</span><span class="nc">ReliableChannelProps</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="n">validator</span><span class="o">).</span><span class="n">withName</span><span class="o">(</span><span class="s">"validation_requests"</span><span class="o">))</span>
<span class="n">extension</span><span class="o">.</span><span class="n">channelOf</span><span class="o">(</span><span class="nc">DefaultChannelProps</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="n">destination</span><span class="o">).</span><span class="n">withName</span><span class="o">(</span><span class="s">"accepted_orders"</span><span class="o">))</span>

<span class="n">extension</span><span class="o">.</span><span class="n">recover</span><span class="o">()</span>
</pre></div>

<p>The named <code>"validation requests"</code> channel is a reliable channel that re-delivers <code>CreditCardValidationRequested</code> events in case of <code>CreditCardValidator</code> failures (for example, when the external credit card validation service is temporarily unavailable). Furthermore, it should be noted that the <code>CreditCardValidator</code> does not confirm event message deliveries (it neither calls <code>confirm()</code> explicitly nor is it modified with the <code>Confirm</code> trait during instantiation). Delivery confirmation will take place when the <code>OrderProcessor</code> successfully processed the <code>CreditCardValidated</code> event.</p>

<p>The <code>Order processor</code> is now ready to receive <code>OrderSubmitted</code> events.</p>

<div class="highlight highlight-scala"><pre><span class="n">processor</span> <span class="o">?</span> <span class="nc">Message</span><span class="o">(</span><span class="nc">OrderSubmitted</span><span class="o">(</span><span class="nc">Order</span><span class="o">(</span><span class="n">details</span> <span class="k">=</span> <span class="s">"jelly beans"</span><span class="o">,</span> <span class="n">creditCardNumber</span> <span class="k">=</span> <span class="s">"1234-5678-1234-5678"</span><span class="o">)))</span> <span class="n">onSuccess</span> <span class="o">{</span>
  <span class="k">case</span> <span class="n">order</span><span class="k">:</span> <span class="kt">Order</span> <span class="o">=&gt;</span> <span class="n">println</span><span class="o">(</span><span class="s">"received response %s"</span> <span class="n">format</span> <span class="n">order</span><span class="o">)</span>
<span class="o">}</span>
</pre></div>

<p>Running this example with an empty journal will write</p>

<pre><code>received response Order(0,jelly beans,true,1234-5678-1234-5678)
received event OrderAccepted(Order(0,jelly beans,true,1234-5678-1234-5678))
</code></pre>

<p>to <code>stdout</code>. You may observe a different line ordering when running the example. The submitted order was assigned an <code>id</code> of <code>0</code> which corresponds to the initial size of the <code>OrderProcessor</code>'s <code>orders</code> map. A second application run will first recover the previous application state, so that another order submission will generate an order <code>id</code> of <code>1</code>.</p>

<pre><code>received response Order(1,jelly beans,true,1234-5678-1234-5678)
received event OrderAccepted(Order(1,jelly beans,true,1234-5678-1234-5678))
</code></pre>

<p>The example code is contained in <a href="https://github.com/eligosource/eventsourced/blob/master/es-examples/src/main/scala/org/eligosource/eventsourced/example/OrderExample.scala">OrderExample.scala</a> and can be executed from the sbt prompt with</p>

<pre><code>&gt; project eventsourced-examples
&gt; run-main org.eligosource.eventsourced.example.OrderExample
</code></pre>

<p>An advanced version of this example, using a <a href="#reliable-request-reply-channel">reliable request-reply channel</a>, is discussed in <a href="http://krasserm.blogspot.com/2013/01/event-sourcing-and-external-service.html">Event sourcing and external service integration</a>.</p>

<h3>
<a name="user-content-state-machines" class="anchor" href="#state-machines" aria-hidden="true"><span class="octicon octicon-link"></span></a>State machines</h3>

<p><a href="https://camo.githubusercontent.com/01ba3b885fddec4193f789fea12fa9884d59f4bd/68747470733a2f2f7261772e6769746875622e636f6d2f656c69676f736f757263652f6576656e74736f75726365642f6d61737465722f646f632f696d616765732f73746174656d616368696e65732d312e706e67" target="_blank"><img src="https://camo.githubusercontent.com/01ba3b885fddec4193f789fea12fa9884d59f4bd/68747470733a2f2f7261772e6769746875622e636f6d2f656c69676f736f757263652f6576656e74736f75726365642f6d61737465722f646f632f696d616765732f73746174656d616368696e65732d312e706e67" alt="State machines" data-canonical-src="https://raw.github.com/eligosource/eventsourced/master/doc/images/statemachines-1.png" style="max-width:100%;"></a></p>

<p>With a <a href="https://www.assembla.com/spaces/akka/tickets/2680">change</a> since Akka 2.1, event-sourcing Akka <a href="http://doc.akka.io/docs/akka/2.1.0/scala/fsm.html">FSM</a>s is now pretty easy. The following state machine example is a <code>Door</code> which can be in one of two states: <code>Open</code> and <code>Closed</code>.</p>

<div class="highlight highlight-scala"><pre><span class="k">sealed</span> <span class="k">trait</span> <span class="nc">DoorState</span>

<span class="k">case</span> <span class="k">object</span> <span class="nc">Open</span> <span class="k">extends</span> <span class="nc">DoorState</span>
<span class="k">case</span> <span class="k">object</span> <span class="nc">Closed</span> <span class="k">extends</span> <span class="nc">DoorState</span>

<span class="k">case</span> <span class="k">class</span> <span class="nc">DoorMoved</span><span class="o">(</span><span class="n">state</span><span class="k">:</span> <span class="kt">DoorState</span><span class="o">,</span> <span class="n">times</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span>
<span class="k">case</span> <span class="k">class</span> <span class="nc">DoorNotMoved</span><span class="o">(</span><span class="n">state</span><span class="k">:</span> <span class="kt">DoorState</span><span class="o">,</span> <span class="n">cmd</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span>
<span class="k">case</span> <span class="k">class</span> <span class="nc">NotSupported</span><span class="o">(</span><span class="n">cmd</span><span class="k">:</span> <span class="kt">Any</span><span class="o">)</span>

<span class="k">class</span> <span class="nc">Door</span> <span class="k">extends</span> <span class="nc">Actor</span> <span class="k">with</span> <span class="nc">FSM</span><span class="o">[</span><span class="kt">DoorState</span>, <span class="kt">Int</span><span class="o">]</span> <span class="o">{</span> <span class="k">this:</span> <span class="kt">Emitter</span> <span class="o">=&gt;</span>
  <span class="n">startWith</span><span class="o">(</span><span class="nc">Closed</span><span class="o">,</span> <span class="mi">0</span><span class="o">)</span>

  <span class="n">when</span><span class="o">(</span><span class="nc">Closed</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">Event</span><span class="o">(</span><span class="s">"open"</span><span class="o">,</span> <span class="n">counter</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="o">{</span>
      <span class="n">emit</span><span class="o">(</span><span class="nc">DoorMoved</span><span class="o">(</span><span class="nc">Open</span><span class="o">,</span> <span class="n">counter</span> <span class="o">+</span> <span class="mi">1</span><span class="o">))</span>
      <span class="n">goto</span><span class="o">(</span><span class="nc">Open</span><span class="o">)</span> <span class="n">using</span><span class="o">(</span><span class="n">counter</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span>
    <span class="o">}</span>
  <span class="o">}</span>

  <span class="n">when</span><span class="o">(</span><span class="nc">Open</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">Event</span><span class="o">(</span><span class="s">"close"</span><span class="o">,</span> <span class="n">counter</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="o">{</span>
      <span class="n">emit</span><span class="o">(</span><span class="nc">DoorMoved</span><span class="o">(</span><span class="nc">Closed</span><span class="o">,</span> <span class="n">counter</span> <span class="o">+</span> <span class="mi">1</span><span class="o">))</span>
      <span class="n">goto</span><span class="o">(</span><span class="nc">Closed</span><span class="o">)</span> <span class="n">using</span><span class="o">(</span><span class="n">counter</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span>
    <span class="o">}</span>
  <span class="o">}</span>

  <span class="n">whenUnhandled</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">Event</span><span class="o">(</span><span class="n">cmd</span> <span class="k">@</span> <span class="o">(</span><span class="s">"open"</span> <span class="o">|</span> <span class="s">"close"</span><span class="o">),</span> <span class="n">counter</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="o">{</span>
      <span class="n">emit</span><span class="o">(</span><span class="nc">DoorNotMoved</span><span class="o">(</span><span class="n">stateName</span><span class="o">,</span> <span class="s">"cannot %s door"</span> <span class="n">format</span> <span class="n">cmd</span><span class="o">))</span>
      <span class="n">stay</span>
    <span class="o">}</span>
    <span class="k">case</span> <span class="nc">Event</span><span class="o">(</span><span class="n">cmd</span><span class="o">,</span> <span class="n">counter</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="o">{</span>
      <span class="n">emit</span><span class="o">(</span><span class="nc">NotSupported</span><span class="o">(</span><span class="n">cmd</span><span class="o">))</span>
      <span class="n">stay</span>
    <span class="o">}</span>
  <span class="o">}</span>

  <span class="k">def</span> <span class="n">emit</span><span class="o">(</span><span class="n">event</span><span class="k">:</span> <span class="kt">Any</span><span class="o">)</span> <span class="k">=</span> <span class="n">emitter</span><span class="o">(</span><span class="s">"destination"</span><span class="o">)</span> <span class="n">forwardEvent</span> <span class="n">event</span>
<span class="o">}</span>
</pre></div>

<p>On state changes, a door emits <code>DoorMoved</code> events to the named <code>"destination"</code> channel. <code>DoorMoved</code> events contain the door's current state and the number of moves so far. On invalid attempts to move a door e.g. trying to open an opened door, a <code>DoorNotMoved</code> event is emitted. The channel destination is an actor that simply prints received events to <code>stdout</code>.</p>

<div class="highlight highlight-scala"><pre><span class="k">class</span> <span class="nc">Destination</span> <span class="k">extends</span> <span class="nc">Actor</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">receive</span> <span class="k">=</span> <span class="o">{</span> <span class="k">case</span> <span class="n">event</span> <span class="k">=&gt;</span> <span class="n">println</span><span class="o">(</span><span class="s">"received event %s"</span> <span class="n">format</span> <span class="n">event</span><span class="o">)</span> <span class="o">}</span>
<span class="o">}</span>
</pre></div>

<p>After configuring the application</p>

<div class="highlight highlight-scala"><pre><span class="k">val</span> <span class="n">system</span><span class="k">:</span> <span class="kt">ActorSystem</span> <span class="o">=</span> <span class="err">…</span>
<span class="k">val</span> <span class="n">extension</span><span class="k">:</span> <span class="kt">EventsourcingExtension</span> <span class="o">=</span> <span class="err">…</span>

<span class="k">val</span> <span class="n">destination</span> <span class="k">=</span> <span class="n">system</span><span class="o">.</span><span class="n">actorOf</span><span class="o">(</span><span class="nc">Props</span><span class="o">(</span><span class="k">new</span> <span class="nc">Destination</span> <span class="k">with</span> <span class="nc">Receiver</span> <span class="k">with</span> <span class="nc">Confirm</span><span class="o">))</span>

<span class="n">extension</span><span class="o">.</span><span class="n">channelOf</span><span class="o">(</span><span class="nc">DefaultChannelProps</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="n">destination</span><span class="o">).</span><span class="n">withName</span><span class="o">(</span><span class="s">"destination"</span><span class="o">))</span>
<span class="n">extension</span><span class="o">.</span><span class="n">processorOf</span><span class="o">(</span><span class="nc">Props</span><span class="o">(</span><span class="k">new</span> <span class="nc">Door</span> <span class="k">with</span> <span class="nc">Emitter</span> <span class="k">with</span> <span class="nc">Eventsourced</span> <span class="o">{</span> <span class="k">val</span> <span class="n">id</span> <span class="k">=</span> <span class="mi">1</span> <span class="o">}</span> <span class="o">))</span>
<span class="n">extension</span><span class="o">.</span><span class="n">recover</span><span class="o">()</span>

<span class="k">val</span> <span class="n">door</span> <span class="k">=</span> <span class="n">extension</span><span class="o">.</span><span class="n">processors</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span>
</pre></div>

<p>we can start sending event messages to <code>door</code>:</p>

<div class="highlight highlight-scala"><pre><span class="n">door</span> <span class="o">!</span> <span class="nc">Message</span><span class="o">(</span><span class="s">"open"</span><span class="o">)</span>
<span class="n">door</span> <span class="o">!</span> <span class="nc">Message</span><span class="o">(</span><span class="s">"close"</span><span class="o">)</span>
</pre></div>

<p>This will write</p>

<pre><code>received event DoorMoved(Open,1)
received event DoorMoved(Closed,2)
</code></pre>

<p>to <code>stdout</code>. When trying to attempt an invalid state change with</p>

<div class="highlight highlight-scala"><pre><span class="n">door</span> <span class="o">!</span> <span class="nc">Message</span><span class="o">(</span><span class="s">"close"</span><span class="o">)</span>
</pre></div>

<p>the <code>destination</code> will receive a <code>DoorNotMoved</code> event:</p>

<pre><code>received event DoorNotMoved(Closed,cannot close door)
</code></pre>

<p>Restarting the example application will recover the door's state so that</p>

<div class="highlight highlight-scala"><pre><span class="n">door</span> <span class="o">!</span> <span class="nc">Message</span><span class="o">(</span><span class="s">"open"</span><span class="o">)</span>
<span class="n">door</span> <span class="o">!</span> <span class="nc">Message</span><span class="o">(</span><span class="s">"close"</span><span class="o">)</span>
</pre></div>

<p>will produce</p>

<pre><code>received event DoorMoved(Open,3)
received event DoorMoved(Closed,4)
</code></pre>

<p>The code from this section is contained in slightly modified form in <a href="https://github.com/eligosource/eventsourced/blob/master/es-core-test/src/test/scala/org/eligosource/eventsourced/core/FsmSpec.scala">FsmExample.scala</a>.</p>

<h3>
<a name="user-content-clustering" class="anchor" href="#clustering" aria-hidden="true"><span class="octicon octicon-link"></span></a>Clustering</h3>

<p>This section makes the <code>Door</code> state machine from the <a href="#state-machines">previous example</a> highly-available in an Akka <a href="http://doc.akka.io/docs/akka/2.1.0/cluster/index.html">cluster</a>. The <code>Door</code> state machine is a cluster-wide singleton that is managed by <code>NodeActor</code>s. There's one <code>NodeActor</code> per cluster node listening to cluster events. If a <code>NodeActor</code> becomes the master (= leader) it creates and recovers a <code>Door</code> instance. The other <code>NodeActor</code>s obtain a remote reference to the <code>Door</code> instance on master.</p>

<p><a href="https://camo.githubusercontent.com/a9eab53cb7f2e7db715c08a3fd2d91fa37de8429/68747470733a2f2f7261772e6769746875622e636f6d2f656c69676f736f757263652f6576656e74736f75726365642f6d61737465722f646f632f696d616765732f636c7573746572696e672d312e706e67" target="_blank"><img src="https://camo.githubusercontent.com/a9eab53cb7f2e7db715c08a3fd2d91fa37de8429/68747470733a2f2f7261772e6769746875622e636f6d2f656c69676f736f757263652f6576656e74736f75726365642f6d61737465722f646f632f696d616765732f636c7573746572696e672d312e706e67" alt="Clustering" data-canonical-src="https://raw.github.com/eligosource/eventsourced/master/doc/images/clustering-1.png" style="max-width:100%;"></a></p>

<p>Clients interact with the <code>Door</code> singleton via <code>NodeActor</code>s by sending them door commands (<code>"open"</code> or <code>"close"</code>). <code>NodeActor</code>s accept commands on any cluster node, not only on master. A <code>NodeActor</code> forwards these commands to the <code>Door</code> as command <a href="http://eligosource.github.com/eventsourced/api/snapshot/#org.eligosource.eventsourced.core.Message"><code>Message</code></a>s. Event <code>Message</code>s emitted by the <code>Door</code> are sent to a remote <code>Destination</code> actor via the named <code>"destination"</code> channel. The <code>Destination</code> creates a response from the received events and sends that response back to the initial sender. The application that runs the <code>Destination</code> actor is not part of the cluster but a standalone remote application. It also hosts the journal that is used by the cluster nodes (which is a SPOF in this example but later versions will use a distributed journal).</p>

<p>When the master crashes, another node in the cluster becomes the master and recovers the <code>Door</code> state machine. The remaining slave node renews its remote reference to the <code>Door</code> instance on the new master.</p>

<p><a href="https://camo.githubusercontent.com/e49ff4dab16385ff835370a7619cfacb379e0921/68747470733a2f2f7261772e6769746875622e636f6d2f656c69676f736f757263652f6576656e74736f75726365642f6d61737465722f646f632f696d616765732f636c7573746572696e672d322e706e67" target="_blank"><img src="https://camo.githubusercontent.com/e49ff4dab16385ff835370a7619cfacb379e0921/68747470733a2f2f7261772e6769746875622e636f6d2f656c69676f736f757263652f6576656e74736f75726365642f6d61737465722f646f632f696d616765732f636c7573746572696e672d322e706e67" alt="Clustering" data-canonical-src="https://raw.github.com/eligosource/eventsourced/master/doc/images/clustering-2.png" style="max-width:100%;"></a></p>

<p>Code from this section is contained in <a href="https://github.com/eligosource/eventsourced/blob/master/es-examples/src/main/scala/org/eligosource/eventsourced/example/ClusterExample.scala">ClusterExample.scala</a>, the configuration files used are <a href="https://github.com/eligosource/eventsourced/blob/master/es-examples/src/main/resources/journal.conf">journal.conf</a> and <a href="https://github.com/eligosource/eventsourced/blob/master/es-examples/src/main/resources/cluster.conf">cluster.conf</a>. For a more detailed description of the example code, refer to the code comments. To run the distributed example application from sbt, first start the application that hosts the <code>Destination</code> actor and the journal:</p>

<pre><code>&gt; run-main org.eligosource.eventsourced.example.DestinationApp
</code></pre>

<p>Then start the first seed node of the cluster</p>

<pre><code>&gt; run-main org.eligosource.eventsourced.example.NodeApp 2561
</code></pre>

<p>then the second seed node</p>

<pre><code>&gt; run-main org.eligosource.eventsourced.example.NodeApp 2562
</code></pre>

<p>and finally a third cluster node</p>

<pre><code>&gt; run-main org.eligosource.eventsourced.example.NodeApp
</code></pre>

<p>The above commands require that you're in the <code>eventsourced-examples</code> project. You can switch to it via</p>

<pre><code>&gt; project eventsourced-examples
</code></pre>

<p>Most likely the first seed node will become the master which writes</p>

<pre><code>MASTER: recovered door at akka://node@127.0.0.1:2561
</code></pre>

<p>to <code>stdout</code>. The other nodes become slaves that write</p>

<pre><code>SLAVE: referenced door at akka://node@127.0.0.1:2561
</code></pre>

<p>to <code>stdout</code>. All nodes prompt the user to enter a door command:</p>

<pre><code>command (open|close):
</code></pre>

<p>We will now enter commands on the last started cluster node (a slave node).</p>

<p>The <code>Door</code> singleton is initially in closed state. Entering <code>open</code> will open it:</p>

<pre><code>command (open|close): open
moved 1 times: door now open
</code></pre>

<p>Then close it again:</p>

<pre><code>command (open|close): close
moved 2 times: door now closed
</code></pre>

<p>Trying to close a closed door will result in an error:</p>

<pre><code>command (open|close): close
cannot close door: door is closed
</code></pre>

<p>Now kill the master node with <code>ctrl^c</code>. This will also destroy the <code>Door</code> singleton. After 1-2 seconds, a new master has been determined by the cluster. The new master is going to recover the event-sourced <code>Door</code> singleton. The slave will renew its remote reference to the <code>Door</code>. To verify that the <code>Door</code> has been properly recovered, open the door again:</p>

<pre><code>command (open|close): open
moved 3 times: door now open
</code></pre>

<p>You can see that the <code>Door</code> state (which contains the number of past moves) has been properly failed-over.</p>

<h2>
<a name="user-content-miscellaneous" class="anchor" href="#miscellaneous" aria-hidden="true"><span class="octicon octicon-link"></span></a>Miscellaneous</h2>

<h3>
<a name="user-content-multicast-processor" class="anchor" href="#multicast-processor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Multicast processor</h3>

<p><a href="https://camo.githubusercontent.com/71964acb3ca9296229da325ee5941468498bc813/68747470733a2f2f7261772e6769746875622e636f6d2f656c69676f736f757263652f6576656e74736f75726365642f6d61737465722f646f632f696d616765732f6d756c7469636173742d312e706e67" target="_blank"><img src="https://camo.githubusercontent.com/71964acb3ca9296229da325ee5941468498bc813/68747470733a2f2f7261772e6769746875622e636f6d2f656c69676f736f757263652f6576656e74736f75726365642f6d61737465722f646f632f696d616765732f6d756c7469636173742d312e706e67" alt="Multicast" data-canonical-src="https://raw.github.com/eligosource/eventsourced/master/doc/images/multicast-1.png" style="max-width:100%;"></a></p>

<p>The <a href="http://eligosource.github.com/eventsourced/api/snapshot/#org.eligosource.eventsourced.core.Multicast"><code>Multicast</code></a> processor is a predefined <code>Eventsourced</code> processor that forwards received event messages to multiple targets. Using a <code>Multicast</code> processor with n targets is an optimization of having n <code>Eventsourced</code> processors that receive the same event <code>Message</code>s. Using a multicast processor, a received event message is journaled only once whereas with n <code>Eventsourced</code> processors that message would be journaled n times (once for each processor). Using a <code>Multicast</code> processor for a large number of targets can therefore significantly save disk space and increase throughput.</p>

<p>Applications can create a <code>Multicast</code> processor with the <code>multicast</code> factory method which is defined in package <a href="http://eligosource.github.com/eventsourced/api/snapshot/#org.eligosource.eventsourced.core.package"><code>core</code></a>.</p>

<div class="highlight highlight-scala"><pre><span class="c1">// …</span>
<span class="k">import</span> <span class="nn">org.eligosource.eventsourced.core._</span>

<span class="k">val</span> <span class="n">extension</span><span class="k">:</span> <span class="kt">EventsourcingExtension</span> <span class="o">=</span> <span class="err">…</span>

<span class="k">val</span> <span class="n">processorId</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="err">…</span>
<span class="k">val</span> <span class="n">target1</span><span class="k">:</span> <span class="kt">ActorRef</span> <span class="o">=</span> <span class="err">…</span>
<span class="k">val</span> <span class="n">target2</span><span class="k">:</span> <span class="kt">ActorRef</span> <span class="o">=</span> <span class="err">…</span>

<span class="k">val</span> <span class="n">multicast</span> <span class="k">=</span> <span class="n">extension</span><span class="o">.</span><span class="n">processorOf</span><span class="o">(</span><span class="nc">Props</span><span class="o">(</span><span class="n">multicast</span><span class="o">(</span><span class="n">processorId</span><span class="o">,</span> <span class="nc">List</span><span class="o">(</span><span class="n">target1</span><span class="o">,</span> <span class="n">target2</span><span class="o">))))</span>
</pre></div>

<p>This is equivalent to</p>

<div class="highlight highlight-scala"><pre><span class="k">val</span> <span class="n">multicast</span> <span class="k">=</span> <span class="n">extension</span><span class="o">.</span><span class="n">processorOf</span><span class="o">(</span><span class="nc">Props</span><span class="o">(</span><span class="k">new</span> <span class="nc">Multicast</span><span class="o">(</span><span class="nc">List</span><span class="o">(</span><span class="n">target1</span><span class="o">,</span> <span class="n">target2</span><span class="o">),</span> <span class="n">identity</span><span class="o">)</span> <span class="k">with</span> <span class="nc">Eventsourced</span> <span class="o">{</span> <span class="k">val</span> <span class="n">id</span> <span class="k">=</span> <span class="n">processorId</span> <span class="o">}</span> <span class="o">))</span>
</pre></div>

<p>Applications that want to modify received event <code>Message</code>s, before they are forwarded to targets, can specify a <code>transformer</code> function.</p>

<div class="highlight highlight-scala"><pre><span class="k">val</span> <span class="n">transformer</span><span class="k">:</span> <span class="kt">Message</span> <span class="o">=&gt;</span> <span class="nc">Any</span> <span class="k">=</span> <span class="n">msg</span> <span class="k">=&gt;</span> <span class="n">msg</span><span class="o">.</span><span class="n">event</span>
<span class="k">val</span> <span class="n">multicast</span> <span class="k">=</span> <span class="n">extension</span><span class="o">.</span><span class="n">processorOf</span><span class="o">(</span><span class="nc">Props</span><span class="o">(</span><span class="n">multicast</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="nc">List</span><span class="o">(</span><span class="n">target1</span><span class="o">,</span> <span class="n">target2</span><span class="o">),</span> <span class="n">transformer</span><span class="o">)))</span>
</pre></div>

<p>In the above example, the <code>transformer</code> function extracts the <code>event</code> from a received event <code>Message</code>. If the <code>transformer</code> function is not specified, it defaults to the <code>identity</code> function. Another <code>Multicast</code> factory method is the <code>decorator</code> method for creating a multicast processor with a single target.</p>

<h3>
<a name="user-content-retroactive-changes" class="anchor" href="#retroactive-changes" aria-hidden="true"><span class="octicon octicon-link"></span></a>Retroactive changes</h3>

<p>TODO</p>

<h2>
<a name="user-content-appendix-a-legend" class="anchor" href="#appendix-a-legend" aria-hidden="true"><span class="octicon octicon-link"></span></a>Appendix A: Legend</h2>

<p><a href="https://camo.githubusercontent.com/576962b1e0a64da30058fcab6f0189afcfb3917b/68747470733a2f2f7261772e6769746875622e636f6d2f656c69676f736f757263652f6576656e74736f75726365642f6d61737465722f646f632f696d616765732f6c6567656e642e706e67" target="_blank"><img src="https://camo.githubusercontent.com/576962b1e0a64da30058fcab6f0189afcfb3917b/68747470733a2f2f7261772e6769746875622e636f6d2f656c69676f736f757263652f6576656e74736f75726365642f6d61737465722f646f632f696d616765732f6c6567656e642e706e67" alt="Legend" data-canonical-src="https://raw.github.com/eligosource/eventsourced/master/doc/images/legend.png" style="max-width:100%;"></a></p>

<h2>
<a name="user-content-appendix-b-project" class="anchor" href="#appendix-b-project" aria-hidden="true"><span class="octicon octicon-link"></span></a>Appendix B: Project</h2>

<ul class="task-list">
<li><a href="http://eligosource.github.com/eventsourced/api/snapshot/#org.eligosource.eventsourced.core.package">Eventsourced API</a></li>
<li><a href="https://github.com/eligosource/eventsourced-example">Eventsourced reference application</a></li>
<li><a href="https://github.com/eligosource/eventsourced/wiki/Developer-guidelines">Developer guidelines</a></li>
<li><a href="https://github.com/eligosource/eventsourced/wiki/Installation">Installation</a></li>
<li><a href="https://github.com/eligosource/eventsourced/wiki/FAQ">FAQ</a></li>
</ul><h2>
<a name="user-content-appendix-c-articles" class="anchor" href="#appendix-c-articles" aria-hidden="true"><span class="octicon octicon-link"></span></a>Appendix C: Articles</h2>

<ul class="task-list">
<li><a href="http://krasserm.blogspot.com/2013/01/event-sourcing-and-external-service.html">Event sourcing and external service integration</a></li>
</ul><h2>
<a name="user-content-appendix-d-support" class="anchor" href="#appendix-d-support" aria-hidden="true"><span class="octicon octicon-link"></span></a>Appendix D: Support</h2>

<ul class="task-list">
<li><a href="http://groups.google.com/group/eventsourced">Eventsourced user forum</a></li>
<li><a href="http://groups.google.com/group/eventsourced-dev">Eventsourced developer forum</a></li>
<li>Commercial support by <a href="http://www.eligotech.com/">Eligotech B.V.</a>
</li>
</ul></article></div>