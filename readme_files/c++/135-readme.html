<div class="announce instapaper_body markdown" data-path="README.markdown" id="readme"><article class="markdown-body entry-content" itemprop="mainContentOfPage"><h1>
<a name="user-content-ammojs" class="anchor" href="#ammojs" aria-hidden="true"><span class="octicon octicon-link"></span></a>ammo.js</h1>

<p><strong>Demo: <a href="http://kripken.github.com/ammo.js/examples/new/ammo.html">http://kripken.github.com/ammo.js/examples/new/ammo.html</a></strong></p>

<p><strong>Example code to give you an idea of the API: <a href="https://github.com/kripken/ammo.js/blob/master/examples/webgl_demo/ammo.html#L14">https://github.com/kripken/ammo.js/blob/master/examples/webgl_demo/ammo.html#L14</a></strong></p>

<p>ammo.js is a direct port of the <a href="http://bulletphysics.org/">Bullet physics engine</a> to JavaScript, using Emscripten. The source code is translated directly to JavaScript, without human rewriting, so functionality should be identical to the original Bullet.</p>

<p><strong>Note: ammo.js has just been updated to a new porting approach. If you find some part of the Bullet API that is not supported that you need, please see <a href="https://github.com/kripken/ammo.js/issues/60">https://github.com/kripken/ammo.js/issues/60</a></strong></p>

<p>'ammo' stands for "Avoided Making My Own js physics engine by compiling bullet from C++" ;)</p>

<p>ammo.js is zlib licensed, just like Bullet.</p>

<p>Discussion takes place on IRC at #emscripten on Mozilla's server (irc.mozilla.org)</p>

<h2>
<a name="user-content-instructions" class="anchor" href="#instructions" aria-hidden="true"><span class="octicon octicon-link"></span></a>Instructions</h2>

<p><code>builds/ammo.js</code> contains a prebuilt version of ammo.js. This is probably what you want.</p>

<p>You can also build ammo.js yourself, as follows:</p>

<ul class="task-list">
<li>
<p>Get Emscripten</p>

<p><a href="http://emscripten.org">http://emscripten.org</a></p>

<p>and set it up. See</p>

<p><a href="https://github.com/kripken/emscripten/wiki/Getting-started">https://github.com/kripken/emscripten/wiki/Getting-started</a></p>
</li>
<li>
<p>Run the build script,</p>

<p><code>python make.py</code></p>

<p>which should generate builds/ammo.js.</p>
</li>
<li>
<p>Optionally, run the automatic tests,</p>

<p><code>python test.py</code></p>
</li>
</ul><h2>
<a name="user-content-usage" class="anchor" href="#usage" aria-hidden="true"><span class="octicon octicon-link"></span></a>Usage</h2>

<p>The most straightforward thing is if you want to write your code in C++, and
run that on the web. If so, then compile your code into LLVM, link it with
bullet, and compile that to JavaScript using emscripten. (The easiest way to
link it is to add your .bc file to the llvm-link command in make.py.)</p>

<p>If, on the other hand, you want to write code in JavaScript, you can use the
autogenerated binding code. A complete example appears in</p>

<p><code>examples/hello_world.js</code></p>

<p>That is HelloWorld.cpp from Bullet, translated to JavaScript. Other examples
in that directory might be useful as well. In particular see the WebGL
demo code in</p>

<p><code>examples/webgl_demo/ammo.html</code></p>

<h1>
<a name="user-content-bindings-api" class="anchor" href="#bindings-api" aria-hidden="true"><span class="octicon octicon-link"></span></a>Bindings API</h1>

<p>ammo.js autogenerates its API from the Bullet source code, so it should
be basically identical. There are however some differences and things
to be aware of:</p>

<ul class="task-list">
<li><p>See <a href="https://github.com/kripken/emscripten/wiki/WebIDL-Binder">https://github.com/kripken/emscripten/wiki/WebIDL-Binder</a>
for a description of the bindings tool we use here, which includes
instructions for how to use the wrapped objects.</p></li>
<li><p>All ammo.js elements should be accessed through <code>Ammo.*</code>. For example,
<code>Ammo.btVector3</code>, etc., as you can see in the example code.</p></li>
<li>
<p>Member variables of structs and classes can be accessed through
setter and getter functions, that are prefixed with <code>|get_|</code> or <code>|set_|</code>.
For example,</p>

<p><code>rayCallback.get_m_rayToWorld()</code></p>

<p>will get <code>m_rayToWorld</code> from say a <code>ClosestRayResultCallback</code>. Native
JavaScript getters and setters could give a slightly nicer API here,
however their performance is potentially problematic.</p>
</li>
<li><p>Functions returning or getting <code>float&amp;</code> or <code>btScalar&amp;</code> are converted to
float. The reason is that <code>float&amp;</code> is basically <code>float*</code> with nicer syntax
in C++, but from JavaScript you would need to write to the heap every
time you call such a function, making usage very ugly. With this change,
you can do <code>|new btVector3(5, 6, 7)|</code> and it will work as expected. If
you find a case where you need the float&amp; method, please file an issue.</p></li>
<li><p>Not all classes are exposed, as only what is described in ammo.idl is
wrapped. Please submit pull requests with extra stuff that you need
and add.</p></li>
<li>
<p>There is experimental support for binding operator functions. The following
might work:</p>

<table>
<thead><tr>
<th>Operator</th>
<th>Name in JS</th>
</tr></thead>
<tbody>
<tr>
<td><code>=</code></td>
<td><code>op_set</code></td>
</tr>
<tr>
<td><code>+</code></td>
<td><code>op_add</code></td>
</tr>
<tr>
<td><code>-</code></td>
<td><code>op_sub</code></td>
</tr>
<tr>
<td><code>*</code></td>
<td><code>op_mul</code></td>
</tr>
<tr>
<td><code>/</code></td>
<td><code>op_div</code></td>
</tr>
<tr>
<td><code>[]</code></td>
<td><code>op_get</code></td>
</tr>
<tr>
<td><code>==</code></td>
<td><code>op_eq</code></td>
</tr>
</tbody>
</table>
</li>
</ul><h1>
<a name="user-content-troubleshooting" class="anchor" href="#troubleshooting" aria-hidden="true"><span class="octicon octicon-link"></span></a>Troubleshooting</h1>

<ul class="task-list">
<li>
<p>It's easy to forget to write |new| when creating an object, for
example</p>

<p><code>var vec = Ammo.btVector3(1,2,3); // This is wrong! Need 'new'!</code></p>

<p>This can lead to error messages like the following:</p>

<p><code>Cannot read property 'a' of undefined</code>
  <code>Cannot read property 'ptr' of undefined</code></p>

<p>This is an annoying aspect of JavaScript, sadly.</p>
</li>
</ul><h1>
<a name="user-content-reporting-issues" class="anchor" href="#reporting-issues" aria-hidden="true"><span class="octicon octicon-link"></span></a>Reporting Issues</h1>

<p>If you find a bug in ammo.js and file an issue, please include a script
that reproduces the problem. That way it is easier to debug, and we can
then include that script in our automatic tests.</p>

<h1>
<a name="user-content-release-process" class="anchor" href="#release-process" aria-hidden="true"><span class="octicon octicon-link"></span></a>Release Process</h1>

<p>Pushing a new build in <code>builds/ammo.js</code> should be done only after the
following steps:</p>

<ul class="task-list">
<li><p>Build a safe build and make sure it passes all automatic tests. Safe
builds contain a lot of runtime assertions that can catch potential
bugs (similar to the sort of things valgrind can catch).</p></li>
<li><p>Build a fast build and make sure it passes all automatic tests.</p></li>
<li><p>Run closure compiler on that fast build and make sure it passes
all automatic tests.</p></li>
<li><p>Make sure that the stress test benchmark did not regress
compared to the old build.</p></li>
<li><p>Run the WebGL demo in examples/webgl_demo and make sure it looks
ok.</p></li>
</ul><h1>
<a name="user-content-upstream-version" class="anchor" href="#upstream-version" aria-hidden="true"><span class="octicon octicon-link"></span></a>Upstream Version</h1>

<p>Bullet 2.82</p></article></div>