<div class="announce instapaper_body md" data-path="README.md" id="readme"><article class="markdown-body entry-content" itemprop="mainContentOfPage"><h1>
<a name="user-content-shelly" class="anchor" href="#shelly" aria-hidden="true"><span class="octicon octicon-link"></span></a>Shelly</h1>

<p>Shelly provides a single module for convenient systems programming in Haskell.</p>

<ul class="task-list">
<li>is aimed at convenience and getting things done rather than being a demonstration of elegance.</li>
<li>has detailed and useful error messages</li>
<li>maintains its own environment, making it thread-safe</li>
<li>is modern, using Text and system-filepath/system-fileio</li>
<li>has low memory usage

<ul class="task-list">
<li>
<code>run_</code> and other underscore variants that don't return stdout</li>
<li>
<code>runFoldLines</code> to run a fold operation over each line rather than loading all of stdout into memory</li>
<li>
<code>runHandle</code> and <code>runHandles</code> for complete control over handles</li>
</ul>
</li>
</ul><p>Looking to put your Haskell learning to immediate practical use? You don't have to create artifical intelligence, try just automating some of your boring tasks.</p>

<p>The focus of this library on convenience combined with good error messages should make shelly approachable for newer users of Haskell.
I have published <a href="http://www.linux-magazin.de/Online-Artikel/Shell-scripting-with-type-safety-using-Haskell/">an introductory article to scripting with shelly, targeted towards those not familiar with Haskell</a>. There is a paid version in German from Linux Magazin.
That article uses the version <code>shelly &lt; 1.0</code> which uses lazy text. <code>shelly &gt; 1.0</code> uses strict text.</p>

<h2>
<a name="user-content-more-shelly-packages" class="anchor" href="#more-shelly-packages" aria-hidden="true"><span class="octicon octicon-link"></span></a>More shelly packages</h2>

<p>The <a href="http://hackage.haskell.org/package/shelly-extra">shelly-extra</a> package has some additional functionality that requires additional dependencies, currently including a convenient concurrency/futures implementation. If you are following along the above article you need to install it.</p>

<h2>
<a name="user-content-examples" class="anchor" href="#examples" aria-hidden="true"><span class="octicon octicon-link"></span></a>Examples</h2>

<ul class="task-list">
<li><a href="https://github.com/yesodweb/scripts/blob/master/install.hs">Yesod development installer</a></li>
<li><a href="https://github.com/yesodweb/cabal-meta/blob/master/main.hs">cabal-meta, a haskell install tool</a></li>
<li><a href="https://github.com/Tarrasch/antigen-hs">antigen-hs, a zsh plugin manager</a></li>
</ul><h3>
<a name="user-content-blog-posts" class="anchor" href="#blog-posts" aria-hidden="true"><span class="octicon octicon-link"></span></a>Blog Posts</h3>

<ul class="task-list">
<li><a href="http://www.scholarslab.org/dh-developer/shell-programming-in-haskell-converting-s5-slides-to-pdf/">Shelly automation with Literate Haskell</a></li>
</ul><h3>
<a name="user-content-testimonials" class="anchor" href="#testimonials" aria-hidden="true"><span class="octicon octicon-link"></span></a>Testimonials</h3>

<ul class="task-list">
<li><a href="http://www.reddit.com/r/haskell/comments/w86gu/my_current_job_task_is_boring_so_i_wrote_a_simple/">a beginning Haskeller does automation</a></li>
</ul><h3>
<a name="user-content-help" class="anchor" href="#help" aria-hidden="true"><span class="octicon octicon-link"></span></a>Help</h3>

<ul class="task-list">
<li><a href="https://groups.google.com/forum/#!forum/haskell-shell-scripting">google group for Haskell shell scripting</a></li>
</ul><h2>
<a name="user-content-alternatives" class="anchor" href="#alternatives" aria-hidden="true"><span class="octicon octicon-link"></span></a>Alternatives</h2>

<h3>
<a name="user-content-haskell-shell-scripting-libarires" class="anchor" href="#haskell-shell-scripting-libarires" aria-hidden="true"><span class="octicon octicon-link"></span></a>Haskell shell scripting libarires</h3>

<ul class="task-list">
<li>
<a href="http://hackage.haskell.org/package/HSH">HSH</a> - A good alternative if you want to mixup usage of String and ByteString rather than just use Text.</li>
<li>
<a href="http://hackage.haskell.org/packages/archive/hsshellscript/3.1.0/doc/html/HsShellScript.html">HsShellScript</a> - Has extensive low-level shell capabilities.</li>
</ul><p>Both of these libraries (unlike Shelly currently) also implement very efficient mechanisms for piping/redirecting.</p>

<h3>
<a name="user-content-haskell-supplements" class="anchor" href="#haskell-supplements" aria-hidden="true"><span class="octicon octicon-link"></span></a>Haskell supplements</h3>

<ul class="task-list">
<li>
<a href="hackage.haskell.org/package/FileManip">FileManip</a> - more efficient file finding code (uses Lazy IO). Shelly's finders are currently being re-worked</li>
</ul><h3>
<a name="user-content-shell-commands-with-richer-inputoutput" class="anchor" href="#shell-commands-with-richer-inputoutput" aria-hidden="true"><span class="octicon octicon-link"></span></a>Shell commands with richer input/output</h3>

<p>Shelly does not change the nature of shell scripting (text in, text out).
If you want something more revolutionary you might try these:</p>

<ul class="task-list">
<li>
<a href="https://github.com/mzero/plush">Plush</a> shell with nice GUI. Written in Haskell. Actively developed, unlike <a href="https://github.com/unconed/TermKit/">TermKit</a>
</li>
<li>PowerShell is proably the best known.</li>
<li>
<a href="https://github.com/pkamenarsky/ytools">Haskell project</a> using typed JSON</li>
<li><a href="https://github.com/benbernard/RecordStream">untyped JSON</a></li>
</ul><h2>
<a name="user-content-usage" class="anchor" href="#usage" aria-hidden="true"><span class="octicon octicon-link"></span></a>Usage</h2>

<p>Shelly's main goal is ease of use.
There should be a primitive for every shell operation you need so you can easily build abstractions, so there are many of the usual file and environment operations.</p>

<p>There are 2 main entry points for running arbitrary commands: <code>run</code> and <code>cmd</code>.
They take a FilePath as their first argument. <code>run</code> takes a [Text] as its second argument.
<code>cmd</code> takes a variadic number of arguments, and they can be either Text or FilePath.</p>

<p>Fun Example: shows an infectious script: it uploads itself to a server and runs itself over ssh.
Of course, the development machine may need to be exactly the same OS as the server.</p>

<p>I recommend using the boilerplate at the top of this example in your projects.</p>

<div class="highlight highlight-haskell"><pre>    <span class="cm">{-# LANGUAGE OverloadedStrings #-}</span>
    <span class="cm">{-# LANGUAGE ExtendedDefaultRules #-}</span>
    <span class="cm">{-# OPTIONS_GHC -fno-warn-type-defaults #-}</span>
    <span class="kr">import</span> <span class="nn">Shelly</span>
    <span class="kr">import</span> <span class="nn">Data.Text</span> <span class="k">as</span> <span class="n">T</span>
    <span class="kr">default</span> <span class="p">(</span><span class="kt">T</span><span class="o">.</span><span class="kt">Text</span><span class="p">)</span>

    <span class="n">main</span> <span class="ow">=</span> <span class="n">shelly</span> <span class="o">$</span> <span class="n">verbosely</span> <span class="o">$</span> <span class="kr">do</span>
      <span class="n">host</span> <span class="ow">&lt;-</span> <span class="n">run</span> <span class="s">"uname"</span> <span class="p">[</span><span class="s">"-n"</span><span class="p">]</span>
      <span class="kr">if</span> <span class="kt">T</span><span class="o">.</span><span class="n">stripEnd</span> <span class="n">host</span> <span class="o">===</span> <span class="s">"local-machine"</span>
        <span class="kr">then</span> <span class="kr">do</span> <span class="n">d</span> <span class="ow">&lt;-</span> <span class="n">cmd</span> <span class="s">"date"</span>
                <span class="n">c</span> <span class="ow">&lt;-</span> <span class="n">escaping</span> <span class="kt">False</span> <span class="o">$</span> <span class="n">cmd</span> <span class="s">"git"</span> <span class="s">"log -1 | head -1 | awk '{print $2}'"</span>
                <span class="n">appendfile</span> <span class="s">"log/deploy.log"</span> <span class="o">$</span> <span class="kt">T</span><span class="o">.</span><span class="n">intercalate</span> <span class="s">" - "</span> <span class="p">[</span><span class="kt">T</span><span class="o">.</span><span class="n">stripEnd</span> <span class="n">d</span><span class="p">,</span> <span class="n">c</span><span class="p">]</span>
                <span class="n">uploads</span> <span class="p">[</span><span class="s">"deploy"</span><span class="p">]</span>
                <span class="n">shPairs_</span> <span class="s">"my-server"</span> <span class="p">[(</span><span class="s">"./deploy"</span><span class="p">,</span> <span class="kt">[]</span><span class="p">)]</span>
        <span class="kr">else</span> <span class="kr">do</span>
              <span class="n">cmd</span> <span class="s">"./script/angel"</span>

    <span class="c1">-- same path on remote host</span>
    <span class="c1">-- will create directories</span>
    <span class="n">uploads</span> <span class="ow">::</span> <span class="p">[</span><span class="kt">Text</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="kt">Sh</span> <span class="nb">()</span>
    <span class="n">uploads</span> <span class="n">locals</span> <span class="n">login</span> <span class="ow">=</span> <span class="n">rsync</span> <span class="o">$</span> <span class="p">[</span><span class="s">"--relative"</span><span class="p">]</span> <span class="o">++</span> <span class="n">locals</span> <span class="o">++</span> <span class="p">[</span><span class="n">login</span><span class="p">]</span>

    <span class="n">rsync</span> <span class="n">args</span> <span class="ow">=</span> <span class="n">run_</span> <span class="s">"rsync"</span> <span class="o">$</span> <span class="p">[</span><span class="s">"--delete"</span><span class="p">,</span> <span class="s">"-avz"</span><span class="p">,</span> <span class="s">"--no-g"</span><span class="p">]</span> <span class="o">++</span> <span class="n">args</span>
</pre></div>

<h3>
<a name="user-content-variadic-arguments-to-cmd" class="anchor" href="#variadic-arguments-to-cmd" aria-hidden="true"><span class="octicon octicon-link"></span></a>Variadic arguments to cmd</h3>

<p>Yes, as seen above you can write variadic functions in Haskell quite easily, you just can't compose them as easily.
I find <code>cmd</code> to be more convenient, but I often use <code>run</code> and <code>command</code> variants when I am building up abstractions.
Building up abstractions with cmd will require type signatures.</p>

<pre><code>-- easy signature, but only allows one argument
let cabal = cmd "cabal" :: Text -&gt; Sh Text

-- more complex signature that allows partial application of cmd
let cabal = cmd "cabal" :: Shelly.ShellCmd result =&gt; result
</code></pre>

<h3>
<a name="user-content-escaping" class="anchor" href="#escaping" aria-hidden="true"><span class="octicon octicon-link"></span></a>Escaping</h3>

<p>By default, all commands are shell escaped.
If you want the shell to interpret special characters such as <code>*</code>, just use <code>escaping False $ do ...</code> </p>

<h3>
<a name="user-content-using-text-and-filepath-together" class="anchor" href="#using-text-and-filepath-together" aria-hidden="true"><span class="octicon octicon-link"></span></a>Using Text and FilePath together</h3>

<p>Shelly's usage of system-filepath means you may need to convert between Text and FilePath sometimes.
This should be infrequent though because</p>

<ul class="task-list">
<li>
<code>cmd</code> will convert FilePath to Text</li>
<li>The <code>&lt;/&gt;</code> and <code>&lt;.&gt;</code> combinators convert String/Text into a FilePath automatically</li>
</ul><p>Manual conversion is done through <code>toTextIgnore</code> or <code>toTextWarn</code>.</p>

<h3>
<a name="user-content-thread-safe-working-directory-and-relative-paths" class="anchor" href="#thread-safe-working-directory-and-relative-paths" aria-hidden="true"><span class="octicon octicon-link"></span></a>Thread-safe working directory and relative paths</h3>

<p><code>cd</code> does not change the process working directory (essentially a global variable), but instead changes the shelly state (which is thread safe).
All of the Shelly API takes this into account, internally shelly converts all paths to absolute paths. You can turn a relative path into an absolute with <code>absPath</code> or <code>canonic</code> or you can make a path relative to the Shelly working directory with <code>relPath</code>.</p>

<h3>
<a name="user-content-good-error-messages" class="anchor" href="#good-error-messages" aria-hidden="true"><span class="octicon octicon-link"></span></a>Good error messages</h3>

<p>Haskell's #1 weakness for IO code is a lack of stack traces.
Shelly gives you something different: detailed logging.
In most cases this should be more useful than a stack trace.
Shelly keeps a log of API usage and saves it to a .shelly directory on failure.
If you use <code>shellyNoDir</code>, the log will instead be printed to stderr.
This is in addition to the <code>verbosely</code> settings that will print out commands and their output as the program is running.
Shelly's own error messages are detailed and in some cases it will catch Haskell exceptions and re-throw them with better messages.</p>

<p>If you make your own primitive functions that don't use the existing Shelly API, you can create a wrapper in the Sh monad that use <code>trace</code> or <code>tag</code> to log what they are doing.
You can turn tracing off (not generally recommended) by setting <code>tracing False</code>.</p>

<h2>
<a name="user-content-future-plans" class="anchor" href="#future-plans" aria-hidden="true"><span class="octicon octicon-link"></span></a>Future plans</h2>

<ul class="task-list">
<li>improved SSH API</li>
<li>more efficient piping/redirecting (issue #18)</li>
<li>more efficient find functions (issue #23)</li>
</ul></article></div>