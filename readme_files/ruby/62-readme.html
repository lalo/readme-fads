<div class="announce instapaper_body md" data-path="README.md" id="readme"><article class="markdown-body entry-content" itemprop="mainContentOfPage"><h1>
<a name="user-content-state_machine--" class="anchor" href="#state_machine--" aria-hidden="true"><span class="octicon octicon-link"></span></a>state_machine <a href="http://travis-ci.org/pluginaweek/state_machine"><img src="https://camo.githubusercontent.com/eb8c0f38bc83e2335e391fbc13d66ca7619f36a6/68747470733a2f2f7365637572652e7472617669732d63692e6f72672f706c7567696e617765656b2f73746174655f6d616368696e652e706e67" alt="Build Status" title="Build Status" data-canonical-src="https://secure.travis-ci.org/pluginaweek/state_machine.png" style="max-width:100%;"></a> <a href="https://gemnasium.com/pluginaweek/state_machine"><img src="https://camo.githubusercontent.com/4edc930a069b09463bb510fa95b3deb0002a5fc8/68747470733a2f2f67656d6e617369756d2e636f6d2f706c7567696e617765656b2f73746174655f6d616368696e652e706e67" alt="Dependency Status" title="Dependency Status" data-canonical-src="https://gemnasium.com/pluginaweek/state_machine.png" style="max-width:100%;"></a>
</h1>

<p><em>state_machine</em> adds support for creating state machines for attributes on any
Ruby class.</p>

<h2>
<a name="user-content-resources" class="anchor" href="#resources" aria-hidden="true"><span class="octicon octicon-link"></span></a>Resources</h2>

<p>API</p>

<ul class="task-list">
<li><a href="http://rdoc.info/github/pluginaweek/state_machine/master/frames">http://rdoc.info/github/pluginaweek/state_machine/master/frames</a></li>
</ul><p>Bugs</p>

<ul class="task-list">
<li><a href="http://github.com/pluginaweek/state_machine/issues">http://github.com/pluginaweek/state_machine/issues</a></li>
</ul><p>Development</p>

<ul class="task-list">
<li><a href="http://github.com/pluginaweek/state_machine">http://github.com/pluginaweek/state_machine</a></li>
</ul><p>Testing</p>

<ul class="task-list">
<li><a href="http://travis-ci.org/pluginaweek/state_machine">http://travis-ci.org/pluginaweek/state_machine</a></li>
</ul><p>Source</p>

<ul class="task-list">
<li>git://github.com/pluginaweek/state_machine.git</li>
</ul><p>Mailing List</p>

<ul class="task-list">
<li><a href="http://groups.google.com/group/pluginaweek-talk">http://groups.google.com/group/pluginaweek-talk</a></li>
</ul><h2>
<a name="user-content-description" class="anchor" href="#description" aria-hidden="true"><span class="octicon octicon-link"></span></a>Description</h2>

<p>State machines make it dead-simple to manage the behavior of a class.  Too often,
the state of an object is kept by creating multiple boolean attributes and
deciding how to behave based on the values.  This can become cumbersome and
difficult to maintain when the complexity of your class starts to increase.</p>

<p><em>state_machine</em> simplifies this design by introducing the various parts of a real
state machine, including states, events, transitions, and callbacks.  However,
the api is designed to be so simple you don't even need to know what a
state machine is :)</p>

<p>Some brief, high-level features include:</p>

<ul class="task-list">
<li>Defining state machines on any Ruby class</li>
<li>Multiple state machines on a single class</li>
<li>Namespaced state machines</li>
<li>before/after/around/failure transition hooks with explicit transition requirements</li>
<li>Integration with ActiveModel, ActiveRecord, DataMapper, Mongoid, MongoMapper, and Sequel</li>
<li>State predicates</li>
<li>State-driven instance / class behavior</li>
<li>State values of any data type</li>
<li>Dynamically-generated state values</li>
<li>Event parallelization</li>
<li>Attribute-based event transitions</li>
<li>Path analysis</li>
<li>Inheritance</li>
<li>Internationalization</li>
<li>GraphViz visualization creator</li>
<li>YARD integration (Ruby 1.9+ only)</li>
<li>Flexible machine syntax</li>
</ul><p>Examples of the usage patterns for some of the above features are shown below.
You can find much more detailed documentation in the actual API.</p>

<h2>
<a name="user-content-usage" class="anchor" href="#usage" aria-hidden="true"><span class="octicon octicon-link"></span></a>Usage</h2>

<h3>
<a name="user-content-example" class="anchor" href="#example" aria-hidden="true"><span class="octicon octicon-link"></span></a>Example</h3>

<p>Below is an example of many of the features offered by this plugin, including:</p>

<ul class="task-list">
<li>Initial states</li>
<li>Namespaced states</li>
<li>Transition callbacks</li>
<li>Conditional transitions</li>
<li>State-driven instance behavior</li>
<li>Customized state values</li>
<li>Parallel events</li>
<li>Path analysis</li>
</ul><p>Class definition:</p>

<div class="highlight highlight-ruby"><pre><span class="k">class</span> <span class="nc">Vehicle</span>
  <span class="kp">attr_accessor</span> <span class="ss">:seatbelt_on</span><span class="p">,</span> <span class="ss">:time_used</span><span class="p">,</span> <span class="ss">:auto_shop_busy</span>

  <span class="n">state_machine</span> <span class="ss">:state</span><span class="p">,</span> <span class="ss">:initial</span> <span class="o">=&gt;</span> <span class="ss">:parked</span> <span class="k">do</span>
    <span class="n">before_transition</span> <span class="ss">:parked</span> <span class="o">=&gt;</span> <span class="n">any</span> <span class="o">-</span> <span class="ss">:parked</span><span class="p">,</span> <span class="ss">:do</span> <span class="o">=&gt;</span> <span class="ss">:put_on_seatbelt</span>

    <span class="n">after_transition</span> <span class="ss">:on</span> <span class="o">=&gt;</span> <span class="ss">:crash</span><span class="p">,</span> <span class="ss">:do</span> <span class="o">=&gt;</span> <span class="ss">:tow</span>
    <span class="n">after_transition</span> <span class="ss">:on</span> <span class="o">=&gt;</span> <span class="ss">:repair</span><span class="p">,</span> <span class="ss">:do</span> <span class="o">=&gt;</span> <span class="ss">:fix</span>
    <span class="n">after_transition</span> <span class="n">any</span> <span class="o">=&gt;</span> <span class="ss">:parked</span> <span class="k">do</span> <span class="o">|</span><span class="n">vehicle</span><span class="p">,</span> <span class="n">transition</span><span class="o">|</span>
      <span class="n">vehicle</span><span class="o">.</span><span class="n">seatbelt_on</span> <span class="o">=</span> <span class="kp">false</span>
    <span class="k">end</span>

    <span class="n">after_failure</span> <span class="ss">:on</span> <span class="o">=&gt;</span> <span class="ss">:ignite</span><span class="p">,</span> <span class="ss">:do</span> <span class="o">=&gt;</span> <span class="ss">:log_start_failure</span>

    <span class="n">around_transition</span> <span class="k">do</span> <span class="o">|</span><span class="n">vehicle</span><span class="p">,</span> <span class="n">transition</span><span class="p">,</span> <span class="n">block</span><span class="o">|</span>
      <span class="n">start</span> <span class="o">=</span> <span class="no">Time</span><span class="o">.</span><span class="n">now</span>
      <span class="n">block</span><span class="o">.</span><span class="n">call</span>
      <span class="n">vehicle</span><span class="o">.</span><span class="n">time_used</span> <span class="o">+=</span> <span class="no">Time</span><span class="o">.</span><span class="n">now</span> <span class="o">-</span> <span class="n">start</span>
    <span class="k">end</span>

    <span class="n">event</span> <span class="ss">:park</span> <span class="k">do</span>
      <span class="n">transition</span> <span class="o">[</span><span class="ss">:idling</span><span class="p">,</span> <span class="ss">:first_gear</span><span class="o">]</span> <span class="o">=&gt;</span> <span class="ss">:parked</span>
    <span class="k">end</span>

    <span class="n">event</span> <span class="ss">:ignite</span> <span class="k">do</span>
      <span class="n">transition</span> <span class="ss">:stalled</span> <span class="o">=&gt;</span> <span class="n">same</span><span class="p">,</span> <span class="ss">:parked</span> <span class="o">=&gt;</span> <span class="ss">:idling</span>
    <span class="k">end</span>

    <span class="n">event</span> <span class="ss">:idle</span> <span class="k">do</span>
      <span class="n">transition</span> <span class="ss">:first_gear</span> <span class="o">=&gt;</span> <span class="ss">:idling</span>
    <span class="k">end</span>

    <span class="n">event</span> <span class="ss">:shift_up</span> <span class="k">do</span>
      <span class="n">transition</span> <span class="ss">:idling</span> <span class="o">=&gt;</span> <span class="ss">:first_gear</span><span class="p">,</span> <span class="ss">:first_gear</span> <span class="o">=&gt;</span> <span class="ss">:second_gear</span><span class="p">,</span> <span class="ss">:second_gear</span> <span class="o">=&gt;</span> <span class="ss">:third_gear</span>
    <span class="k">end</span>

    <span class="n">event</span> <span class="ss">:shift_down</span> <span class="k">do</span>
      <span class="n">transition</span> <span class="ss">:third_gear</span> <span class="o">=&gt;</span> <span class="ss">:second_gear</span><span class="p">,</span> <span class="ss">:second_gear</span> <span class="o">=&gt;</span> <span class="ss">:first_gear</span>
    <span class="k">end</span>

    <span class="n">event</span> <span class="ss">:crash</span> <span class="k">do</span>
      <span class="n">transition</span> <span class="n">all</span> <span class="o">-</span> <span class="o">[</span><span class="ss">:parked</span><span class="p">,</span> <span class="ss">:stalled</span><span class="o">]</span> <span class="o">=&gt;</span> <span class="ss">:stalled</span><span class="p">,</span> <span class="ss">:if</span> <span class="o">=&gt;</span> <span class="nb">lambda</span> <span class="p">{</span><span class="o">|</span><span class="n">vehicle</span><span class="o">|</span> <span class="o">!</span><span class="n">vehicle</span><span class="o">.</span><span class="n">passed_inspection?</span><span class="p">}</span>
    <span class="k">end</span>

    <span class="n">event</span> <span class="ss">:repair</span> <span class="k">do</span>
      <span class="c1"># The first transition that matches the state and passes its conditions</span>
      <span class="c1"># will be used</span>
      <span class="n">transition</span> <span class="ss">:stalled</span> <span class="o">=&gt;</span> <span class="ss">:parked</span><span class="p">,</span> <span class="ss">:unless</span> <span class="o">=&gt;</span> <span class="ss">:auto_shop_busy</span>
      <span class="n">transition</span> <span class="ss">:stalled</span> <span class="o">=&gt;</span> <span class="n">same</span>
    <span class="k">end</span>

    <span class="n">state</span> <span class="ss">:parked</span> <span class="k">do</span>
      <span class="k">def</span> <span class="nf">speed</span>
        <span class="mi">0</span>
      <span class="k">end</span>
    <span class="k">end</span>

    <span class="n">state</span> <span class="ss">:idling</span><span class="p">,</span> <span class="ss">:first_gear</span> <span class="k">do</span>
      <span class="k">def</span> <span class="nf">speed</span>
        <span class="mi">10</span>
      <span class="k">end</span>
    <span class="k">end</span>

    <span class="n">state</span> <span class="n">all</span> <span class="o">-</span> <span class="o">[</span><span class="ss">:parked</span><span class="p">,</span> <span class="ss">:stalled</span><span class="p">,</span> <span class="ss">:idling</span><span class="o">]</span> <span class="k">do</span>
      <span class="k">def</span> <span class="nf">moving?</span>
        <span class="kp">true</span>
      <span class="k">end</span>
    <span class="k">end</span>

    <span class="n">state</span> <span class="ss">:parked</span><span class="p">,</span> <span class="ss">:stalled</span><span class="p">,</span> <span class="ss">:idling</span> <span class="k">do</span>
      <span class="k">def</span> <span class="nf">moving?</span>
        <span class="kp">false</span>
      <span class="k">end</span>
    <span class="k">end</span>
  <span class="k">end</span>

  <span class="n">state_machine</span> <span class="ss">:alarm_state</span><span class="p">,</span> <span class="ss">:initial</span> <span class="o">=&gt;</span> <span class="ss">:active</span><span class="p">,</span> <span class="ss">:namespace</span> <span class="o">=&gt;</span> <span class="s1">'alarm'</span> <span class="k">do</span>
    <span class="n">event</span> <span class="ss">:enable</span> <span class="k">do</span>
      <span class="n">transition</span> <span class="n">all</span> <span class="o">=&gt;</span> <span class="ss">:active</span>
    <span class="k">end</span>

    <span class="n">event</span> <span class="ss">:disable</span> <span class="k">do</span>
      <span class="n">transition</span> <span class="n">all</span> <span class="o">=&gt;</span> <span class="ss">:off</span>
    <span class="k">end</span>

    <span class="n">state</span> <span class="ss">:active</span><span class="p">,</span> <span class="ss">:value</span> <span class="o">=&gt;</span> <span class="mi">1</span>
    <span class="n">state</span> <span class="ss">:off</span><span class="p">,</span> <span class="ss">:value</span> <span class="o">=&gt;</span> <span class="mi">0</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">initialize</span>
    <span class="vi">@seatbelt_on</span> <span class="o">=</span> <span class="kp">false</span>
    <span class="vi">@time_used</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="vi">@auto_shop_busy</span> <span class="o">=</span> <span class="kp">true</span>
    <span class="k">super</span><span class="p">()</span> <span class="c1"># NOTE: This *must* be called, otherwise states won't get initialized</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">put_on_seatbelt</span>
    <span class="vi">@seatbelt_on</span> <span class="o">=</span> <span class="kp">true</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">passed_inspection?</span>
    <span class="kp">false</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">tow</span>
    <span class="c1"># tow the vehicle</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">fix</span>
    <span class="c1"># get the vehicle fixed by a mechanic</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">log_start_failure</span>
    <span class="c1"># log a failed attempt to start the vehicle</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre></div>

<p><strong>Note</strong> the comment made on the <code>initialize</code> method in the class.  In order for
state machine attributes to be properly initialized, <code>super()</code> must be called.
See <code>StateMachine::MacroMethods</code> for more information about this.</p>

<p>Using the above class as an example, you can interact with the state machine
like so:</p>

<div class="highlight highlight-ruby"><pre><span class="n">vehicle</span> <span class="o">=</span> <span class="no">Vehicle</span><span class="o">.</span><span class="n">new</span>           <span class="c1"># =&gt; #&lt;Vehicle:0xb7cf4eac @state="parked", @seatbelt_on=false&gt;</span>
<span class="n">vehicle</span><span class="o">.</span><span class="n">state</span>                   <span class="c1"># =&gt; "parked"</span>
<span class="n">vehicle</span><span class="o">.</span><span class="n">state_name</span>              <span class="c1"># =&gt; :parked</span>
<span class="n">vehicle</span><span class="o">.</span><span class="n">human_state_name</span>        <span class="c1"># =&gt; "parked"</span>
<span class="n">vehicle</span><span class="o">.</span><span class="n">parked?</span>                 <span class="c1"># =&gt; true</span>
<span class="n">vehicle</span><span class="o">.</span><span class="n">can_ignite?</span>             <span class="c1"># =&gt; true</span>
<span class="n">vehicle</span><span class="o">.</span><span class="n">ignite_transition</span>       <span class="c1"># =&gt; #&lt;StateMachine::Transition attribute=:state event=:ignite from="parked" from_name=:parked to="idling" to_name=:idling&gt;</span>
<span class="n">vehicle</span><span class="o">.</span><span class="n">state_events</span>            <span class="c1"># =&gt; [:ignite]</span>
<span class="n">vehicle</span><span class="o">.</span><span class="n">state_transitions</span>       <span class="c1"># =&gt; [#&lt;StateMachine::Transition attribute=:state event=:ignite from="parked" from_name=:parked to="idling" to_name=:idling&gt;]</span>
<span class="n">vehicle</span><span class="o">.</span><span class="n">speed</span>                   <span class="c1"># =&gt; 0</span>
<span class="n">vehicle</span><span class="o">.</span><span class="n">moving?</span>                 <span class="c1"># =&gt; false</span>

<span class="n">vehicle</span><span class="o">.</span><span class="n">ignite</span>                  <span class="c1"># =&gt; true</span>
<span class="n">vehicle</span><span class="o">.</span><span class="n">parked?</span>                 <span class="c1"># =&gt; false</span>
<span class="n">vehicle</span><span class="o">.</span><span class="n">idling?</span>                 <span class="c1"># =&gt; true</span>
<span class="n">vehicle</span><span class="o">.</span><span class="n">speed</span>                   <span class="c1"># =&gt; 10</span>
<span class="n">vehicle</span>                         <span class="c1"># =&gt; #&lt;Vehicle:0xb7cf4eac @state="idling", @seatbelt_on=true&gt;</span>

<span class="n">vehicle</span><span class="o">.</span><span class="n">shift_up</span>                <span class="c1"># =&gt; true</span>
<span class="n">vehicle</span><span class="o">.</span><span class="n">speed</span>                   <span class="c1"># =&gt; 10</span>
<span class="n">vehicle</span><span class="o">.</span><span class="n">moving?</span>                 <span class="c1"># =&gt; true</span>
<span class="n">vehicle</span>                         <span class="c1"># =&gt; #&lt;Vehicle:0xb7cf4eac @state="first_gear", @seatbelt_on=true&gt;</span>

<span class="c1"># A generic event helper is available to fire without going through the event's instance method</span>
<span class="n">vehicle</span><span class="o">.</span><span class="n">fire_state_event</span><span class="p">(</span><span class="ss">:shift_up</span><span class="p">)</span> <span class="c1"># =&gt; true</span>

<span class="c1"># Call state-driven behavior that's undefined for the state raises a NoMethodError</span>
<span class="n">vehicle</span><span class="o">.</span><span class="n">speed</span>                   <span class="c1"># =&gt; NoMethodError: super: no superclass method `speed' for #&lt;Vehicle:0xb7cf4eac&gt;</span>
<span class="n">vehicle</span>                         <span class="c1"># =&gt; #&lt;Vehicle:0xb7cf4eac @state="second_gear", @seatbelt_on=true&gt;</span>

<span class="c1"># The bang (!) operator can raise exceptions if the event fails</span>
<span class="n">vehicle</span><span class="o">.</span><span class="n">park!</span>                   <span class="c1"># =&gt; StateMachine::InvalidTransition: Cannot transition state via :park from :second_gear</span>

<span class="c1"># Generic state predicates can raise exceptions if the value does not exist</span>
<span class="n">vehicle</span><span class="o">.</span><span class="n">state?</span><span class="p">(</span><span class="ss">:parked</span><span class="p">)</span>         <span class="c1"># =&gt; false</span>
<span class="n">vehicle</span><span class="o">.</span><span class="n">state?</span><span class="p">(</span><span class="ss">:invalid</span><span class="p">)</span>        <span class="c1"># =&gt; IndexError: :invalid is an invalid name</span>

<span class="c1"># Namespaced machines have uniquely-generated methods</span>
<span class="n">vehicle</span><span class="o">.</span><span class="n">alarm_state</span>             <span class="c1"># =&gt; 1</span>
<span class="n">vehicle</span><span class="o">.</span><span class="n">alarm_state_name</span>        <span class="c1"># =&gt; :active</span>

<span class="n">vehicle</span><span class="o">.</span><span class="n">can_disable_alarm?</span>      <span class="c1"># =&gt; true</span>
<span class="n">vehicle</span><span class="o">.</span><span class="n">disable_alarm</span>           <span class="c1"># =&gt; true</span>
<span class="n">vehicle</span><span class="o">.</span><span class="n">alarm_state</span>             <span class="c1"># =&gt; 0</span>
<span class="n">vehicle</span><span class="o">.</span><span class="n">alarm_state_name</span>        <span class="c1"># =&gt; :off</span>
<span class="n">vehicle</span><span class="o">.</span><span class="n">can_enable_alarm?</span>       <span class="c1"># =&gt; true</span>

<span class="n">vehicle</span><span class="o">.</span><span class="n">alarm_off?</span>              <span class="c1"># =&gt; true</span>
<span class="n">vehicle</span><span class="o">.</span><span class="n">alarm_active?</span>           <span class="c1"># =&gt; false</span>

<span class="c1"># Events can be fired in parallel</span>
<span class="n">vehicle</span><span class="o">.</span><span class="n">fire_events</span><span class="p">(</span><span class="ss">:shift_down</span><span class="p">,</span> <span class="ss">:enable_alarm</span><span class="p">)</span> <span class="c1"># =&gt; true</span>
<span class="n">vehicle</span><span class="o">.</span><span class="n">state_name</span>                              <span class="c1"># =&gt; :first_gear</span>
<span class="n">vehicle</span><span class="o">.</span><span class="n">alarm_state_name</span>                        <span class="c1"># =&gt; :active</span>

<span class="n">vehicle</span><span class="o">.</span><span class="n">fire_events!</span><span class="p">(</span><span class="ss">:ignite</span><span class="p">,</span> <span class="ss">:enable_alarm</span><span class="p">)</span>    <span class="c1"># =&gt; StateMachine::InvalidTransition: Cannot run events in parallel: ignite, enable_alarm</span>

<span class="c1"># Human-friendly names can be accessed for states/events</span>
<span class="no">Vehicle</span><span class="o">.</span><span class="n">human_state_name</span><span class="p">(</span><span class="ss">:first_gear</span><span class="p">)</span>               <span class="c1"># =&gt; "first gear"</span>
<span class="no">Vehicle</span><span class="o">.</span><span class="n">human_alarm_state_name</span><span class="p">(</span><span class="ss">:active</span><span class="p">)</span>             <span class="c1"># =&gt; "active"</span>

<span class="no">Vehicle</span><span class="o">.</span><span class="n">human_state_event_name</span><span class="p">(</span><span class="ss">:shift_down</span><span class="p">)</span>         <span class="c1"># =&gt; "shift down"</span>
<span class="no">Vehicle</span><span class="o">.</span><span class="n">human_alarm_state_event_name</span><span class="p">(</span><span class="ss">:enable</span><span class="p">)</span>       <span class="c1"># =&gt; "enable"</span>

<span class="c1"># States / events can also be references by the string version of their name</span>
<span class="no">Vehicle</span><span class="o">.</span><span class="n">human_state_name</span><span class="p">(</span><span class="s1">'first_gear'</span><span class="p">)</span>              <span class="c1"># =&gt; "first gear"</span>
<span class="no">Vehicle</span><span class="o">.</span><span class="n">human_state_event_name</span><span class="p">(</span><span class="s1">'shift_down'</span><span class="p">)</span>        <span class="c1"># =&gt; "shift down"</span>

<span class="c1"># Available transition paths can be analyzed for an object</span>
<span class="n">vehicle</span><span class="o">.</span><span class="n">state_paths</span>                                       <span class="c1"># =&gt; [[#&lt;StateMachine::Transition ...], [#&lt;StateMachine::Transition ...], ...]</span>
<span class="n">vehicle</span><span class="o">.</span><span class="n">state_paths</span><span class="o">.</span><span class="n">to_states</span>                             <span class="c1"># =&gt; [:parked, :idling, :first_gear, :stalled, :second_gear, :third_gear]</span>
<span class="n">vehicle</span><span class="o">.</span><span class="n">state_paths</span><span class="o">.</span><span class="n">events</span>                                <span class="c1"># =&gt; [:park, :ignite, :shift_up, :idle, :crash, :repair, :shift_down]</span>

<span class="c1"># Find all paths that start and end on certain states</span>
<span class="n">vehicle</span><span class="o">.</span><span class="n">state_paths</span><span class="p">(</span><span class="ss">:from</span> <span class="o">=&gt;</span> <span class="ss">:parked</span><span class="p">,</span> <span class="ss">:to</span> <span class="o">=&gt;</span> <span class="ss">:first_gear</span><span class="p">)</span> <span class="c1"># =&gt; [[</span>
                                                          <span class="c1">#       #&lt;StateMachine::Transition attribute=:state event=:ignite from="parked" ...&gt;,</span>
                                                          <span class="c1">#       #&lt;StateMachine::Transition attribute=:state event=:shift_up from="idling" ...&gt;</span>
                                                          <span class="c1">#    ]]</span>
<span class="c1"># Skipping state_machine and writing to attributes directly</span>
<span class="n">vehicle</span><span class="o">.</span><span class="n">state</span> <span class="o">=</span> <span class="s2">"parked"</span>
<span class="n">vehicle</span><span class="o">.</span><span class="n">state</span>                   <span class="c1"># =&gt; "parked"</span>
<span class="n">vehicle</span><span class="o">.</span><span class="n">state_name</span>              <span class="c1"># =&gt; :parked</span>

<span class="c1"># *Note* that the following is not supported (see StateMachine::MacroMethods#state_machine):</span>
<span class="c1"># vehicle.state = :parked</span>
</pre></div>

<h2>
<a name="user-content-integrations" class="anchor" href="#integrations" aria-hidden="true"><span class="octicon octicon-link"></span></a>Integrations</h2>

<p>In addition to being able to define state machines on all Ruby classes, a set of
out-of-the-box integrations are available for some of the more popular Ruby
libraries.  These integrations add library-specific behavior, allowing for state
machines to work more tightly with the conventions defined by those libraries.</p>

<p>The integrations currently available include:</p>

<ul class="task-list">
<li>ActiveModel classes</li>
<li>ActiveRecord models</li>
<li>DataMapper resources</li>
<li>Mongoid models</li>
<li>MongoMapper models</li>
<li>Sequel models</li>
</ul><p>A brief overview of these integrations is described below.</p>

<h3>
<a name="user-content-activemodel" class="anchor" href="#activemodel" aria-hidden="true"><span class="octicon octicon-link"></span></a>ActiveModel</h3>

<p>The ActiveModel integration is useful for both standalone usage and for providing
the base implementation for ORMs which implement the ActiveModel API.  This
integration adds support for validation errors, dirty attribute tracking, and
observers.  For example,</p>

<div class="highlight highlight-ruby"><pre><span class="k">class</span> <span class="nc">Vehicle</span>
  <span class="kp">include</span> <span class="no">ActiveModel</span><span class="o">::</span><span class="no">Dirty</span>
  <span class="kp">include</span> <span class="no">ActiveModel</span><span class="o">::</span><span class="no">Validations</span>
  <span class="kp">include</span> <span class="no">ActiveModel</span><span class="o">::</span><span class="no">Observing</span>

  <span class="kp">attr_accessor</span> <span class="ss">:state</span>
  <span class="n">define_attribute_methods</span> <span class="o">[</span><span class="ss">:state</span><span class="o">]</span>

  <span class="n">state_machine</span> <span class="ss">:initial</span> <span class="o">=&gt;</span> <span class="ss">:parked</span> <span class="k">do</span>
    <span class="n">before_transition</span> <span class="ss">:parked</span> <span class="o">=&gt;</span> <span class="n">any</span> <span class="o">-</span> <span class="ss">:parked</span><span class="p">,</span> <span class="ss">:do</span> <span class="o">=&gt;</span> <span class="ss">:put_on_seatbelt</span>
    <span class="n">after_transition</span> <span class="n">any</span> <span class="o">=&gt;</span> <span class="ss">:parked</span> <span class="k">do</span> <span class="o">|</span><span class="n">vehicle</span><span class="p">,</span> <span class="n">transition</span><span class="o">|</span>
      <span class="n">vehicle</span><span class="o">.</span><span class="n">seatbelt</span> <span class="o">=</span> <span class="s1">'off'</span>
    <span class="k">end</span>
    <span class="n">around_transition</span> <span class="ss">:benchmark</span>

    <span class="n">event</span> <span class="ss">:ignite</span> <span class="k">do</span>
      <span class="n">transition</span> <span class="ss">:parked</span> <span class="o">=&gt;</span> <span class="ss">:idling</span>
    <span class="k">end</span>

    <span class="n">state</span> <span class="ss">:first_gear</span><span class="p">,</span> <span class="ss">:second_gear</span> <span class="k">do</span>
      <span class="n">validates_presence_of</span> <span class="ss">:seatbelt_on</span>
    <span class="k">end</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">put_on_seatbelt</span>
    <span class="o">.</span><span class="n">.</span><span class="o">.</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">benchmark</span>
    <span class="o">.</span><span class="n">.</span><span class="o">.</span>
    <span class="k">yield</span>
    <span class="o">.</span><span class="n">.</span><span class="o">.</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="k">class</span> <span class="nc">VehicleObserver</span> <span class="o">&lt;</span> <span class="no">ActiveModel</span><span class="o">::</span><span class="no">Observer</span>
  <span class="c1"># Callback for :ignite event *before* the transition is performed</span>
  <span class="k">def</span> <span class="nf">before_ignite</span><span class="p">(</span><span class="n">vehicle</span><span class="p">,</span> <span class="n">transition</span><span class="p">)</span>
    <span class="c1"># log message</span>
  <span class="k">end</span>

  <span class="c1"># Generic transition callback *after* the transition is performed</span>
  <span class="k">def</span> <span class="nf">after_transition</span><span class="p">(</span><span class="n">vehicle</span><span class="p">,</span> <span class="n">transition</span><span class="p">)</span>
    <span class="no">Audit</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">vehicle</span><span class="p">,</span> <span class="n">transition</span><span class="p">)</span>
  <span class="k">end</span>

  <span class="c1"># Generic callback after the transition fails to perform</span>
  <span class="k">def</span> <span class="nf">after_failure_to_transition</span><span class="p">(</span><span class="n">vehicle</span><span class="p">,</span> <span class="n">transition</span><span class="p">)</span>
    <span class="no">Audit</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="n">vehicle</span><span class="p">,</span> <span class="n">transition</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre></div>

<p>For more information about the various behaviors added for ActiveModel state
machines and how to build new integrations that use ActiveModel, see
<code>StateMachine::Integrations::ActiveModel</code>.</p>

<h3>
<a name="user-content-activerecord" class="anchor" href="#activerecord" aria-hidden="true"><span class="octicon octicon-link"></span></a>ActiveRecord</h3>

<p>The ActiveRecord integration adds support for database transactions, automatically
saving the record, named scopes, validation errors, and observers.  For example,</p>

<div class="highlight highlight-ruby"><pre><span class="k">class</span> <span class="nc">Vehicle</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
  <span class="n">state_machine</span> <span class="ss">:initial</span> <span class="o">=&gt;</span> <span class="ss">:parked</span> <span class="k">do</span>
    <span class="n">before_transition</span> <span class="ss">:parked</span> <span class="o">=&gt;</span> <span class="n">any</span> <span class="o">-</span> <span class="ss">:parked</span><span class="p">,</span> <span class="ss">:do</span> <span class="o">=&gt;</span> <span class="ss">:put_on_seatbelt</span>
    <span class="n">after_transition</span> <span class="n">any</span> <span class="o">=&gt;</span> <span class="ss">:parked</span> <span class="k">do</span> <span class="o">|</span><span class="n">vehicle</span><span class="p">,</span> <span class="n">transition</span><span class="o">|</span>
      <span class="n">vehicle</span><span class="o">.</span><span class="n">seatbelt</span> <span class="o">=</span> <span class="s1">'off'</span>
    <span class="k">end</span>
    <span class="n">around_transition</span> <span class="ss">:benchmark</span>

    <span class="n">event</span> <span class="ss">:ignite</span> <span class="k">do</span>
      <span class="n">transition</span> <span class="ss">:parked</span> <span class="o">=&gt;</span> <span class="ss">:idling</span>
    <span class="k">end</span>

    <span class="n">state</span> <span class="ss">:first_gear</span><span class="p">,</span> <span class="ss">:second_gear</span> <span class="k">do</span>
      <span class="n">validates_presence_of</span> <span class="ss">:seatbelt_on</span>
    <span class="k">end</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">put_on_seatbelt</span>
    <span class="o">.</span><span class="n">.</span><span class="o">.</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">benchmark</span>
    <span class="o">.</span><span class="n">.</span><span class="o">.</span>
    <span class="k">yield</span>
    <span class="o">.</span><span class="n">.</span><span class="o">.</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="k">class</span> <span class="nc">VehicleObserver</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Observer</span>
  <span class="c1"># Callback for :ignite event *before* the transition is performed</span>
  <span class="k">def</span> <span class="nf">before_ignite</span><span class="p">(</span><span class="n">vehicle</span><span class="p">,</span> <span class="n">transition</span><span class="p">)</span>
    <span class="c1"># log message</span>
  <span class="k">end</span>

  <span class="c1"># Generic transition callback *after* the transition is performed</span>
  <span class="k">def</span> <span class="nf">after_transition</span><span class="p">(</span><span class="n">vehicle</span><span class="p">,</span> <span class="n">transition</span><span class="p">)</span>
    <span class="no">Audit</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">vehicle</span><span class="p">,</span> <span class="n">transition</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre></div>

<p>For more information about the various behaviors added for ActiveRecord state
machines, see <code>StateMachine::Integrations::ActiveRecord</code>.</p>

<h3>
<a name="user-content-datamapper" class="anchor" href="#datamapper" aria-hidden="true"><span class="octicon octicon-link"></span></a>DataMapper</h3>

<p>Like the ActiveRecord integration, the DataMapper integration adds support for
database transactions, automatically saving the record, named scopes, Extlib-like
callbacks, validation errors, and observers.  For example,</p>

<div class="highlight highlight-ruby"><pre><span class="k">class</span> <span class="nc">Vehicle</span>
  <span class="kp">include</span> <span class="no">DataMapper</span><span class="o">::</span><span class="no">Resource</span>

  <span class="n">property</span> <span class="ss">:id</span><span class="p">,</span> <span class="no">Serial</span>
  <span class="n">property</span> <span class="ss">:state</span><span class="p">,</span> <span class="nb">String</span>

  <span class="n">state_machine</span> <span class="ss">:initial</span> <span class="o">=&gt;</span> <span class="ss">:parked</span> <span class="k">do</span>
    <span class="n">before_transition</span> <span class="ss">:parked</span> <span class="o">=&gt;</span> <span class="n">any</span> <span class="o">-</span> <span class="ss">:parked</span><span class="p">,</span> <span class="ss">:do</span> <span class="o">=&gt;</span> <span class="ss">:put_on_seatbelt</span>
    <span class="n">after_transition</span> <span class="n">any</span> <span class="o">=&gt;</span> <span class="ss">:parked</span> <span class="k">do</span> <span class="o">|</span><span class="n">transition</span><span class="o">|</span>
      <span class="nb">self</span><span class="o">.</span><span class="n">seatbelt</span> <span class="o">=</span> <span class="s1">'off'</span> <span class="c1"># self is the record</span>
    <span class="k">end</span>
    <span class="n">around_transition</span> <span class="ss">:benchmark</span>

    <span class="n">event</span> <span class="ss">:ignite</span> <span class="k">do</span>
      <span class="n">transition</span> <span class="ss">:parked</span> <span class="o">=&gt;</span> <span class="ss">:idling</span>
    <span class="k">end</span>

    <span class="n">state</span> <span class="ss">:first_gear</span><span class="p">,</span> <span class="ss">:second_gear</span> <span class="k">do</span>
      <span class="n">validates_presence_of</span> <span class="ss">:seatbelt_on</span>
    <span class="k">end</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">put_on_seatbelt</span>
    <span class="o">.</span><span class="n">.</span><span class="o">.</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">benchmark</span>
    <span class="o">.</span><span class="n">.</span><span class="o">.</span>
    <span class="k">yield</span>
    <span class="o">.</span><span class="n">.</span><span class="o">.</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="k">class</span> <span class="nc">VehicleObserver</span>
  <span class="kp">include</span> <span class="no">DataMapper</span><span class="o">::</span><span class="no">Observer</span>

  <span class="n">observe</span> <span class="no">Vehicle</span>

  <span class="c1"># Callback for :ignite event *before* the transition is performed</span>
  <span class="n">before_transition</span> <span class="ss">:on</span> <span class="o">=&gt;</span> <span class="ss">:ignite</span> <span class="k">do</span> <span class="o">|</span><span class="n">transition</span><span class="o">|</span>
    <span class="c1"># log message (self is the record)</span>
  <span class="k">end</span>

  <span class="c1"># Generic transition callback *after* the transition is performed</span>
  <span class="n">after_transition</span> <span class="k">do</span> <span class="o">|</span><span class="n">transition</span><span class="o">|</span>
    <span class="no">Audit</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="nb">self</span><span class="p">,</span> <span class="n">transition</span><span class="p">)</span> <span class="c1"># self is the record</span>
  <span class="k">end</span>

  <span class="n">around_transition</span> <span class="k">do</span> <span class="o">|</span><span class="n">transition</span><span class="p">,</span> <span class="n">block</span><span class="o">|</span>
    <span class="c1"># mark start time</span>
    <span class="n">block</span><span class="o">.</span><span class="n">call</span>
    <span class="c1"># mark stop time</span>
  <span class="k">end</span>

  <span class="c1"># Generic callback after the transition fails to perform</span>
  <span class="n">after_transition_failure</span> <span class="k">do</span> <span class="o">|</span><span class="n">transition</span><span class="o">|</span>
    <span class="no">Audit</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="nb">self</span><span class="p">,</span> <span class="n">transition</span><span class="p">)</span> <span class="c1"># self is the record</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre></div>

<p><strong>Note</strong> that the DataMapper::Observer integration is optional and only available
when the dm-observer library is installed.</p>

<p>For more information about the various behaviors added for DataMapper state
machines, see <code>StateMachine::Integrations::DataMapper</code>.</p>

<h3>
<a name="user-content-mongoid" class="anchor" href="#mongoid" aria-hidden="true"><span class="octicon octicon-link"></span></a>Mongoid</h3>

<p>The Mongoid integration adds support for automatically saving the record,
basic scopes, validation errors, and observers.  For example,</p>

<div class="highlight highlight-ruby"><pre><span class="k">class</span> <span class="nc">Vehicle</span>
  <span class="kp">include</span> <span class="no">Mongoid</span><span class="o">::</span><span class="no">Document</span>

  <span class="n">state_machine</span> <span class="ss">:initial</span> <span class="o">=&gt;</span> <span class="ss">:parked</span> <span class="k">do</span>
    <span class="n">before_transition</span> <span class="ss">:parked</span> <span class="o">=&gt;</span> <span class="n">any</span> <span class="o">-</span> <span class="ss">:parked</span><span class="p">,</span> <span class="ss">:do</span> <span class="o">=&gt;</span> <span class="ss">:put_on_seatbelt</span>
    <span class="n">after_transition</span> <span class="n">any</span> <span class="o">=&gt;</span> <span class="ss">:parked</span> <span class="k">do</span> <span class="o">|</span><span class="n">vehicle</span><span class="p">,</span> <span class="n">transition</span><span class="o">|</span>
      <span class="n">vehicle</span><span class="o">.</span><span class="n">seatbelt</span> <span class="o">=</span> <span class="s1">'off'</span> <span class="c1"># self is the record</span>
    <span class="k">end</span>
    <span class="n">around_transition</span> <span class="ss">:benchmark</span>

    <span class="n">event</span> <span class="ss">:ignite</span> <span class="k">do</span>
      <span class="n">transition</span> <span class="ss">:parked</span> <span class="o">=&gt;</span> <span class="ss">:idling</span>
    <span class="k">end</span>

    <span class="n">state</span> <span class="ss">:first_gear</span><span class="p">,</span> <span class="ss">:second_gear</span> <span class="k">do</span>
      <span class="n">validates_presence_of</span> <span class="ss">:seatbelt_on</span>
    <span class="k">end</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">put_on_seatbelt</span>
    <span class="o">.</span><span class="n">.</span><span class="o">.</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">benchmark</span>
    <span class="o">.</span><span class="n">.</span><span class="o">.</span>
    <span class="k">yield</span>
    <span class="o">.</span><span class="n">.</span><span class="o">.</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="k">class</span> <span class="nc">VehicleObserver</span> <span class="o">&lt;</span> <span class="no">Mongoid</span><span class="o">::</span><span class="no">Observer</span>
  <span class="c1"># Callback for :ignite event *before* the transition is performed</span>
  <span class="k">def</span> <span class="nf">before_ignite</span><span class="p">(</span><span class="n">vehicle</span><span class="p">,</span> <span class="n">transition</span><span class="p">)</span>
    <span class="c1"># log message</span>
  <span class="k">end</span>

  <span class="c1"># Generic transition callback *after* the transition is performed</span>
  <span class="k">def</span> <span class="nf">after_transition</span><span class="p">(</span><span class="n">vehicle</span><span class="p">,</span> <span class="n">transition</span><span class="p">)</span>
    <span class="no">Audit</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">vehicle</span><span class="p">,</span> <span class="n">transition</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre></div>

<p>For more information about the various behaviors added for Mongoid state
machines, see <code>StateMachine::Integrations::Mongoid</code>.</p>

<h3>
<a name="user-content-mongomapper" class="anchor" href="#mongomapper" aria-hidden="true"><span class="octicon octicon-link"></span></a>MongoMapper</h3>

<p>The MongoMapper integration adds support for automatically saving the record,
basic scopes, validation errors and callbacks.  For example,</p>

<div class="highlight highlight-ruby"><pre><span class="k">class</span> <span class="nc">Vehicle</span>
  <span class="kp">include</span> <span class="no">MongoMapper</span><span class="o">::</span><span class="no">Document</span>

  <span class="n">state_machine</span> <span class="ss">:initial</span> <span class="o">=&gt;</span> <span class="ss">:parked</span> <span class="k">do</span>
    <span class="n">before_transition</span> <span class="ss">:parked</span> <span class="o">=&gt;</span> <span class="n">any</span> <span class="o">-</span> <span class="ss">:parked</span><span class="p">,</span> <span class="ss">:do</span> <span class="o">=&gt;</span> <span class="ss">:put_on_seatbelt</span>
    <span class="n">after_transition</span> <span class="n">any</span> <span class="o">=&gt;</span> <span class="ss">:parked</span> <span class="k">do</span> <span class="o">|</span><span class="n">vehicle</span><span class="p">,</span> <span class="n">transition</span><span class="o">|</span>
      <span class="n">vehicle</span><span class="o">.</span><span class="n">seatbelt</span> <span class="o">=</span> <span class="s1">'off'</span> <span class="c1"># self is the record</span>
    <span class="k">end</span>
    <span class="n">around_transition</span> <span class="ss">:benchmark</span>

    <span class="n">event</span> <span class="ss">:ignite</span> <span class="k">do</span>
      <span class="n">transition</span> <span class="ss">:parked</span> <span class="o">=&gt;</span> <span class="ss">:idling</span>
    <span class="k">end</span>

    <span class="n">state</span> <span class="ss">:first_gear</span><span class="p">,</span> <span class="ss">:second_gear</span> <span class="k">do</span>
      <span class="n">validates_presence_of</span> <span class="ss">:seatbelt_on</span>
    <span class="k">end</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">put_on_seatbelt</span>
    <span class="o">.</span><span class="n">.</span><span class="o">.</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">benchmark</span>
    <span class="o">.</span><span class="n">.</span><span class="o">.</span>
    <span class="k">yield</span>
    <span class="o">.</span><span class="n">.</span><span class="o">.</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre></div>

<p>For more information about the various behaviors added for MongoMapper state
machines, see <code>StateMachine::Integrations::MongoMapper</code>.</p>

<h3>
<a name="user-content-sequel" class="anchor" href="#sequel" aria-hidden="true"><span class="octicon octicon-link"></span></a>Sequel</h3>

<p>Like the ActiveRecord integration, the Sequel integration adds support for
database transactions, automatically saving the record, named scopes, validation
errors and callbacks.  For example,</p>

<div class="highlight highlight-ruby"><pre><span class="k">class</span> <span class="nc">Vehicle</span> <span class="o">&lt;</span> <span class="no">Sequel</span><span class="o">::</span><span class="no">Model</span>
  <span class="n">plugin</span> <span class="ss">:validation_class_methods</span>

  <span class="n">state_machine</span> <span class="ss">:initial</span> <span class="o">=&gt;</span> <span class="ss">:parked</span> <span class="k">do</span>
    <span class="n">before_transition</span> <span class="ss">:parked</span> <span class="o">=&gt;</span> <span class="n">any</span> <span class="o">-</span> <span class="ss">:parked</span><span class="p">,</span> <span class="ss">:do</span> <span class="o">=&gt;</span> <span class="ss">:put_on_seatbelt</span>
    <span class="n">after_transition</span> <span class="n">any</span> <span class="o">=&gt;</span> <span class="ss">:parked</span> <span class="k">do</span> <span class="o">|</span><span class="n">transition</span><span class="o">|</span>
      <span class="nb">self</span><span class="o">.</span><span class="n">seatbelt</span> <span class="o">=</span> <span class="s1">'off'</span> <span class="c1"># self is the record</span>
    <span class="k">end</span>
    <span class="n">around_transition</span> <span class="ss">:benchmark</span>

    <span class="n">event</span> <span class="ss">:ignite</span> <span class="k">do</span>
      <span class="n">transition</span> <span class="ss">:parked</span> <span class="o">=&gt;</span> <span class="ss">:idling</span>
    <span class="k">end</span>

    <span class="n">state</span> <span class="ss">:first_gear</span><span class="p">,</span> <span class="ss">:second_gear</span> <span class="k">do</span>
      <span class="n">validates_presence_of</span> <span class="ss">:seatbelt_on</span>
    <span class="k">end</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">put_on_seatbelt</span>
    <span class="o">.</span><span class="n">.</span><span class="o">.</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">benchmark</span>
    <span class="o">.</span><span class="n">.</span><span class="o">.</span>
    <span class="k">yield</span>
    <span class="o">.</span><span class="n">.</span><span class="o">.</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre></div>

<p>For more information about the various behaviors added for Sequel state
machines, see <code>StateMachine::Integrations::Sequel</code>.</p>

<h2>
<a name="user-content-additional-topics" class="anchor" href="#additional-topics" aria-hidden="true"><span class="octicon octicon-link"></span></a>Additional Topics</h2>

<h3>
<a name="user-content-explicit-vs-implicit-event-transitions" class="anchor" href="#explicit-vs-implicit-event-transitions" aria-hidden="true"><span class="octicon octicon-link"></span></a>Explicit vs. Implicit Event Transitions</h3>

<p>Every event defined for a state machine generates an instance method on the
class that allows the event to be explicitly triggered.  Most of the examples in
the state_machine documentation use this technique.  However, with some types of
integrations, like ActiveRecord, you can also <em>implicitly</em> fire events by
setting a special attribute on the instance.</p>

<p>Suppose you're using the ActiveRecord integration and the following model is
defined:</p>

<div class="highlight highlight-ruby"><pre><span class="k">class</span> <span class="nc">Vehicle</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
  <span class="n">state_machine</span> <span class="ss">:initial</span> <span class="o">=&gt;</span> <span class="ss">:parked</span> <span class="k">do</span>
    <span class="n">event</span> <span class="ss">:ignite</span> <span class="k">do</span>
      <span class="n">transition</span> <span class="ss">:parked</span> <span class="o">=&gt;</span> <span class="ss">:idling</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre></div>

<p>To trigger the <code>ignite</code> event, you would typically call the <code>Vehicle#ignite</code>
method like so:</p>

<div class="highlight highlight-ruby"><pre><span class="n">vehicle</span> <span class="o">=</span> <span class="no">Vehicle</span><span class="o">.</span><span class="n">create</span>    <span class="c1"># =&gt; #&lt;Vehicle id=1 state="parked"&gt;</span>
<span class="n">vehicle</span><span class="o">.</span><span class="n">ignite</span>              <span class="c1"># =&gt; true</span>
<span class="n">vehicle</span><span class="o">.</span><span class="n">state</span>               <span class="c1"># =&gt; "idling"</span>
</pre></div>

<p>This is referred to as an <em>explicit</em> event transition.  The same behavior can
also be achieved <em>implicitly</em> by setting the state event attribute and invoking
the action associated with the state machine.  For example:</p>

<div class="highlight highlight-ruby"><pre><span class="n">vehicle</span> <span class="o">=</span> <span class="no">Vehicle</span><span class="o">.</span><span class="n">create</span>        <span class="c1"># =&gt; #&lt;Vehicle id=1 state="parked"&gt;</span>
<span class="n">vehicle</span><span class="o">.</span><span class="n">state_event</span> <span class="o">=</span> <span class="s2">"ignite"</span>  <span class="c1"># =&gt; "ignite"</span>
<span class="n">vehicle</span><span class="o">.</span><span class="n">save</span>                    <span class="c1"># =&gt; true</span>
<span class="n">vehicle</span><span class="o">.</span><span class="n">state</span>                   <span class="c1"># =&gt; "idling"</span>
<span class="n">vehicle</span><span class="o">.</span><span class="n">state_event</span>             <span class="c1"># =&gt; nil</span>
</pre></div>

<p>As you can see, the <code>ignite</code> event was automatically triggered when the <code>save</code>
action was called.  This is particularly useful if you want to allow users to
drive the state transitions from a web API.</p>

<p>See each integration's API documentation for more information on the implicit
approach.</p>

<h3>
<a name="user-content-symbols-vs-strings" class="anchor" href="#symbols-vs-strings" aria-hidden="true"><span class="octicon octicon-link"></span></a>Symbols vs. Strings</h3>

<p>In all of the examples used throughout the documentation, you'll notice that
states and events are almost always referenced as symbols.  This isn't a
requirement, but rather a suggested best practice.</p>

<p>You can very well define your state machine with Strings like so:</p>

<div class="highlight highlight-ruby"><pre><span class="k">class</span> <span class="nc">Vehicle</span>
  <span class="n">state_machine</span> <span class="ss">:initial</span> <span class="o">=&gt;</span> <span class="s1">'parked'</span> <span class="k">do</span>
    <span class="n">event</span> <span class="s1">'ignite'</span> <span class="k">do</span>
      <span class="n">transition</span> <span class="s1">'parked'</span> <span class="o">=&gt;</span> <span class="s1">'idling'</span>
    <span class="k">end</span>

    <span class="c1"># ...</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre></div>

<p>You could even use numbers as your state / event names.  The <strong>important</strong> thing
to keep in mind is that the type being used for referencing states / events in
your machine definition must be <strong>consistent</strong>.  If you're using Symbols, then
all states / events must use Symbols.  Otherwise you'll encounter the following
error:</p>

<div class="highlight highlight-ruby"><pre><span class="k">class</span> <span class="nc">Vehicle</span>
  <span class="n">state_machine</span> <span class="k">do</span>
    <span class="n">event</span> <span class="ss">:ignite</span> <span class="k">do</span>
      <span class="n">transition</span> <span class="ss">:parked</span> <span class="o">=&gt;</span> <span class="s1">'idling'</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="c1"># =&gt; ArgumentError: "idling" state defined as String, :parked defined as Symbol; all states must be consistent</span>
</pre></div>

<p>There <strong>is</strong> an exception to this rule.  The consistency is only required within
the definition itself.  However, when the machine's helper methods are called
with input from external sources, such as a web form, state_machine will map
that input to a String / Symbol.  For example:</p>

<div class="highlight highlight-ruby"><pre><span class="k">class</span> <span class="nc">Vehicle</span>
  <span class="n">state_machine</span> <span class="ss">:initial</span> <span class="o">=&gt;</span> <span class="ss">:parked</span> <span class="k">do</span>
    <span class="n">event</span> <span class="ss">:ignite</span> <span class="k">do</span>
      <span class="n">transition</span> <span class="ss">:parked</span> <span class="o">=&gt;</span> <span class="ss">:idling</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="n">v</span> <span class="o">=</span> <span class="no">Vehicle</span><span class="o">.</span><span class="n">new</span>     <span class="c1"># =&gt; #&lt;Vehicle:0xb71da5f8 @state="parked"&gt;</span>
<span class="n">v</span><span class="o">.</span><span class="n">state?</span><span class="p">(</span><span class="s1">'parked'</span><span class="p">)</span>  <span class="c1"># =&gt; true</span>
<span class="n">v</span><span class="o">.</span><span class="n">state?</span><span class="p">(</span><span class="ss">:parked</span><span class="p">)</span>   <span class="c1"># =&gt; true</span>
</pre></div>

<p><strong>Note</strong> that none of this actually has to do with the type of the value that
gets stored.  By default, all state values are assumed to be string -- regardless
of whether the state names are symbols or strings.  If you want to store states
as symbols instead you'll have to be explicit about it:</p>

<div class="highlight highlight-ruby"><pre><span class="k">class</span> <span class="nc">Vehicle</span>
  <span class="n">state_machine</span> <span class="ss">:initial</span> <span class="o">=&gt;</span> <span class="ss">:parked</span> <span class="k">do</span>
    <span class="n">event</span> <span class="ss">:ignite</span> <span class="k">do</span>
      <span class="n">transition</span> <span class="ss">:parked</span> <span class="o">=&gt;</span> <span class="ss">:idling</span>
    <span class="k">end</span>

    <span class="n">states</span><span class="o">.</span><span class="n">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">state</span><span class="o">|</span>
      <span class="nb">self</span><span class="o">.</span><span class="n">state</span><span class="p">(</span><span class="n">state</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="ss">:value</span> <span class="o">=&gt;</span> <span class="n">state</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">to_sym</span><span class="p">)</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="n">v</span> <span class="o">=</span> <span class="no">Vehicle</span><span class="o">.</span><span class="n">new</span>     <span class="c1"># =&gt; #&lt;Vehicle:0xb71da5f8 @state=:parked&gt;</span>
<span class="n">v</span><span class="o">.</span><span class="n">state?</span><span class="p">(</span><span class="s1">'parked'</span><span class="p">)</span>  <span class="c1"># =&gt; true</span>
<span class="n">v</span><span class="o">.</span><span class="n">state?</span><span class="p">(</span><span class="ss">:parked</span><span class="p">)</span>   <span class="c1"># =&gt; true</span>
</pre></div>

<h3>
<a name="user-content-syntax-flexibility" class="anchor" href="#syntax-flexibility" aria-hidden="true"><span class="octicon octicon-link"></span></a>Syntax flexibility</h3>

<p>Although state_machine introduces a simplified syntax, it still remains
backwards compatible with previous versions and other state-related libraries by
providing some flexibility around how transitions are defined.  See below for an
overview of these syntaxes.</p>

<h4>
<a name="user-content-verbose-syntax" class="anchor" href="#verbose-syntax" aria-hidden="true"><span class="octicon octicon-link"></span></a>Verbose syntax</h4>

<p>In general, it's recommended that state machines use the implicit syntax for
transitions.  However, you can be a little more explicit and verbose about
transitions by using the <code>:from</code>, <code>:except_from</code>, <code>:to</code>,
and <code>:except_to</code> options.</p>

<p>For example, transitions and callbacks can be defined like so:</p>

<div class="highlight highlight-ruby"><pre><span class="k">class</span> <span class="nc">Vehicle</span>
  <span class="n">state_machine</span> <span class="ss">:initial</span> <span class="o">=&gt;</span> <span class="ss">:parked</span> <span class="k">do</span>
    <span class="n">before_transition</span> <span class="ss">:from</span> <span class="o">=&gt;</span> <span class="ss">:parked</span><span class="p">,</span> <span class="ss">:except_to</span> <span class="o">=&gt;</span> <span class="ss">:parked</span><span class="p">,</span> <span class="ss">:do</span> <span class="o">=&gt;</span> <span class="ss">:put_on_seatbelt</span>
    <span class="n">after_transition</span> <span class="ss">:to</span> <span class="o">=&gt;</span> <span class="ss">:parked</span> <span class="k">do</span> <span class="o">|</span><span class="n">transition</span><span class="o">|</span>
      <span class="nb">self</span><span class="o">.</span><span class="n">seatbelt</span> <span class="o">=</span> <span class="s1">'off'</span> <span class="c1"># self is the record</span>
    <span class="k">end</span>

    <span class="n">event</span> <span class="ss">:ignite</span> <span class="k">do</span>
      <span class="n">transition</span> <span class="ss">:from</span> <span class="o">=&gt;</span> <span class="ss">:parked</span><span class="p">,</span> <span class="ss">:to</span> <span class="o">=&gt;</span> <span class="ss">:idling</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre></div>

<h4>
<a name="user-content-transition-context" class="anchor" href="#transition-context" aria-hidden="true"><span class="octicon octicon-link"></span></a>Transition context</h4>

<p>Some flexibility is provided around the context in which transitions can be
defined.  In almost all examples throughout the documentation, transitions are
defined within the context of an event.  If you prefer to have state machines
defined in the context of a <strong>state</strong> either out of preference or in order to
easily migrate from a different library, you can do so as shown below:</p>

<div class="highlight highlight-ruby"><pre><span class="k">class</span> <span class="nc">Vehicle</span>
  <span class="n">state_machine</span> <span class="ss">:initial</span> <span class="o">=&gt;</span> <span class="ss">:parked</span> <span class="k">do</span>
    <span class="o">.</span><span class="n">.</span><span class="o">.</span>

    <span class="n">state</span> <span class="ss">:parked</span> <span class="k">do</span>
      <span class="n">transition</span> <span class="ss">:to</span> <span class="o">=&gt;</span> <span class="ss">:idling</span><span class="p">,</span> <span class="ss">:on</span> <span class="o">=&gt;</span> <span class="o">[</span><span class="ss">:ignite</span><span class="p">,</span> <span class="ss">:shift_up</span><span class="o">]</span><span class="p">,</span> <span class="ss">:if</span> <span class="o">=&gt;</span> <span class="ss">:seatbelt_on?</span>

      <span class="k">def</span> <span class="nf">speed</span>
        <span class="mi">0</span>
      <span class="k">end</span>
    <span class="k">end</span>

    <span class="n">state</span> <span class="ss">:first_gear</span> <span class="k">do</span>
      <span class="n">transition</span> <span class="ss">:to</span> <span class="o">=&gt;</span> <span class="ss">:second_gear</span><span class="p">,</span> <span class="ss">:on</span> <span class="o">=&gt;</span> <span class="ss">:shift_up</span>

      <span class="k">def</span> <span class="nf">speed</span>
        <span class="mi">10</span>
      <span class="k">end</span>
    <span class="k">end</span>

    <span class="n">state</span> <span class="ss">:idling</span><span class="p">,</span> <span class="ss">:first_gear</span> <span class="k">do</span>
      <span class="n">transition</span> <span class="ss">:to</span> <span class="o">=&gt;</span> <span class="ss">:parked</span><span class="p">,</span> <span class="ss">:on</span> <span class="o">=&gt;</span> <span class="ss">:park</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre></div>

<p>In the above example, there's no need to specify the <code>from</code> state for each
transition since it's inferred from the context.</p>

<p>You can also define transitions completely outside the context of a particular
state / event.  This may be useful in cases where you're building a state
machine from a data store instead of part of the class definition.  See the
example below:</p>

<div class="highlight highlight-ruby"><pre><span class="k">class</span> <span class="nc">Vehicle</span>
  <span class="n">state_machine</span> <span class="ss">:initial</span> <span class="o">=&gt;</span> <span class="ss">:parked</span> <span class="k">do</span>
    <span class="o">.</span><span class="n">.</span><span class="o">.</span>

    <span class="n">transition</span> <span class="ss">:parked</span> <span class="o">=&gt;</span> <span class="ss">:idling</span><span class="p">,</span> <span class="ss">:on</span> <span class="o">=&gt;</span> <span class="o">[</span><span class="ss">:ignite</span><span class="p">,</span> <span class="ss">:shift_up</span><span class="o">]</span>
    <span class="n">transition</span> <span class="ss">:first_gear</span> <span class="o">=&gt;</span> <span class="ss">:second_gear</span><span class="p">,</span> <span class="ss">:second_gear</span> <span class="o">=&gt;</span> <span class="ss">:third_gear</span><span class="p">,</span> <span class="ss">:on</span> <span class="o">=&gt;</span> <span class="ss">:shift_up</span>
    <span class="n">transition</span> <span class="o">[</span><span class="ss">:idling</span><span class="p">,</span> <span class="ss">:first_gear</span><span class="o">]</span> <span class="o">=&gt;</span> <span class="ss">:parked</span><span class="p">,</span> <span class="ss">:on</span> <span class="o">=&gt;</span> <span class="ss">:park</span>
    <span class="n">transition</span> <span class="o">[</span><span class="ss">:idling</span><span class="p">,</span> <span class="ss">:first_gear</span><span class="o">]</span> <span class="o">=&gt;</span> <span class="ss">:parked</span><span class="p">,</span> <span class="ss">:on</span> <span class="o">=&gt;</span> <span class="ss">:park</span>
    <span class="n">transition</span> <span class="n">all</span> <span class="o">-</span> <span class="o">[</span><span class="ss">:parked</span><span class="p">,</span> <span class="ss">:stalled</span><span class="o">]</span> <span class="o">=&gt;</span> <span class="ss">:stalled</span><span class="p">,</span> <span class="ss">:unless</span> <span class="o">=&gt;</span> <span class="ss">:auto_shop_busy?</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre></div>

<p>Notice that in these alternative syntaxes:</p>

<ul class="task-list">
<li>You can continue to configure <code>:if</code> and <code>:unless</code> conditions</li>
<li>You can continue to define <code>from</code> states (when in the machine context) using
the <code>all</code>, <code>any</code>, and <code>same</code> helper methods</li>
</ul><h3>
<a name="user-content-static--dynamic-definitions" class="anchor" href="#static--dynamic-definitions" aria-hidden="true"><span class="octicon octicon-link"></span></a>Static / Dynamic definitions</h3>

<p>In most cases, the definition of a state machine is <strong>static</strong>.  That is to say,
the states, events and possible transitions are known ahead of time even though
they may depend on data that's only known at runtime.  For example, certain
transitions may only be available depending on an attribute on that object it's
being run on.  All of the documentation in this library define static machines
like so:</p>

<div class="highlight highlight-ruby"><pre><span class="k">class</span> <span class="nc">Vehicle</span>
  <span class="n">state_machine</span> <span class="ss">:state</span><span class="p">,</span> <span class="ss">:initial</span> <span class="o">=&gt;</span> <span class="ss">:parked</span> <span class="k">do</span>
    <span class="n">event</span> <span class="ss">:park</span> <span class="k">do</span>
      <span class="n">transition</span> <span class="o">[</span><span class="ss">:idling</span><span class="p">,</span> <span class="ss">:first_gear</span><span class="o">]</span> <span class="o">=&gt;</span> <span class="ss">:parked</span>
    <span class="k">end</span>

    <span class="o">.</span><span class="n">.</span><span class="o">.</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre></div>

<p>However, there may be cases where the definition of a state machine is <strong>dynamic</strong>.
This means that you don't know the possible states or events for a machine until
runtime.  For example, you may allow users in your application to manage the
state machine of a project or task in your system.  This means that the list of
transitions (and their associated states / events) could be stored externally,
such as in a database.  In a case like this, you can define dynamically-generated
state machines like so:</p>

<div class="highlight highlight-ruby"><pre><span class="k">class</span> <span class="nc">Vehicle</span>
  <span class="kp">attr_accessor</span> <span class="ss">:state</span>

  <span class="c1"># Make sure the machine gets initialized so the initial state gets set properly</span>
  <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
    <span class="k">super</span>
    <span class="n">machine</span>
  <span class="k">end</span>

  <span class="c1"># Replace this with an external source (like a db)</span>
  <span class="k">def</span> <span class="nf">transitions</span>
    <span class="o">[</span>
      <span class="p">{</span><span class="ss">:parked</span> <span class="o">=&gt;</span> <span class="ss">:idling</span><span class="p">,</span> <span class="ss">:on</span> <span class="o">=&gt;</span> <span class="ss">:ignite</span><span class="p">},</span>
      <span class="p">{</span><span class="ss">:idling</span> <span class="o">=&gt;</span> <span class="ss">:first_gear</span><span class="p">,</span> <span class="ss">:first_gear</span> <span class="o">=&gt;</span> <span class="ss">:second_gear</span><span class="p">,</span> <span class="ss">:on</span> <span class="o">=&gt;</span> <span class="ss">:shift_up</span><span class="p">}</span>
      <span class="c1"># ...</span>
    <span class="o">]</span>
  <span class="k">end</span>

  <span class="c1"># Create a state machine for this vehicle instance dynamically based on the</span>
  <span class="c1"># transitions defined from the source above</span>
  <span class="k">def</span> <span class="nf">machine</span>
    <span class="n">vehicle</span> <span class="o">=</span> <span class="nb">self</span>
    <span class="vi">@machine</span> <span class="o">||=</span> <span class="no">Machine</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="n">vehicle</span><span class="p">,</span> <span class="ss">:initial</span> <span class="o">=&gt;</span> <span class="ss">:parked</span><span class="p">,</span> <span class="ss">:action</span> <span class="o">=&gt;</span> <span class="ss">:save</span><span class="p">)</span> <span class="k">do</span>
      <span class="n">vehicle</span><span class="o">.</span><span class="n">transitions</span><span class="o">.</span><span class="n">each</span> <span class="p">{</span><span class="o">|</span><span class="n">attrs</span><span class="o">|</span> <span class="n">transition</span><span class="p">(</span><span class="n">attrs</span><span class="p">)}</span>
    <span class="k">end</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">save</span>
    <span class="c1"># Save the state change...</span>
    <span class="kp">true</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="c1"># Generic class for building machines</span>
<span class="k">class</span> <span class="nc">Machine</span>
  <span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">new</span><span class="p">(</span><span class="n">object</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">block</span><span class="p">)</span>
    <span class="n">machine_class</span> <span class="o">=</span> <span class="no">Class</span><span class="o">.</span><span class="n">new</span>
    <span class="n">machine</span> <span class="o">=</span> <span class="n">machine_class</span><span class="o">.</span><span class="n">state_machine</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">block</span><span class="p">)</span>
    <span class="n">attribute</span> <span class="o">=</span> <span class="n">machine</span><span class="o">.</span><span class="n">attribute</span>
    <span class="n">action</span> <span class="o">=</span> <span class="n">machine</span><span class="o">.</span><span class="n">action</span>

    <span class="c1"># Delegate attributes</span>
    <span class="n">machine_class</span><span class="o">.</span><span class="n">class_eval</span> <span class="k">do</span>
      <span class="n">define_method</span><span class="p">(</span><span class="ss">:definition</span><span class="p">)</span> <span class="p">{</span> <span class="n">machine</span> <span class="p">}</span>
      <span class="n">define_method</span><span class="p">(</span><span class="n">attribute</span><span class="p">)</span> <span class="p">{</span> <span class="n">object</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="n">attribute</span><span class="p">)</span> <span class="p">}</span>
      <span class="n">define_method</span><span class="p">(</span><span class="s2">"</span><span class="si">#{</span><span class="n">attribute</span><span class="si">}</span><span class="s2">="</span><span class="p">)</span> <span class="p">{</span><span class="o">|</span><span class="n">value</span><span class="o">|</span> <span class="n">object</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="s2">"</span><span class="si">#{</span><span class="n">attribute</span><span class="si">}</span><span class="s2">="</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span> <span class="p">}</span>
      <span class="n">define_method</span><span class="p">(</span><span class="n">action</span><span class="p">)</span> <span class="p">{</span> <span class="n">object</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="n">action</span><span class="p">)</span> <span class="p">}</span> <span class="k">if</span> <span class="n">action</span>
    <span class="k">end</span>

    <span class="n">machine_class</span><span class="o">.</span><span class="n">new</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="n">vehicle</span> <span class="o">=</span> <span class="no">Vehicle</span><span class="o">.</span><span class="n">new</span>                   <span class="c1"># =&gt; #&lt;Vehicle:0xb708412c @state="parked" ...&gt;</span>
<span class="n">vehicle</span><span class="o">.</span><span class="n">state</span>                           <span class="c1"># =&gt; "parked"</span>
<span class="n">vehicle</span><span class="o">.</span><span class="n">machine</span><span class="o">.</span><span class="n">ignite</span>                  <span class="c1"># =&gt; true</span>
<span class="n">vehicle</span><span class="o">.</span><span class="n">machine</span><span class="o">.</span><span class="n">state</span>                   <span class="c1"># =&gt; "idling</span>
<span class="n">vehicle</span><span class="o">.</span><span class="n">state</span>                           <span class="c1"># =&gt; "idling"</span>
<span class="n">vehicle</span><span class="o">.</span><span class="n">machine</span><span class="o">.</span><span class="n">state_transitions</span>       <span class="c1"># =&gt; [#&lt;StateMachine::Transition ...&gt;]</span>
<span class="n">vehicle</span><span class="o">.</span><span class="n">machine</span><span class="o">.</span><span class="n">definition</span><span class="o">.</span><span class="n">states</span><span class="o">.</span><span class="n">keys</span>  <span class="c1"># =&gt; :first_gear, :second_gear, :parked, :idling</span>
</pre></div>

<p>As you can see, state_machine provides enough flexibility for you to be able
to create new machine definitions on the fly based on an external source of
transitions.</p>

<h3>
<a name="user-content-core-extensions" class="anchor" href="#core-extensions" aria-hidden="true"><span class="octicon octicon-link"></span></a>Core Extensions</h3>

<p>By default, state_machine extends the Ruby core with a <code>state_machine</code> method on
<code>Class</code>.  All other parts of the library are confined within the <code>StateMachine</code>
namespace.  While this isn't wholly necessary, it also doesn't have any performance
impact and makes it truly feel like an extension to the language.  This is very
similar to the way that you'll find <code>yaml</code>, <code>json</code>, or other libraries adding a
simple method to all objects just by loading the library.</p>

<p>However, if you'd like to avoid having state_machine add this extension to the
Ruby core, you can do so like so:</p>

<div class="highlight highlight-ruby"><pre><span class="nb">require</span> <span class="s1">'state_machine/core'</span>

<span class="k">class</span> <span class="nc">Vehicle</span>
  <span class="kp">extend</span> <span class="no">StateMachine</span><span class="o">::</span><span class="no">MacroMethods</span>

  <span class="n">state_machine</span> <span class="k">do</span>
    <span class="c1"># ...</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre></div>

<p>If you're using a gem loader like Bundler, you can explicitly indicate which
file to load:</p>

<div class="highlight highlight-ruby"><pre><span class="c1"># In Gemfile</span>
<span class="o">.</span><span class="n">.</span><span class="o">.</span>
<span class="n">gem</span> <span class="s1">'state_machine'</span><span class="p">,</span> <span class="ss">:require</span> <span class="o">=&gt;</span> <span class="s1">'state_machine/core'</span>
</pre></div>

<h2>
<a name="user-content-tools" class="anchor" href="#tools" aria-hidden="true"><span class="octicon octicon-link"></span></a>Tools</h2>

<h3>
<a name="user-content-generating-graphs" class="anchor" href="#generating-graphs" aria-hidden="true"><span class="octicon octicon-link"></span></a>Generating graphs</h3>

<p>This library comes with built-in support for generating di-graphs based on the
events, states, and transitions defined for a state machine using <a href="http://www.graphviz.org">GraphViz</a>.
This requires that both the <code>ruby-graphviz</code> gem and graphviz library be
installed on the system.</p>

<h4>
<a name="user-content-examples" class="anchor" href="#examples" aria-hidden="true"><span class="octicon octicon-link"></span></a>Examples</h4>

<p>To generate a graph for a specific file / class:</p>

<div class="highlight highlight-bash"><pre>rake state_machine:draw <span class="nv">FILE</span><span class="o">=</span>vehicle.rb <span class="nv">CLASS</span><span class="o">=</span>Vehicle
</pre></div>

<p>To save files to a specific path:</p>

<div class="highlight highlight-bash"><pre>rake state_machine:draw <span class="nv">FILE</span><span class="o">=</span>vehicle.rb <span class="nv">CLASS</span><span class="o">=</span>Vehicle <span class="nv">TARGET</span><span class="o">=</span>files
</pre></div>

<p>To customize the image format / orientation:</p>

<div class="highlight highlight-bash"><pre>rake state_machine:draw <span class="nv">FILE</span><span class="o">=</span>vehicle.rb <span class="nv">CLASS</span><span class="o">=</span>Vehicle <span class="nv">FORMAT</span><span class="o">=</span>jpg <span class="nv">ORIENTATION</span><span class="o">=</span>landscape
</pre></div>

<p>See <a href="http://rdoc.info/github/glejeune/Ruby-Graphviz/Constants">http://rdoc.info/github/glejeune/Ruby-Graphviz/Constants</a> for the list of
supported image formats.  If resolution is an issue, the svg format may offer
better results.</p>

<p>To generate multiple state machine graphs:</p>

<div class="highlight highlight-bash"><pre>rake state_machine:draw <span class="nv">FILE</span><span class="o">=</span>vehicle.rb,car.rb <span class="nv">CLASS</span><span class="o">=</span>Vehicle,Car
</pre></div>

<p>To use human state / event names:</p>

<div class="highlight highlight-bash"><pre>rake state_machine:draw <span class="nv">FILE</span><span class="o">=</span>vehicle.rb <span class="nv">CLASS</span><span class="o">=</span>Vehicle <span class="nv">HUMAN_NAMES</span><span class="o">=</span><span class="nb">true</span>
</pre></div>

<p><strong>Note</strong> that this will generate a different file for every state machine defined
in the class.  The generated files will use an output filename of the format
<code>#{class_name}_#{machine_name}.#{format}</code>.</p>

<p>For examples of actual images generated using this task, see those under the
examples folder.</p>

<h3>
<a name="user-content-interactive-graphs" class="anchor" href="#interactive-graphs" aria-hidden="true"><span class="octicon octicon-link"></span></a>Interactive graphs</h3>

<p>Jean Bovet's <a href="http://www.cs.usfca.edu/%7Ejbovet/vas.html">Visual Automata Simulator</a>
is a great tool for "simulating, visualizing and transforming finite state
automata and Turing Machines".  It can help in the creation of states and events
for your models.  It is cross-platform, written in Java.</p>

<h3>
<a name="user-content-generating-documentation" class="anchor" href="#generating-documentation" aria-hidden="true"><span class="octicon octicon-link"></span></a>Generating documentation</h3>

<p>If you use YARD to generate documentation for your projects, state_machine can
be enabled to generate API docs for auto-generated methods from each state machine
definition as well as providing embedded visualizations.</p>

<p>See the generated API documentation under the examples folder to see what the
output looks like.</p>

<p>To enable the YARD integration, you'll need to add state_machine to the list of
YARD's plugins by editing the global YARD config:</p>

<p>~/.yard/config:</p>

<div class="highlight highlight-yaml"><pre><span class="l-Scalar-Plain">load_plugins</span><span class="p-Indicator">:</span> <span class="l-Scalar-Plain">true</span>
<span class="l-Scalar-Plain">autoload_plugins</span><span class="p-Indicator">:</span>
  <span class="p-Indicator">-</span> <span class="l-Scalar-Plain">state_machine</span>
</pre></div>

<p>Once enabled, simply generate your documentation like you normally do.</p>

<p><em>Note</em> that this only works for Ruby 1.9+.</p>

<h2>
<a name="user-content-web-frameworks" class="anchor" href="#web-frameworks" aria-hidden="true"><span class="octicon octicon-link"></span></a>Web Frameworks</h2>

<h3>
<a name="user-content-ruby-on-rails" class="anchor" href="#ruby-on-rails" aria-hidden="true"><span class="octicon octicon-link"></span></a>Ruby on Rails</h3>

<p>Integrating state_machine into your Ruby on Rails application is straightforward
and provides a few additional features specific to the framework. To get
started, following the steps below.</p>

<h4>
<a name="user-content-1-install-the-gem" class="anchor" href="#1-install-the-gem" aria-hidden="true"><span class="octicon octicon-link"></span></a>1. Install the gem</h4>

<p>If using Rails 2.x:</p>

<div class="highlight highlight-ruby"><pre><span class="c1"># In config/environment.rb</span>
<span class="o">.</span><span class="n">.</span><span class="o">.</span>
<span class="no">Rails</span><span class="o">::</span><span class="no">Initializer</span><span class="o">.</span><span class="n">run</span> <span class="k">do</span> <span class="o">|</span><span class="n">config</span><span class="o">|</span>
  <span class="o">.</span><span class="n">.</span><span class="o">.</span>
  <span class="n">config</span><span class="o">.</span><span class="n">gem</span> <span class="s1">'state_machine'</span><span class="p">,</span> <span class="ss">:version</span> <span class="o">=&gt;</span> <span class="s1">'~&gt; 1.0'</span>
  <span class="o">.</span><span class="n">.</span><span class="o">.</span>
<span class="k">end</span>
</pre></div>

<p>If using Rails 3.x or up:</p>

<div class="highlight highlight-ruby"><pre><span class="c1"># In Gemfile</span>
<span class="o">.</span><span class="n">.</span><span class="o">.</span>
<span class="n">gem</span> <span class="s1">'state_machine'</span>
<span class="n">gem</span> <span class="s1">'ruby-graphviz'</span><span class="p">,</span> <span class="ss">:require</span> <span class="o">=&gt;</span> <span class="s1">'graphviz'</span> <span class="c1"># Optional: only required for graphing</span>
</pre></div>

<p>As usual, run <code>bundle install</code> to load the gems.</p>

<h4>
<a name="user-content-2-create-a-model" class="anchor" href="#2-create-a-model" aria-hidden="true"><span class="octicon octicon-link"></span></a>2. Create a model</h4>

<p>Create a model with a field to store the state, along with other any other
fields your application requires:</p>

<div class="highlight highlight-bash"><pre><span class="nv">$ </span>rails generate model Vehicle state:string
<span class="nv">$ </span>rake db:migrate
</pre></div>

<h4>
<a name="user-content-3-configure-the-state-machine" class="anchor" href="#3-configure-the-state-machine" aria-hidden="true"><span class="octicon octicon-link"></span></a>3. Configure the state machine</h4>

<p>Add the state machine to your model.  Following the examples above,
<em>app/models/vehicle.rb</em> might become:</p>

<div class="highlight highlight-ruby"><pre><span class="k">class</span> <span class="nc">Vehicle</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
  <span class="n">state_machine</span> <span class="ss">:initial</span> <span class="o">=&gt;</span> <span class="ss">:parked</span> <span class="k">do</span>
    <span class="n">before_transition</span> <span class="ss">:parked</span> <span class="o">=&gt;</span> <span class="n">any</span> <span class="o">-</span> <span class="ss">:parked</span><span class="p">,</span> <span class="ss">:do</span> <span class="o">=&gt;</span> <span class="ss">:put_on_seatbelt</span>
    <span class="o">.</span><span class="n">.</span><span class="o">.</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre></div>

<h4>
<a name="user-content-rake-tasks" class="anchor" href="#rake-tasks" aria-hidden="true"><span class="octicon octicon-link"></span></a>Rake tasks</h4>

<p>There is a special integration Rake task for generating state machines for
classes used in a Ruby on Rails application.  This task will load the application
environment, meaning that it's unnecessary to specify the actual file to load.</p>

<p>For example,</p>

<div class="highlight highlight-bash"><pre>rake state_machine:draw <span class="nv">CLASS</span><span class="o">=</span>Vehicle
</pre></div>

<p>If you are using this library as a gem in Rails 2.x, the following must be added
to the end of your application's Rakefile in order for the above task to work:</p>

<div class="highlight highlight-ruby"><pre><span class="nb">require</span> <span class="s1">'tasks/state_machine'</span>
</pre></div>

<h3>
<a name="user-content-merb" class="anchor" href="#merb" aria-hidden="true"><span class="octicon octicon-link"></span></a>Merb</h3>

<h4>
<a name="user-content-rake-tasks-1" class="anchor" href="#rake-tasks-1" aria-hidden="true"><span class="octicon octicon-link"></span></a>Rake tasks</h4>

<p>Like Ruby on Rails, there is a special integration Rake task for generating
state machines for classes used in a Merb application.  This task will load the
application environment, meaning that it's unnecessary to specify the actual
files to load.</p>

<p>For example,</p>

<div class="highlight highlight-bash"><pre>rake state_machine:draw <span class="nv">CLASS</span><span class="o">=</span>Vehicle
</pre></div>

<h2>
<a name="user-content-testing" class="anchor" href="#testing" aria-hidden="true"><span class="octicon octicon-link"></span></a>Testing</h2>

<p>To run the core test suite (does <strong>not</strong> test any of the integrations):</p>

<div class="highlight highlight-bash"><pre>bundle install
bundle <span class="nb">exec </span>rake <span class="nb">test</span>
</pre></div>

<p>To run integration tests:</p>

<div class="highlight highlight-bash"><pre>bundle install
rake appraisal:install
rake appraisal:test
</pre></div>

<p>You can also test a specific version:</p>

<div class="highlight highlight-bash"><pre>rake appraisal:active_model-3.0.0 <span class="nb">test</span>
rake appraisal:active_record-2.0.0 <span class="nb">test</span>
rake appraisal:data_mapper-0.9.4 <span class="nb">test</span>
rake appraisal:mongoid-2.0.0 <span class="nb">test</span>
rake appraisal:mongo_mapper-0.5.5 <span class="nb">test</span>
rake appraisal:sequel-2.8.0 <span class="nb">test</span>
</pre></div>

<h2>
<a name="user-content-caveats" class="anchor" href="#caveats" aria-hidden="true"><span class="octicon octicon-link"></span></a>Caveats</h2>

<p>The following caveats should be noted when using state_machine:</p>

<ul class="task-list">
<li>Overridden event methods won't get invoked when using attribute-based event transitions</li>
<li>
<strong>DataMapper</strong>: Attribute-based event transitions are disabled when using dm-validations 0.9.4 - 0.9.6</li>
<li>
<strong>DataMapper</strong>: Transitions cannot persist states when run from after :create / :save callbacks</li>
<li>
<strong>JRuby / Rubinius</strong>: around_transition callbacks in ORM integrations won't work on JRuby since it doesn't support continuations</li>
<li>
<strong>Factory Girl</strong>: Dynamic initial states don't work because of the way factory_girl
builds objects.  You can work around this in a few ways:

<ol class="task-list">
<li>Use a default state that is common across all objects and rely on events to
determine the actual initial state for your object.</li>
<li>Assuming you're not using state-driven behavior on initialization, you can
re-initialize states after the fact:</li>
</ol>
</li>
</ul><div class="highlight highlight-ruby"><pre><span class="c1"># Re-initialize in FactoryGirl</span>
<span class="no">FactoryGirl</span><span class="o">.</span><span class="n">define</span> <span class="k">do</span>
  <span class="n">factory</span> <span class="ss">:vehicle</span> <span class="k">do</span>
    <span class="n">after_build</span> <span class="p">{</span><span class="o">|</span><span class="n">user</span><span class="o">|</span> <span class="n">user</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="ss">:initialize_state_machines</span><span class="p">,</span> <span class="ss">:dynamic</span> <span class="o">=&gt;</span> <span class="ss">:force</span><span class="p">)}</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="c1"># Alternatively re-initialize in your model</span>
<span class="k">class</span> <span class="nc">Vehicle</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
  <span class="o">.</span><span class="n">.</span><span class="o">.</span>
  <span class="n">before_validation</span> <span class="ss">:on</span> <span class="o">=&gt;</span> <span class="ss">:create</span> <span class="p">{</span><span class="o">|</span><span class="n">user</span><span class="o">|</span> <span class="n">user</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="ss">:initialize_state_machines</span><span class="p">,</span> <span class="ss">:dynamic</span> <span class="o">=&gt;</span> <span class="ss">:force</span><span class="p">)}</span>
<span class="k">end</span>
</pre></div>

<h2>
<a name="user-content-dependencies" class="anchor" href="#dependencies" aria-hidden="true"><span class="octicon octicon-link"></span></a>Dependencies</h2>

<p>Ruby versions officially supported and tested:</p>

<ul class="task-list">
<li>Ruby (MRI) 1.8.6+</li>
<li>JRuby (1.8, 1.9)</li>
<li>Rubinius (1.8, 1.9)</li>
</ul><p>ORM versions officially supported and tested:</p>

<ul class="task-list">
<li>
<a href="http://rubyonrails.org">ActiveModel</a> integration: 3.0.0 or later</li>
<li>
<a href="http://rubyonrails.org">ActiveRecord</a> integration: 2.0.0 or later</li>
<li>
<a href="http://datamapper.org">DataMapper</a> integration: 0.9.4 or later</li>
<li>
<a href="http://mongoid.org">Mongoid</a> integration: 2.0.0 or later</li>
<li>
<a href="http://mongomapper.com">MongoMapper</a> integration: 0.5.5 or later</li>
<li>
<a href="http://sequel.rubyforge.org">Sequel</a> integration: 2.8.0 or later</li>
</ul><p>If graphing state machine:</p>

<ul class="task-list">
<li>
<a href="http://github.com/glejeune/Ruby-Graphviz">ruby-graphviz</a>: 0.9.17 or later</li>
</ul></article></div>