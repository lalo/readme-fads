<div class="announce instapaper_body md" data-path="README.md" id="readme"><article class="markdown-body entry-content" itemprop="mainContentOfPage"><h1>
<a name="user-content-cells" class="anchor" href="#cells" aria-hidden="true"><span class="octicon octicon-link"></span></a>Cells</h1>

<p><em>View Components for Rails.</em></p>

<h2>
<a name="user-content-overview" class="anchor" href="#overview" aria-hidden="true"><span class="octicon octicon-link"></span></a>Overview</h2>

<p>Cells allow you to encapsulate parts of your page into a separate MVC component. They look and feel like controllers, can run arbitrary code in an action and render views.</p>

<p>While they improve your overall software architecture by abstracting logic into an encapsulated OOP instance, cells also maximise reuseability within or across projects.</p>

<p>Basically, cells can be rendered anywhere in your code. Most people use them in views to replace a helper/partial/filter mess, as a mailer renderer substitute or hook them to routes and completely bypass <code>ActionController</code>.</p>

<h2>
<a name="user-content-view-models" class="anchor" href="#view-models" aria-hidden="true"><span class="octicon octicon-link"></span></a>View Models</h2>

<p>Since version 3.9 cells comes with two "dialects": You can still use a cell like a controller. However, the new <a href="https://github.com/apotonick/cells#view-models-explained">view model</a> "dialect" supercedes the traditional cell. It allows you to treat a cell more object-oriented while providing an alternative approach to helpers.</p>

<p>While the old dialect still works, we strongly recommend using a cell as a view model.</p>

<h2>
<a name="user-content-installation" class="anchor" href="#installation" aria-hidden="true"><span class="octicon octicon-link"></span></a>Installation</h2>

<p>Cells run with all Rails &gt;= 3.0. For 2.3 support <a href="#rails-23-note">see below</a>.</p>

<div class="highlight highlight-ruby"><pre><span class="n">gem</span> <span class="s1">'cells'</span>
</pre></div>

<h2>
<a name="user-content-file-layout" class="anchor" href="#file-layout" aria-hidden="true"><span class="octicon octicon-link"></span></a>File Layout</h2>

<p>Cells are placed in <code>app/cells</code>.</p>

<pre><code>app
├── cells
│   ├── comment_cell.rb
│   ├── comment
│   │   ├── show.haml
│   │   ├── list.haml
</code></pre>

<h2>
<a name="user-content-generate" class="anchor" href="#generate" aria-hidden="true"><span class="octicon octicon-link"></span></a>Generate</h2>

<p>Creating a cell is nothing more than</p>

<pre lang="shell"><code>rails generate cell cart show -e haml
</code></pre>

<pre><code>create  app/cells/
create  app/cells/cart
create  app/cells/cart_cell.rb
create  app/cells/cart/show.html.haml
create  test/cells/cart_test.rb
</code></pre>

<p>That looks very familiar.</p>

<h2>
<a name="user-content-render-the-cell" class="anchor" href="#render-the-cell" aria-hidden="true"><span class="octicon octicon-link"></span></a>Render the cell</h2>

<p>Now, render your cart. Why not put it in <code>layouts/application.html.erb</code> for now?</p>

<div class="highlight highlight-erb"><pre><span class="x">&lt;div id="header"&gt;</span>
<span class="x">  </span><span class="cp">&lt;%=</span> <span class="n">render_cell</span> <span class="ss">:cart</span><span class="p">,</span> <span class="ss">:show</span><span class="p">,</span> <span class="ss">:user</span> <span class="o">=&gt;</span> <span class="vi">@current_user</span> <span class="cp">%&gt;</span><span class="x"></span>
</pre></div>

<p>Feels like rendering a controller action. For good encapsulation we pass the current <code>user</code> from outside into the cell - a dependency injection.</p>

<h2>
<a name="user-content-code" class="anchor" href="#code" aria-hidden="true"><span class="octicon octicon-link"></span></a>Code</h2>

<p>Time to improve our cell code. Let's start with <code>app/cells/cart_cell.rb</code>:</p>

<div class="highlight highlight-ruby"><pre><span class="k">class</span> <span class="nc">CartCell</span> <span class="o">&lt;</span> <span class="no">Cell</span><span class="o">::</span><span class="no">Rails</span>
  <span class="k">def</span> <span class="nf">show</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
    <span class="n">user</span>    <span class="o">=</span> <span class="n">args</span><span class="o">[</span><span class="ss">:user</span><span class="o">]</span>
    <span class="vi">@items</span>  <span class="o">=</span> <span class="n">user</span><span class="o">.</span><span class="n">items_in_cart</span>

    <span class="n">render</span>  <span class="c1"># renders show.html.haml</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre></div>

<p>Is that a controller? Hell, yeah. We even got a <code>#render</code> method as we know it from the good ol' <code>ActionController</code>.</p>

<h2>
<a name="user-content-views" class="anchor" href="#views" aria-hidden="true"><span class="octicon octicon-link"></span></a>Views</h2>

<p>Since a plain call to <code>#render</code> will start rendering <code>app/cells/cart/show.html.haml</code> we should put some meaningful markup there.</p>

<div class="highlight highlight-haml"><pre><span class="nf">#cart</span>
  You have <span class="si">#{</span><span class="vi">@items</span><span class="o">.</span><span class="n">size</span><span class="si">}</span> items in your shopping cart.
</pre></div>

<h3>
<a name="user-content-erb-haml-builder" class="anchor" href="#erb-haml-builder" aria-hidden="true"><span class="octicon octicon-link"></span></a>ERB? Haml? Builder?</h3>

<p>Yes, Cells support all template types that are supported by Rails itself. Remember- it's a controller!</p>

<h3>
<a name="user-content-helpers" class="anchor" href="#helpers" aria-hidden="true"><span class="octicon octicon-link"></span></a>Helpers</h3>

<p>Yes, Cells have helpers just like controllers. If you need some specific helper, do</p>

<div class="highlight highlight-ruby"><pre><span class="k">class</span> <span class="nc">CartCell</span> <span class="o">&lt;</span> <span class="no">Cell</span><span class="o">::</span><span class="no">Rails</span>
  <span class="n">helper</span> <span class="no">MyExtraHelper</span>
</pre></div>

<p>and it will be around in your cart views.</p>

<h3>
<a name="user-content-partials" class="anchor" href="#partials" aria-hidden="true"><span class="octicon octicon-link"></span></a>Partials?</h3>

<p>In Cells, everything template file is a <em>view</em>. You're still free to render views within views (aka "partial") but we just call it "<em>view</em>". There's no need to have two different types of views. Whenever you're tempted to render a partial, use the cells term <code>view</code>.</p>

<div class="highlight highlight-haml"><pre><span class="c">/ app/cells/comment/show.haml</span>

<span class="nt">%h1</span> All comments

<span class="nt">%p</span>
  <span class="p">=</span> <span class="n">render</span> <span class="ss">:view</span> <span class="o">=&gt;</span> <span class="s1">'items'</span>
</pre></div>

<h2>
<a name="user-content-file-structure" class="anchor" href="#file-structure" aria-hidden="true"><span class="octicon octicon-link"></span></a>File Structure</h2>

<p>TODO: rails g concept Song =&gt; show.haml,</p>

<p>In Cells 3.10 we introduce a new <em>optional</em> file structure integrating with <a href="https://github.com/apotonick/trailblazer">Trailblazer</a>'s "concept-oriented" layout.</p>

<p>This new file layout makes a cell fully <strong>self-contained</strong> so it can be moved around just by grabbing one single directory.</p>

<p>Activate it with</p>

<div class="highlight highlight-ruby"><pre><span class="k">class</span> <span class="nc">Comment</span><span class="o">::</span><span class="no">Cell</span>
  <span class="n">self_contained!</span>

  <span class="c1"># ...</span>
<span class="k">end</span>
</pre></div>

<p>Now, the cell directory ideally looks like the following.</p>

<pre><code>app
├── cells
│   ├── comment
│   │   ├── cell.rb
│   │   ├── views
│   │   │   ├── show.haml
│   │   │   ├── list.haml
</code></pre>

<p>Here, cell class and associated views are in the same self-contained <code>comment</code> directory.</p>

<p>You can use the new views directory along with leaving your cell <em>class</em> at <code>app/cells/comment_cell.rb</code>, if you fancy that.</p>

<h2>
<a name="user-content-asset-pipeline" class="anchor" href="#asset-pipeline" aria-hidden="true"><span class="octicon octicon-link"></span></a>Asset Pipeline</h2>

<p>Cells can also package their own assets like JavaScript, CoffeeScript, Sass and stylesheets. When configured, those files go directly into Rails' asset pipeline. This is a great way to clean up your assets by pushing scripts and styles into the component they belong to. It makes it so much easier to find out which files are actually involved per "widget".</p>

<p>Note: This feature is <strong>still experimental</strong> and the API (file name conventions, configuration, etc.) might change.</p>

<p>Assets per default sit in the cell's <code>assets/</code> directory.</p>

<pre><code>app
├── cells
│   ├── comment
│   │   ├── views
│   │   ├── ..
│   │   ├── assets
│   │   │   ├── comment.js.coffee
│   │   │   ├── comment.css.sass
</code></pre>

<p>Adding the assets files to the asset pipeline currently involves two steps (I know it feels a bit clumsy, but I'm sure we'll find a way to make it better soon).</p>

<ol class="task-list">
<li>
<p>Tell Rails that this cell provides its own self-contained assets.</p>

<div class="highlight highlight-ruby"><pre><span class="no">Gemgem</span><span class="o">::</span><span class="no">Application</span><span class="o">.</span><span class="n">configure</span> <span class="k">do</span>
  <span class="c1"># ...</span>

  <span class="n">config</span><span class="o">.</span><span class="n">cells</span><span class="o">.</span><span class="n">with_assets</span> <span class="o">=</span> <span class="sx">%w(comment)</span>
</pre></div>

<p>This will add <code>app/cells/comment/assets/</code> to the asset pipeline's paths.</p>
</li>
<li>
<p>Include the assets in <code>application.js</code> and <code>application.css.sass</code></p>

<p>In <code>app/assets/application.js</code>, you have to add the cell assets manually.</p>

<div class="highlight highlight-javascript"><pre><span class="c1">//=# require comments</span>
</pre></div>

<p>Same goes into <code>app/assets/application.css.sass</code>.</p>

<div class="highlight highlight-sass"><pre><span class="k">@import</span> <span class="s">'comments';</span>
</pre></div>
</li>
</ol><p>In future versions, we wanna improve this by automatically including cell assets and avoiding name clashes. If you have ideas, suggestions, I'd love to hear them.</p>

<h3>
<a name="user-content-rendering-global-partials" class="anchor" href="#rendering-global-partials" aria-hidden="true"><span class="octicon octicon-link"></span></a>Rendering Global Partials</h3>

<p>Sometimes you need to render a global partial from <code>app/views</code> within a cell. For instance, the <code>gmaps4rails</code> helper depends on a global partial. While this breaks encapsulation it's still possible in cells - just add the global view path.</p>

<div class="highlight highlight-ruby"><pre><span class="k">class</span> <span class="nc">MapCell</span> <span class="o">&lt;</span> <span class="no">Cell</span><span class="o">::</span><span class="no">Rails</span>
  <span class="n">append_view_path</span> <span class="s2">"app/views"</span>

  <span class="k">def</span> <span class="nf">show</span>
    <span class="n">render</span> <span class="ss">partial</span><span class="p">:</span> <span class="s1">'shared/map_form'</span>
  <span class="k">end</span>
</pre></div>

<p>Note that you have to use <code>render partial:</code> which will then look in the global view directory and render the partial found at <code>app/views/shared/map_form.html.haml</code>.</p>

<h2>
<a name="user-content-view-inheritance" class="anchor" href="#view-inheritance" aria-hidden="true"><span class="octicon octicon-link"></span></a>View Inheritance</h2>

<p>This is where OOP comes back to your view.</p>

<ul class="task-list">
<li>
<strong>Inherit code</strong> into your cells by deriving more abstract cells.</li>
<li>
<strong>Inherit views</strong> from parent cells.</li>
</ul><h3>
<a name="user-content-sharing-views" class="anchor" href="#sharing-views" aria-hidden="true"><span class="octicon octicon-link"></span></a>Sharing Views</h3>

<p>Sometimes it is handy to reuse an existing view directory from another cell, to avoid a growing number of directories. You could derive the new cell and thus inherit the view paths.</p>

<div class="highlight highlight-ruby"><pre><span class="k">class</span> <span class="nc">Comment</span><span class="o">::</span><span class="no">FormCell</span> <span class="o">&lt;</span> <span class="no">CommentCell</span>
</pre></div>

<p>This does not only allow view inheritance, but will also inherit all the code from <code>CommentCell</code>. This might not be what you want.</p>

<p>If you're just after inheriting the <em>views</em>, use <code>::inherit_views</code>.</p>

<div class="highlight highlight-ruby"><pre><span class="k">class</span> <span class="nc">Comment</span><span class="o">::</span><span class="no">FormCell</span> <span class="o">&lt;</span> <span class="no">Cell</span><span class="o">::</span><span class="no">Rails</span>
  <span class="n">inherit_views</span> <span class="no">CommentCell</span>
</pre></div>

<p>When rendering views in <code>FormCell</code>, the view directories to look for templates will be inherited.</p>

<h3>
<a name="user-content-builders" class="anchor" href="#builders" aria-hidden="true"><span class="octicon octicon-link"></span></a>Builders</h3>

<p>Let <code>render_cell</code> take care of creating the right cell. Just configure your super-cell properly.</p>

<div class="highlight highlight-ruby"><pre><span class="k">class</span> <span class="nc">LoginCell</span> <span class="o">&lt;</span> <span class="no">Cell</span><span class="o">::</span><span class="no">Rails</span>
  <span class="n">build</span> <span class="k">do</span>
    <span class="no">UnauthorizedUserCell</span> <span class="k">unless</span> <span class="n">logged_in?</span>
  <span class="k">end</span>
</pre></div>

<p>A call to</p>

<div class="highlight highlight-ruby"><pre><span class="n">render_cell</span><span class="p">(</span><span class="ss">:login</span><span class="p">,</span> <span class="ss">:box</span><span class="p">)</span>
</pre></div>

<p>will render the configured <code>UnauthorizedUserCell</code> instead of the original <code>LoginCell</code> if the login test fails.</p>

<h2>
<a name="user-content-caching" class="anchor" href="#caching" aria-hidden="true"><span class="octicon octicon-link"></span></a>Caching</h2>

<p>Cells allow you to cache per state. It's simple: the rendered result of a state method is cached and expired as you configure it.</p>

<p>To cache forever, don't configure anything</p>

<div class="highlight highlight-ruby"><pre><span class="k">class</span> <span class="nc">CartCell</span> <span class="o">&lt;</span> <span class="no">Cell</span><span class="o">::</span><span class="no">Rails</span>
  <span class="n">cache</span> <span class="ss">:show</span>

  <span class="k">def</span> <span class="nf">show</span>
    <span class="n">render</span>
  <span class="k">end</span>
</pre></div>

<p>This will run <code>#show</code> only once, after that the rendered view comes from the cache.</p>

<h3>
<a name="user-content-cache-options" class="anchor" href="#cache-options" aria-hidden="true"><span class="octicon octicon-link"></span></a>Cache Options</h3>

<p>Note that you can pass arbitrary options through to your cache store. Symbols are evaluated as instance methods, callable objects (e.g. lambdas) are evaluated in the cell instance context allowing you to call instance methods and access instance variables. All arguments passed to your state (e.g. via <code>render_cell</code>) are propagated to the block.</p>

<div class="highlight highlight-ruby"><pre><span class="n">cache</span> <span class="ss">:show</span><span class="p">,</span> <span class="ss">:expires_in</span> <span class="o">=&gt;</span> <span class="mi">10</span><span class="o">.</span><span class="n">minutes</span>
</pre></div>

<p>If you need dynamic options evaluated at render-time, use a lambda.</p>

<div class="highlight highlight-ruby"><pre><span class="n">cache</span> <span class="ss">:show</span><span class="p">,</span> <span class="ss">:tags</span> <span class="o">=&gt;</span> <span class="nb">lambda</span> <span class="p">{</span> <span class="o">|*</span><span class="n">args</span><span class="o">|</span> <span class="n">tags</span> <span class="p">}</span>
</pre></div>

<p>If you don't like blocks, use instance methods instead.</p>

<div class="highlight highlight-ruby"><pre><span class="k">class</span> <span class="nc">CartCell</span> <span class="o">&lt;</span> <span class="no">Cell</span><span class="o">::</span><span class="no">Rails</span>
  <span class="n">cache</span> <span class="ss">:show</span><span class="p">,</span> <span class="ss">:tags</span> <span class="o">=&gt;</span> <span class="ss">:cache_tags</span>

  <span class="k">def</span> <span class="nf">cache_tags</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
    <span class="c1"># do your magic..</span>
  <span class="k">end</span>
</pre></div>

<h3>
<a name="user-content-conditional-caching" class="anchor" href="#conditional-caching" aria-hidden="true"><span class="octicon octicon-link"></span></a>Conditional Caching</h3>

<p>The +:if+ option lets you define a condition. If it doesn't return a true value, caching for that state is skipped.</p>

<div class="highlight highlight-ruby"><pre><span class="n">cache</span> <span class="ss">:show</span><span class="p">,</span> <span class="ss">:if</span> <span class="o">=&gt;</span> <span class="nb">lambda</span> <span class="p">{</span> <span class="o">|*|</span> <span class="n">has_changed?</span> <span class="p">}</span>
</pre></div>

<h3>
<a name="user-content-cache-keys" class="anchor" href="#cache-keys" aria-hidden="true"><span class="octicon octicon-link"></span></a>Cache Keys</h3>

<p>You can expand the state's cache key by appending a versioner block to the <code>::cache</code> call. This way you can expire state caches yourself.</p>

<div class="highlight highlight-ruby"><pre><span class="k">class</span> <span class="nc">CartCell</span> <span class="o">&lt;</span> <span class="no">Cell</span><span class="o">::</span><span class="no">Rails</span>
  <span class="n">cache</span> <span class="ss">:show</span> <span class="k">do</span> <span class="o">|</span><span class="n">options</span><span class="o">|</span>
    <span class="n">order</span><span class="o">.</span><span class="n">id</span>
  <span class="k">end</span>
</pre></div>

<p>The versioner block is executed in the cell instance context, allowing you to access all stakeholder objects you need to compute a cache key. The return value is appended to the state key: <code>"cells/cart/show/1"</code>.</p>

<p>As everywhere in Rails, you can also return an array.</p>

<div class="highlight highlight-ruby"><pre><span class="k">class</span> <span class="nc">CartCell</span> <span class="o">&lt;</span> <span class="no">Cell</span><span class="o">::</span><span class="no">Rails</span>
  <span class="n">cache</span> <span class="ss">:show</span> <span class="k">do</span> <span class="o">|</span><span class="n">options</span><span class="o">|</span>
    <span class="o">[</span><span class="nb">id</span><span class="p">,</span> <span class="n">options</span><span class="o">[</span><span class="ss">:items</span><span class="o">].</span><span class="n">md5</span><span class="o">]</span>
  <span class="k">end</span>
</pre></div>

<p>Resulting in: <code>"cells/cart/show/1/0ecb1360644ce665a4ef"</code>.</p>

<h3>
<a name="user-content-debugging-cache" class="anchor" href="#debugging-cache" aria-hidden="true"><span class="octicon octicon-link"></span></a>Debugging Cache</h3>

<p>When caching is turned on, you might wanna see notifications. Just like a controller, Cells gives you the following notifications.</p>

<ul class="task-list">
<li>
<code>write_fragment.action_controller</code> for cache miss.</li>
<li>
<code>read_fragment.action_controller</code> for cache hits.</li>
</ul><p>To activate notifications, include the <code>Notifications</code> module in your cell.</p>

<div class="highlight highlight-ruby"><pre><span class="k">class</span> <span class="nc">Comment</span><span class="o">::</span><span class="no">Cell</span> <span class="o">&lt;</span> <span class="no">Cell</span><span class="o">::</span><span class="no">Rails</span>
  <span class="kp">include</span> <span class="no">Cell</span><span class="o">::</span><span class="no">Caching</span><span class="o">::</span><span class="no">Notifications</span>
</pre></div>

<h3>
<a name="user-content-inheritance" class="anchor" href="#inheritance" aria-hidden="true"><span class="octicon octicon-link"></span></a>Inheritance</h3>

<p>Cache configuration is inherited to derived cells.</p>

<h3>
<a name="user-content-a-note-on-fragment-caching" class="anchor" href="#a-note-on-fragment-caching" aria-hidden="true"><span class="octicon octicon-link"></span></a>A Note On Fragment Caching</h3>

<p>Fragment caching is <a href="http://nicksda.apotomo.de/2011/02/rails-misapprehensions-caching-views-is-not-the-views-job/">not implemented in Cells per design</a> - Cells tries to move caching to the class layer enforcing an object-oriented design rather than cluttering your views with caching blocks.</p>

<p>If you need to cache a part of your view, implement that as another cell state.</p>

<h3>
<a name="user-content-testing-caching" class="anchor" href="#testing-caching" aria-hidden="true"><span class="octicon octicon-link"></span></a>Testing Caching</h3>

<p>If you want to test it in <code>development</code>, you need to put <code>config.action_controller.perform_caching = true</code> in <code>development.rb</code> to see the effect.</p>

<h2>
<a name="user-content-testing" class="anchor" href="#testing" aria-hidden="true"><span class="octicon octicon-link"></span></a>Testing</h2>

<p>Another big advantage compared to monolithic controller/helper/partial piles is the ability to test your cells isolated.</p>

<h3>
<a name="user-content-testunit" class="anchor" href="#testunit" aria-hidden="true"><span class="octicon octicon-link"></span></a>Test::Unit</h3>

<p>So what if you wanna test the cart cell? Use the generated <code>test/cells/cart_cell_test.rb</code> test.</p>

<div class="highlight highlight-ruby"><pre><span class="k">class</span> <span class="nc">CartCellTest</span> <span class="o">&lt;</span> <span class="no">Cell</span><span class="o">::</span><span class="no">TestCase</span>
  <span class="nb">test</span> <span class="s2">"show"</span> <span class="k">do</span>
    <span class="n">invoke</span> <span class="ss">:show</span><span class="p">,</span> <span class="ss">:user</span> <span class="o">=&gt;</span> <span class="vi">@user_fixture</span>
    <span class="n">assert_select</span> <span class="s2">"#cart"</span><span class="p">,</span> <span class="s2">"You have 3 items in your shopping cart."</span>
  <span class="k">end</span>
</pre></div>

<p>Don't forget to put <code>require 'cell/test_case'</code> in your project's <code>test/test_helper.rb</code> file.</p>

<p>Then, run your tests with</p>

<pre lang="shell"><code>rake test:cells
</code></pre>

<p>That's easy, clean and strongly improves your component-driven software quality. How'd you do that with partials?</p>

<h3>
<a name="user-content-rspec" class="anchor" href="#rspec" aria-hidden="true"><span class="octicon octicon-link"></span></a>RSpec</h3>

<p>If you prefer RSpec examples, use the <a href="http://github.com/apotonick/rspec-cells">rspec-cells</a> gem for specing.</p>

<div class="highlight highlight-ruby"><pre><span class="n">it</span> <span class="s2">"should render the posts count"</span> <span class="k">do</span>
  <span class="n">render_cell</span><span class="p">(</span><span class="ss">:posts</span><span class="p">,</span> <span class="ss">:count</span><span class="p">)</span><span class="o">.</span><span class="n">should</span> <span class="n">have_selector</span><span class="p">(</span><span class="s2">"p"</span><span class="p">,</span> <span class="ss">:content</span> <span class="o">=&gt;</span> <span class="s2">"4 posts!"</span><span class="p">)</span>
<span class="k">end</span>
</pre></div>

<p>To run your specs we got a rake task, too!</p>

<pre lang="shell"><code>rake spec:cells
</code></pre>

<h1>
<a name="user-content-view-models-explained" class="anchor" href="#view-models-explained" aria-hidden="true"><span class="octicon octicon-link"></span></a>View Models, Explained</h1>

<p>View models supersede the old controller-like cells. View models feel more natural as they wrap domain models and then add decorating methods for the view.</p>

<p>They are also significantly faster since they don't need to copy helpers and instance variables to the view: The view model itself is the view context. That means, methods called in the view are invoked on your cell instance.</p>

<div class="highlight highlight-ruby"><pre><span class="c1"># app/cells/song_cell.rb</span>
<span class="k">class</span> <span class="nc">SongCell</span> <span class="o">&lt;</span> <span class="no">Cell</span><span class="o">::</span><span class="no">ViewModel</span>
<span class="k">end</span>
</pre></div>

<h3>
<a name="user-content-creation" class="anchor" href="#creation" aria-hidden="true"><span class="octicon octicon-link"></span></a>Creation</h3>

<p>Instantiating the view model should happen in controllers and views, but you can virtually use them anywhere.</p>

<p>A default workflow for creating and rendering a view model looks as the following.</p>

<div class="highlight highlight-ruby"><pre><span class="n">song</span> <span class="o">=</span> <span class="no">Song</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

<span class="vi">@cell</span> <span class="o">=</span> <span class="n">cell</span><span class="p">(</span><span class="ss">:song</span><span class="p">,</span> <span class="n">song</span><span class="p">)</span><span class="o">.</span><span class="n">call</span>
</pre></div>

<p>The <code>#cell</code> helper gives you an instance of the <code>SongCell</code> cell and wraps the <code>song</code> object.</p>

<h3>
<a name="user-content-rendering" class="anchor" href="#rendering" aria-hidden="true"><span class="octicon octicon-link"></span></a>Rendering</h3>

<p>The <code>call</code> invocation instructs the cell to render. Internally, that runs <code>render_state(:show)</code> per default.</p>

<p>You can basically invoke any method you want on that cell. Nevertheless, a view model should only expose the <code>#show</code> method per convention, which is reflected by the <code>#call</code> alias.</p>

<p>It is important to understand this convention: Internally, you may render multiple views, combine them, use instance methods to render and format values, and so on. Externally, exposing only one "public", rendering method defines a strong interface for your view model.</p>

<div class="highlight highlight-ruby"><pre><span class="k">class</span> <span class="nc">SongCell</span> <span class="o">&lt;</span> <span class="no">Cell</span><span class="o">::</span><span class="no">ViewModel</span>
  <span class="k">def</span> <span class="nf">show</span>
    <span class="n">render</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre></div>

<p>The <code>render</code> call will render the cell's <code>show</code> view.</p>

<h3>
<a name="user-content-views-1" class="anchor" href="#views-1" aria-hidden="true"><span class="octicon octicon-link"></span></a>Views</h3>

<div class="highlight highlight-haml"><pre><span class="p">-</span> <span class="c1"># app/cells/song/show.haml</span>

<span class="nt">%h1</span> <span class="si">#{</span><span class="n">title</span><span class="si">}</span>

<span class="nt">%p</span> Written at <span class="si">#{</span><span class="n">composed_at</span><span class="si">}</span>

<span class="p">=</span> <span class="n">author_box</span>
</pre></div>

<p>We strongly recommend to only invoke <em>methods</em> in views and <em>not</em> to use instance variables and locals. In a view model template (or, view), methods are called on the view model instance itself, meaning you can easily expose "helpers" by defining instance methods.</p>

<h3>
<a name="user-content-helpers-1" class="anchor" href="#helpers-1" aria-hidden="true"><span class="octicon octicon-link"></span></a>Helpers</h3>

<div class="highlight highlight-ruby"><pre><span class="k">class</span> <span class="nc">SongCell</span> <span class="o">&lt;</span> <span class="no">Cell</span><span class="o">::</span><span class="no">ViewModel</span>
  <span class="kp">include</span> <span class="no">TimeagoHelper</span>

  <span class="k">def</span> <span class="nf">show</span>
    <span class="n">render</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">composed_at</span>
    <span class="n">timeago</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">created_at</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre></div>

<p>In other words, using <code>composed_at</code> in the view will call <code>SongCell#composed_at</code>. Note that you have to <code>include</code> additional helpers into the class.</p>

<p>The <code>#model</code> methods lets you access the wrapped <code>Song</code> instance we passed into the cell when creating it.</p>

<h3>
<a name="user-content-properties" class="anchor" href="#properties" aria-hidden="true"><span class="octicon octicon-link"></span></a>Properties</h3>

<p>Often, it is helpful to automatically expose some reader methods to the model. You can do that with <code>::property</code>.</p>

<div class="highlight highlight-ruby"><pre><span class="k">class</span> <span class="nc">SongCell</span> <span class="o">&lt;</span> <span class="no">Cell</span><span class="o">::</span><span class="no">ViewModel</span>
  <span class="kp">include</span> <span class="no">TimeagoHelper</span>

  <span class="n">property</span> <span class="ss">:title</span>

  <span class="c1"># ...</span>
<span class="k">end</span>
</pre></div>

<p>You can now safely use <code>#title</code> in the view (and, in the cell class), it is delegated to <code>model.title</code>.</p>

<h3>
<a name="user-content-call" class="anchor" href="#call" aria-hidden="true"><span class="octicon octicon-link"></span></a>Call</h3>

<p>The <code>#call</code> method also accepts a block and yields <code>self</code> (the cell instance) to it. This is extremely helpful for using <code>content_for</code> outside of the cell.</p>

<div class="highlight highlight-ruby"><pre>  <span class="o">=</span> <span class="n">cell</span><span class="p">(</span><span class="ss">:song</span><span class="p">,</span> <span class="no">Song</span><span class="o">.</span><span class="n">last</span><span class="p">)</span><span class="o">.</span><span class="n">call</span><span class="p">(</span><span class="ss">:show</span><span class="p">)</span> <span class="k">do</span> <span class="o">|</span><span class="n">cell</span><span class="o">|</span>
    <span class="n">content_for</span> <span class="ss">:footer</span><span class="p">,</span> <span class="n">cell</span><span class="o">.</span><span class="n">footer</span>
</pre></div>

<p>Note how the block is run in the global view's context, allowing you to use global helpers like <code>content_for</code>.</p>

<h2>
<a name="user-content-using-decorators-twins" class="anchor" href="#using-decorators-twins" aria-hidden="true"><span class="octicon octicon-link"></span></a>Using Decorators (Twins)</h2>

<p>You need to include the <code>disposable</code> gem in order to use this.</p>

<div class="highlight highlight-ruby"><pre><span class="n">gem</span> <span class="s2">"disposable"</span>
</pre></div>

<p>With Cells 3.12, a new experimental concept enters the stage: Decorators in view models. As the view model should only contain logic related to presentation (which can get quite a bit), decorators - called <em>Twins</em> -  can be defined and automatically setup for your model.</p>

<p>Twins are a general concept in Trailblazer and are used everywhere where representers, forms, operations or cells need additional logic that has to be shared between layers. So, this extra step allows re-using your decorator for presentations other than the cell, e.g. in a JSON API, tests, etc.</p>

<p>Also, logic that simply doesn't belong to in a view-related class goes into a twin. That could be code to figure out if a user in logged in.</p>

<div class="highlight highlight-ruby"><pre><span class="k">class</span> <span class="nc">SongCell</span> <span class="o">&lt;</span> <span class="no">Cell</span><span class="o">::</span><span class="no">ViewModel</span>
  <span class="kp">include</span> <span class="no">Properties</span>

  <span class="k">class</span> <span class="nc">Twin</span> <span class="o">&lt;</span> <span class="no">Cell</span><span class="o">::</span><span class="no">Twin</span> <span class="c1"># this is your decorator</span>
    <span class="n">property</span> <span class="ss">:title</span>
    <span class="n">property</span> <span class="ss">:id</span>
    <span class="n">option</span> <span class="ss">:in_stock?</span>
  <span class="k">end</span>

  <span class="n">properties</span> <span class="no">Twin</span>

  <span class="k">def</span> <span class="nf">show</span>
    <span class="k">if</span> <span class="n">in_stock?</span>
      <span class="s2">"You're lucky </span><span class="si">#{</span><span class="n">title</span><span class="si">}</span><span class="s2"> (</span><span class="si">#{</span><span class="nb">id</span><span class="si">}</span><span class="s2">) is in stock!"</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre></div>

<p>In this example, we define the twin <em>in</em> the cell itself. That could be done anywhere, as long as you tell the cell where to find the twin (<code>properties Twin</code>).</p>

<h3>
<a name="user-content-creating-a-twin-cell" class="anchor" href="#creating-a-twin-cell" aria-hidden="true"><span class="octicon octicon-link"></span></a>Creating A Twin Cell</h3>

<p>You create your cell as follows.</p>

<div class="highlight highlight-ruby"><pre><span class="n">cell</span><span class="p">(</span><span class="s2">"song"</span><span class="p">,</span> <span class="no">Song</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">in_stock?</span><span class="p">:</span> <span class="kp">true</span><span class="p">)</span>
</pre></div>

<p>Internally, a twin is created from the arguments and passed to the view model. The view model cell now only works on the twin, not on the model anymore.</p>

<p>The twin simply acts as a delegator between the cell and the model: attributes defined with <code>property</code> are copied from the model, <code>option</code> values <em>have</em> to be passed explicitely to the constructor. The twin defines an <em>interface</em> for using your cell.</p>

<p>Another awesome thing is that you can now easily test your cell by "mocking" values.</p>

<div class="highlight highlight-ruby"><pre><span class="n">it</span> <span class="s2">"renders nicely"</span> <span class="k">do</span>
  <span class="n">cell</span><span class="p">(</span><span class="s2">"song"</span><span class="p">,</span> <span class="n">song</span><span class="p">,</span> <span class="n">in_stock?</span><span class="p">:</span> <span class="kp">true</span><span class="p">,</span> <span class="ss">title</span><span class="p">:</span> <span class="s2">"Mocked Song Title"</span><span class="p">)</span><span class="o">.</span><span class="n">must_match</span> <span class="o">.</span><span class="n">.</span><span class="o">.</span>
<span class="k">end</span>
</pre></div>

<p>The twin will simply use the passed <code>:title</code> and not copy the title from the song model, making it really easy to test edge cases in your view model.</p>

<h3>
<a name="user-content-extending-decorators" class="anchor" href="#extending-decorators" aria-hidden="true"><span class="octicon octicon-link"></span></a>Extending Decorators</h3>

<p>A decorator without any logic only gives you a tiny improvement, they become really helpful when including your own decorator logic.</p>

<div class="highlight highlight-ruby"><pre><span class="k">class</span> <span class="nc">Twin</span> <span class="o">&lt;</span> <span class="no">Cell</span><span class="o">::</span><span class="no">Twin</span> <span class="c1"># this is your decorator</span>
  <span class="n">property</span> <span class="ss">:title</span>
  <span class="n">property</span> <span class="ss">:id</span>
  <span class="n">option</span> <span class="ss">:in_stock?</span>

  <span class="k">def</span> <span class="nf">title</span>
    <span class="k">super</span><span class="o">.</span><span class="n">downcase</span> <span class="c1"># super to retrieve the original title from model!</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre></div>

<p>The same logic can now be used in a cell, a JSON or XML API endpoint or in the model layer.</p>

<p>Note: If there's enough interest, this could also be extended to work with draper and other decoration gems.</p>

<h3>
<a name="user-content-nested-rendering" class="anchor" href="#nested-rendering" aria-hidden="true"><span class="octicon octicon-link"></span></a>Nested Rendering</h3>

<p>When extracting parts of your view into a partial, as we did for the author section, you're free to render additional views using <code>#render</code>. Again, wrap render calls in instance methods, otherwise you'll end up with too much logic in your view.</p>

<div class="highlight highlight-ruby"><pre><span class="k">class</span> <span class="nc">SongCell</span> <span class="o">&lt;</span> <span class="no">Cell</span><span class="o">::</span><span class="no">ViewModel</span>
  <span class="kp">include</span> <span class="no">TimeagoHelper</span>

  <span class="n">property</span> <span class="ss">:title</span>

  <span class="c1"># ...</span>

  <span class="k">def</span> <span class="nf">author_box</span>
    <span class="n">render</span> <span class="ss">:author</span> <span class="c1"># same as render view: :author</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre></div>

<p>This will simply render the <code>author.haml</code> template in the same context as the <code>show</code> view, meaning you might use helpers, again.</p>

<h3>
<a name="user-content-encapsulation" class="anchor" href="#encapsulation" aria-hidden="true"><span class="octicon octicon-link"></span></a>Encapsulation</h3>

<p>If in doubt, encapsulate nested parts of your view into a separate cell. You can use the <code>#cell</code> method in your cell to instantiate a nested cell.</p>

<p>Designing view models to create kickass UIs for your domain layer is discussed in 50+ pages in <a href="http://nicksda.apotomo.de">my upcoming book</a>.</p>

<h3>
<a name="user-content-alternative-instantiation" class="anchor" href="#alternative-instantiation" aria-hidden="true"><span class="octicon octicon-link"></span></a>Alternative Instantiation</h3>

<p>You don't need to pass in a model, it can also be a hash for a composition.</p>

<div class="highlight highlight-ruby"><pre>  <span class="n">cell</span><span class="p">(</span><span class="n">album</span><span class="p">,</span> <span class="ss">song</span><span class="p">:</span> <span class="n">song</span><span class="p">,</span> <span class="ss">composer</span><span class="p">:</span> <span class="n">album</span><span class="o">.</span><span class="n">composer</span><span class="p">)</span>
</pre></div>

<p>This will create two readers in the cell for you automatically: <code>#song</code> and <code>#composer</code>.</p>

<p>Note that we are still working on a declarative API for compositions. It will be similar to the one found in Reform, Disposable::Twin and Representable:</p>

<div class="highlight highlight-ruby"><pre>  <span class="n">property</span> <span class="ss">:title</span><span class="p">,</span> <span class="ss">on</span><span class="p">:</span> <span class="ss">:song</span>
  <span class="n">property</span> <span class="ss">:last_name</span><span class="p">,</span> <span class="ss">on</span><span class="p">:</span> <span class="ss">:composer</span>
</pre></div>

<h2>
<a name="user-content-mountable-cells" class="anchor" href="#mountable-cells" aria-hidden="true"><span class="octicon octicon-link"></span></a>Mountable Cells</h2>

<p>Cells 3.8 got rid of the ActionController dependency. This essentially means you can mount Cells to routes or use them like a Rack middleware. All you need to do is derive from Cell::Base.</p>

<div class="highlight highlight-ruby"><pre><span class="k">class</span> <span class="nc">PostCell</span> <span class="o">&lt;</span> <span class="no">Cell</span><span class="o">::</span><span class="no">Base</span>
  <span class="o">.</span><span class="n">.</span><span class="o">.</span>
<span class="k">end</span>
</pre></div>

<p>In your <code>routes.rb</code> file, mount the cell like a Rack app.</p>

<div class="highlight highlight-ruby"><pre><span class="n">match</span> <span class="s2">"/posts"</span> <span class="o">=&gt;</span> <span class="nb">proc</span> <span class="p">{</span> <span class="o">|</span><span class="n">env</span><span class="o">|</span>
  <span class="o">[</span> <span class="mi">200</span><span class="p">,</span> <span class="p">{},</span> <span class="o">[</span> <span class="no">Cell</span><span class="o">::</span><span class="no">Base</span><span class="o">.</span><span class="n">render_cell_for</span><span class="p">(</span><span class="ss">:post</span><span class="p">,</span> <span class="ss">:show</span><span class="p">)</span> <span class="o">]]</span>
<span class="p">}</span>
</pre></div>

<h3>
<a name="user-content-cells-in-actionmailer" class="anchor" href="#cells-in-actionmailer" aria-hidden="true"><span class="octicon octicon-link"></span></a>Cells in ActionMailer</h3>

<p>ActionMailer doesn't have request object, so if you inherit from Cell::Rails you will receive an error. Cell::Base will fix that problem, but you will not be able to use any of routes inside your cells.</p>

<p>You can fix that with <a href="https://github.com/weppos/actionmailer_with_request">actionmailer_with_request</a> which (suprise!) brings request object to the ActionMailer.</p>

<h2>
<a name="user-content-using-rails-gems-like-simple_form-outside-of-rails" class="anchor" href="#using-rails-gems-like-simple_form-outside-of-rails" aria-hidden="true"><span class="octicon octicon-link"></span></a>Using Rails Gems Like simple_form Outside Of Rails</h2>

<p>Cells can be used outside of Rails. A new module brought in 3.8.5 provides the Rails view "API" making it possible to use gems like  the popular <a href="https://github.com/plataformatec/simple_form">simple_form</a> outside Rails!</p>

<p>All you need to do is providing the cell with some helpers, usually it's the polymorphic routing paths required by the gems.</p>

<div class="highlight highlight-ruby"><pre><span class="k">module</span> <span class="nn">RoutingHelpers</span>
  <span class="k">def</span> <span class="nf">musician_path</span><span class="p">(</span><span class="n">model</span><span class="p">)</span>
    <span class="s2">"/musicians/</span><span class="si">#{</span><span class="n">model</span><span class="o">.</span><span class="n">id</span><span class="si">}</span><span class="s2">"</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre></div>

<p>Then, use the Cell::Rails::HelperAPI module and it should work fine (depending on the quality of the gem you're desiring to use).</p>

<div class="highlight highlight-ruby"><pre><span class="nb">require</span> <span class="s1">'cell/base'</span>
<span class="nb">require</span> <span class="s2">"cell/rails/helper_api"</span>
<span class="nb">require</span> <span class="s2">"simple_form"</span>

<span class="k">class</span> <span class="nc">BassistCell</span> <span class="o">&lt;</span> <span class="no">Cell</span><span class="o">::</span><span class="no">Base</span>
  <span class="kp">include</span> <span class="no">Cell</span><span class="o">::</span><span class="no">Rails</span><span class="o">::</span><span class="no">HelperAPI</span>

  <span class="nb">self</span><span class="o">.</span><span class="n">_helpers</span> <span class="o">=</span> <span class="no">RoutingHelpers</span>

  <span class="k">def</span> <span class="nf">show</span>
    <span class="vi">@musician</span> <span class="o">=</span> <span class="no">Musician</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="ss">:first</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre></div>

<p>Your views can now use the gem's helpers.</p>

<div class="highlight highlight-erb"><pre><span class="cp">&lt;%=</span> <span class="n">simple_form_for</span> <span class="vi">@musician</span> <span class="k">do</span> <span class="o">|</span><span class="n">f</span><span class="o">|</span> <span class="cp">%&gt;</span><span class="x"></span>
<span class="x">  </span><span class="cp">&lt;%=</span> <span class="n">f</span><span class="o">.</span><span class="n">input</span> <span class="ss">:name</span> <span class="cp">%&gt;</span><span class="x"></span>
<span class="x">  </span><span class="cp">&lt;%=</span> <span class="n">f</span><span class="o">.</span><span class="n">button</span> <span class="ss">:submit</span> <span class="cp">%&gt;</span><span class="x"></span>
<span class="cp">&lt;%</span> <span class="k">end</span> <span class="cp">%&gt;</span><span class="x"></span>
</pre></div>

<p>Note that this currently "only" works with Rails 3.2-4.0.</p>

<h2>
<a name="user-content-cells-is-railsengine-aware" class="anchor" href="#cells-is-railsengine-aware" aria-hidden="true"><span class="octicon octicon-link"></span></a>Cells is Rails::Engine aware!</h2>

<p>Now <code>Rails::Engine</code>s can contribute to Cells view paths. By default, any 'app/cells' found inside any Engine is automatically included into Cells view paths. If you need to, you can customize the view paths changing/appending to the <code>'app/cell_views'</code> path configuration. See the <code>Cell::EngineIntegration</code> for more details.</p>

<h2>
<a name="user-content-generator-options" class="anchor" href="#generator-options" aria-hidden="true"><span class="octicon octicon-link"></span></a>Generator Options</h2>

<p>By default, generated cells inherit from <code>Cell::Rails</code>. If you want to change this, specify your new class name in <code>config/application.rb</code>:</p>

<h3>
<a name="user-content-base-class" class="anchor" href="#base-class" aria-hidden="true"><span class="octicon octicon-link"></span></a>Base Class</h3>

<div class="highlight highlight-ruby"><pre><span class="k">module</span> <span class="nn">MyApp</span>
  <span class="k">class</span> <span class="nc">Application</span> <span class="o">&lt;</span> <span class="no">Rails</span><span class="o">::</span><span class="no">Application</span>
    <span class="n">config</span><span class="o">.</span><span class="n">generators</span> <span class="k">do</span> <span class="o">|</span><span class="n">g</span><span class="o">|</span>
      <span class="n">g</span><span class="o">.</span><span class="n">base_cell_class</span> <span class="s2">"ApplicationCell"</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre></div>

<h3>
<a name="user-content-base-path" class="anchor" href="#base-path" aria-hidden="true"><span class="octicon octicon-link"></span></a>Base Path</h3>

<p>You can configure the cells path in case your cells don't reside in <code>app/cells</code>.</p>

<div class="highlight highlight-ruby"><pre><span class="n">config</span><span class="o">.</span><span class="n">generators</span> <span class="k">do</span> <span class="o">|</span><span class="n">g</span><span class="o">|</span>
  <span class="n">g</span><span class="o">.</span><span class="n">base_cell_path</span> <span class="s2">"app/widgets"</span>
<span class="k">end</span>
</pre></div>

<h2>
<a name="user-content-rails-23-note" class="anchor" href="#rails-23-note" aria-hidden="true"><span class="octicon octicon-link"></span></a>Rails 2.3 note</h2>

<h3>
<a name="user-content-installation-1" class="anchor" href="#installation-1" aria-hidden="true"><span class="octicon octicon-link"></span></a>Installation</h3>

<pre lang="shell"><code>gem install cells -v 3.3.9
</code></pre>

<p>In order to copy the cells rake tasks to your app, run</p>

<pre lang="shell"><code>script/generate cells_install
</code></pre>

<h2>
<a name="user-content-capture-support" class="anchor" href="#capture-support" aria-hidden="true"><span class="octicon octicon-link"></span></a>Capture Support</h2>

<p>If you need a global <code>#content_for</code> use the <a href="https://github.com/apotonick/cells-capture">cells-capture</a> gem.</p>

<h2>
<a name="user-content-more-features" class="anchor" href="#more-features" aria-hidden="true"><span class="octicon octicon-link"></span></a>More features</h2>

<p>Cells can do more.</p>

<ul class="task-list">
<li>
<strong>No Limits</strong>. Have as many cells in your page as you need - no limitation to your <code>render_cell</code> calls.</li>
<li>
<strong>Cell Nesting</strong>. Have complex cell hierarchies as you can call <code>render_cell</code> within cells, too.</li>
</ul><p>Go for it, you'll love it!</p>

<h2>
<a name="user-content-license" class="anchor" href="#license" aria-hidden="true"><span class="octicon octicon-link"></span></a>LICENSE</h2>

<p>Copyright (c) 2007-2014, Nick Sutterer</p>

<p>Copyright (c) 2007-2008, Solide ICT by Peter Bex and Bob Leers</p>

<p>Released under the MIT License.</p></article></div>