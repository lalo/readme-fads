<div class="announce instapaper_body markdown" data-path="README.markdown" id="readme"><article class="markdown-body entry-content" itemprop="mainContentOfPage"><h1>
<a name="user-content-analytics" class="anchor" href="#analytics" aria-hidden="true"><span class="octicon octicon-link"></span></a>analytics</h1>

<p><a href="http://travis-ci.org/analytics/analytics"><img src="https://camo.githubusercontent.com/2f1a2a6f71b733e6901f96401321f9ed1409b7a1/68747470733a2f2f7365637572652e7472617669732d63692e6f72672f616e616c79746963732f616e616c79746963732e706e673f6272616e63683d6d6173746572" alt="Build Status" data-canonical-src="https://secure.travis-ci.org/analytics/analytics.png?branch=master" style="max-width:100%;"></a></p>

<p>This is a work-in progress project for working with declarative Datalog style programs as an embedded domain-specific language in Haskell.</p>

<p>The current focus is on getting a rich Datalog-esque EDSL that works nicely as a monad transformer, so you can mix and match it with
tools from other domains.</p>

<p>Skim the <a href="https://github.com/analytics/analytics/tree/master/examples">examples folder</a> to get started for now.</p>

<p>Using <code>X</code>, <code>Y</code> and <code>Z</code> as <code>Node</code> variables, and <code>A</code> <code>B</code> and <code>C</code> as <code>Node</code> entities:</p>

<div class="highlight highlight-haskell"><pre><span class="nf">test</span> <span class="ow">::</span> <span class="kt">Datalog</span> <span class="p">[</span><span class="kt">Edge</span><span class="p">]</span>
<span class="nf">test</span> <span class="ow">=</span> <span class="kr">do</span>
  <span class="n">edge</span> <span class="kt">A</span> <span class="kt">B</span>
  <span class="n">edge</span> <span class="kt">B</span> <span class="kt">C</span>
  <span class="n">edge</span> <span class="kt">B</span> <span class="kt">A</span>
  <span class="n">tc</span> <span class="kt">X</span> <span class="kt">Y</span> <span class="kt">:-</span> <span class="n">edge</span> <span class="kt">X</span> <span class="kt">Y</span>
  <span class="n">tc</span> <span class="kt">X</span> <span class="kt">Z</span> <span class="kt">:-</span> <span class="n">tc</span> <span class="kt">X</span> <span class="kt">Y</span> <span class="o">&lt;*</span> <span class="n">edge</span> <span class="kt">Y</span> <span class="kt">Z</span>
  <span class="n">query</span> <span class="o">$</span> <span class="n">row</span> <span class="p">(</span><span class="n">tc</span> <span class="kt">A</span> <span class="kt">X</span><span class="p">)</span> <span class="o">&lt;*</span> <span class="n">no</span> <span class="p">(</span><span class="n">edge</span> <span class="kt">X</span> <span class="kt">C</span><span class="p">)</span>
</pre></div>

<h2>
<a name="user-content-contact-information" class="anchor" href="#contact-information" aria-hidden="true"><span class="octicon octicon-link"></span></a>Contact Information</h2>

<p>Contributions and bug reports are welcome!</p>

<p>Please feel free to contact me through github or on the #haskell-lens IRC channel on irc.freenode.net.</p>

<p>-Edward Kmett</p></article></div>