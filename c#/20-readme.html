<div class="announce instapaper_body markdown" data-path="README.markdown" id="readme"><article class="markdown-body entry-content" itemprop="mainContentOfPage"><p>This is the master repository for Ninject, the lightweight and lightning-fast .NET dependency injection framework. Ninject is currently in version 2.2.</p>

<p><em>If you're reading blog posts or books from before 2010, they're likely to be regarding version 1, which has <a href="https://github.com/ninject/ninject/wiki/Changes-in-Ninject-2">some key improvements, summarised in the wiki</a></em></p>

<ul class="task-list">
<li><a href="http://ninject.org/">Project website</a></li>
<li><p><a href="http://ninject.org/learn">Documentation</a></p></li>
<li><p><a href="http://kohari.org/">Nate's blog</a></p></li>
<li><a href="http://innovatian.com/">Ian's blog</a></li>
<li><a href="http://www.planetgeek.ch/author/remo-gloor/">Remo's blog</a></li>
</ul><p>Ninject is a lightning-fast, ultra-lightweight dependency injector for .NET applications. It helps you split your
application into a collection of loosely-coupled, highly-cohesive pieces, and then glue them back together in a
flexible manner. By using Ninject to support your software's architecture, your code will become easier to write,
reuse, test, and modify.</p>

<p>Ninject is:</p>

<ol class="task-list">
<li><p>Focused. Too many existing dependency injection projects sacrifice usability for features that aren't often necessary.
Each time a feature is added to Ninject, its benefit is weighed against the complexity it adds to everyday use. Our goal
is to keep the barrier to entry - the baseline level of knowledge required to use Ninject - as low as possible. Ninject
has many advanced features, but understanding them is not required to use the basic features.</p></li>
<li><p>Sleek. Framework bloat is a major concern for some projects, and as such, all of Ninject's core functionality is in a
single assembly with no dependencies outside the .NET base class library. This single assembly's footprint is approximately
85KB when compiled for release.</p></li>
<li><p>Fast. Instead of relying on reflection for invocation, Ninject takes advantage of lightweight code generation in the CLR.
This can result in a dramatic (8-50x) improvement in performance in many situations.</p></li>
<li><p>Precise. Ninject helps developers get things right the first time around. Rather than relying on XML mapping files and
string identifiers to wire up components, Ninject provides a robust domain-specific language. This means that Ninject
takes advantage of the capabilities of the language (like type-safety) and the IDE (like IntelliSense and code completion).</p></li>
<li><p>Agile. Ninject is designed around a component-based architecture, with customization and evolution in mind. Many facets
of the system can be augmented or modified to fit the requirements of each project.</p></li>
<li><p>Stealthy. Ninject will not invade your code. You can easily isolate the dependency on Ninject to a single assembly in
your project.</p></li>
<li><p>Powerful. Ninject includes many advanced features. For example, Ninject is the first dependency injector to support
contextual binding, in which a different concrete implementation of a service may be injected depending on the context in
which it is requested.</p></li>
</ol><h2>
<a name="user-content-everything-else-is-in-extensions" class="anchor" href="#everything-else-is-in-extensions" aria-hidden="true"><span class="octicon octicon-link"></span></a>Everything else is in Extensions</h2>

<p>Yes, sounds slim and focused, but where is the support for all the features that the competitors have? </p>

<p>Generally, they are maintained as specific focused extensions with owners who keep them in sync and pull in new ideas and fixes fast. These are summarized on the <a href="http://ninject.org/extensions">extensions</a> section of the project website. Most are hosted alongside the core project right here.</p></article></div>